
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


!(function (t, e) { typeof exports === "object" && typeof module !== "undefined" ? e(exports) : typeof define === "function" && define.amd ? define(["exports"], e) : e(t.echarts = {}); }(this, (t) => {
  function e(t, e) { t === "createCanvas" && (nw = null), ew[t] = e; } function i(t) { if (t == null || typeof t !== "object") return t; let e = t; const n = Y_.call(t); if (n === "[object Array]") { if (!O(t)) { e = []; for (var o = 0, a = t.length; o < a; o++)e[o] = i(t[o]); } } else if (j_[n]) { if (!O(t)) { const r = t.constructor; if (t.constructor.from)e = r.from(t); else { e = new r(t.length); for (var o = 0, a = t.length; o < a; o++)e[o] = i(t[o]); } } } else if (!X_[n] && !O(t) && !M(t)) { e = {}; for (const s in t)t.hasOwnProperty(s) && (e[s] = i(t[s])); } return e; } function n(t, e, o) { if (!w(e) || !w(t)) return o ? i(e) : t; for (const a in e) if (e.hasOwnProperty(a)) { const r = t[a]; const s = e[a]; !w(s) || !w(r) || y(s) || y(r) || M(s) || M(r) || b(s) || b(r) || O(s) || O(r) ? !o && a in t || (t[a] = i(e[a], !0)) : n(r, s, o); } return t; } function o(t, e) { for (var i = t[0], o = 1, a = t.length; o < a; o++)i = n(i, t[o], e); return i; } function a(t, e) { for (const i in e)e.hasOwnProperty(i) && (t[i] = e[i]); return t; } function r(t, e, i) { for (const n in e)e.hasOwnProperty(n) && (i ? e[n] != null : t[n] == null) && (t[n] = e[n]); return t; } function s() { return nw || (nw = iw().getContext("2d")), nw; } function l(t, e) { if (t) { if (t.indexOf) return t.indexOf(e); for (let i = 0, n = t.length; i < n; i++) if (t[i] === e) return i; } return -1; } function u(t, e) { function i() {} const n = t.prototype; i.prototype = e.prototype, t.prototype = new i(); for (const o in n)t.prototype[o] = n[o]; t.prototype.constructor = t, t.superClass = e; } function h(t, e, i) { r(t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, i); } function c(t) { if (t) return typeof t !== "string" && typeof t.length === "number"; } function d(t, e, i) { if (t && e) if (t.forEach && t.forEach === K_)t.forEach(e, i); else if (t.length === +t.length) for (let n = 0, o = t.length; n < o; n++)e.call(i, t[n], n, t); else for (const a in t)t.hasOwnProperty(a) && e.call(i, t[a], a, t); } function f(t, e, i) { if (t && e) { if (t.map && t.map === Q_) return t.map(e, i); for (var n = [], o = 0, a = t.length; o < a; o++)n.push(e.call(i, t[o], o, t)); return n; } } function p(t, e, i, n) { if (t && e) { if (t.reduce && t.reduce === tw) return t.reduce(e, i, n); for (let o = 0, a = t.length; o < a; o++)i = e.call(n, i, t[o], o, t); return i; } } function g(t, e, i) { if (t && e) { if (t.filter && t.filter === $_) return t.filter(e, i); for (var n = [], o = 0, a = t.length; o < a; o++)e.call(i, t[o], o, t) && n.push(t[o]); return n; } } function m(t, e) { const i = J_.call(arguments, 2); return function () { return t.apply(e, i.concat(J_.call(arguments))); }; } function v(t) { const e = J_.call(arguments, 1); return function () { return t.apply(this, e.concat(J_.call(arguments))); }; } function y(t) { return Y_.call(t) === "[object Array]"; } function x(t) { return typeof t === "function"; } function _(t) { return Y_.call(t) === "[object String]"; } function w(t) { const e = typeof t; return e === "function" || !!t && e === "object"; } function b(t) { return !!X_[Y_.call(t)]; } function S(t) { return !!j_[Y_.call(t)]; } function M(t) { return typeof t === "object" && typeof t.nodeType === "number" && typeof t.ownerDocument === "object"; } function I(t) { return t !== t; } function T(t) { for (let e = 0, i = arguments.length; e < i; e++) if (arguments[e] != null) return arguments[e]; } function A(t, e) { return t != null ? t : e; } function D(t, e, i) { return t != null ? t : e != null ? e : i; } function C() { return Function.call.apply(J_, arguments); } function L(t) { if (typeof t === "number") return [t, t, t, t]; const e = t.length; return e === 2 ? [t[0], t[1], t[0], t[1]] : e === 3 ? [t[0], t[1], t[2], t[1]] : t; } function k(t, e) { if (!t) throw new Error(e); } function P(t) { return t == null ? null : typeof t.trim === "function" ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); } function N(t) { t[ow] = !0; } function O(t) { return t[ow]; } function E(t) { function e(t, e) { i ? n.set(t, e) : n.set(e, t); } var i = y(t); this.data = {}; var n = this; t instanceof E ? t.each(e) : t && d(t, e); } function R(t) { return new E(t); } function z(t, e) { for (var i = new t.constructor(t.length + e.length), n = 0; n < t.length; n++)i[n] = t[n]; const o = t.length; for (n = 0; n < e.length; n++)i[n + o] = e[n]; return i; } function B() {} function V(t, e) { const i = new rw(2); return t == null && (t = 0), e == null && (e = 0), i[0] = t, i[1] = e, i; } function G(t, e) { return t[0] = e[0], t[1] = e[1], t; } function F(t) { const e = new rw(2); return e[0] = t[0], e[1] = t[1], e; } function W(t, e, i) { return t[0] = e, t[1] = i, t; } function H(t, e, i) { return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t; } function Z(t, e, i, n) { return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t; } function U(t, e, i) { return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t; } function X(t) { return Math.sqrt(j(t)); } function j(t) { return t[0] * t[0] + t[1] * t[1]; } function Y(t, e, i) { return t[0] = e[0] * i, t[1] = e[1] * i, t; } function q(t, e) { const i = X(e); return i === 0 ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t; } function K(t, e) { return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])); } function $(t, e) { return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]); } function J(t, e, i, n) { return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t; } function Q(t, e, i) { const n = e[0]; const o = e[1]; return t[0] = i[0] * n + i[2] * o + i[4], t[1] = i[1] * n + i[3] * o + i[5], t; } function tt(t, e, i) { return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t; } function et(t, e, i) { return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t; } function it() { this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this); } function nt(t, e) { return { target: t, topTarget: e && e.topTarget }; } function ot(t, e) { const i = t._$eventProcessor; return e != null && i && i.normalizeQuery && (e = i.normalizeQuery(e)), e; } function at(t, e, i, n, o, a) {
    const r = t._$handlers; if (typeof i === "function" && (o = n, n = i, i = null), !n || !e) return t; i = ot(t, i), r[e] || (r[e] = []); for (let s = 0; s < r[e].length; s++) if (r[e][s].h === n) return t; const l = {
      h: n, one: a, query: i, ctx: o || t, callAtLast: n.zrEventfulCallAtLast,
    }; const u = r[e].length - 1; const h = r[e][u]; return h && h.callAtLast ? r[e].splice(u, 0, l) : r[e].push(l), t;
  } function rt(t) { return t.getBoundingClientRect ? t.getBoundingClientRect() : { left: 0, top: 0 }; } function st(t, e, i, n) { return i = i || {}, n || !U_.canvasSupported ? lt(t, e, i) : U_.browser.firefox && e.layerX != null && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : e.offsetX != null ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : lt(t, e, i), i; } function lt(t, e, i) { const n = rt(t); i.zrX = e.clientX - n.left, i.zrY = e.clientY - n.top; } function ut(t, e, i) { if ((e = e || window.event).zrX != null) return e; const n = e.type; if (n && n.indexOf("touch") >= 0) { const o = n !== "touchend" ? e.targetTouches[0] : e.changedTouches[0]; o && st(t, o, e, i); } else st(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3; const a = e.button; return e.which == null && void 0 !== a && gw.test(e.type) && (e.which = 1 & a ? 1 : 2 & a ? 3 : 4 & a ? 2 : 0), e; } function ht(t, e, i) { pw ? t.addEventListener(e, i) : t.attachEvent(`on${e}`, i); } function ct(t, e, i) { pw ? t.removeEventListener(e, i) : t.detachEvent(`on${e}`, i); } function dt(t) { return t.which === 2 || t.which === 3; } function ft(t) { const e = t[1][0] - t[0][0]; const i = t[1][1] - t[0][1]; return Math.sqrt(e * e + i * i); } function pt(t) { return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]; } function gt(t, e, i) {
    return {
      type: t, event: i, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: i.zrX, offsetY: i.zrY, gestureEvent: i.gestureEvent, pinchX: i.pinchX, pinchY: i.pinchY, pinchScale: i.pinchScale, wheelDelta: i.zrDelta, zrByTouch: i.zrByTouch, which: i.which, stop: mt,
    };
  } function mt(t) { mw(this.event); } function vt() {} function yt(t, e, i) { if (t[t.rectHover ? "rectContain" : "contain"](e, i)) { for (var n, o = t; o;) { if (o.clipPath && !o.clipPath.contain(e, i)) return !1; o.silent && (n = !0), o = o.parent; } return !n || xw; } return !1; } function xt() { const t = new bw(6); return _t(t), t; } function _t(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t; } function wt(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t; } function bt(t, e, i) { const n = e[0] * i[0] + e[2] * i[1]; const o = e[1] * i[0] + e[3] * i[1]; const a = e[0] * i[2] + e[2] * i[3]; const r = e[1] * i[2] + e[3] * i[3]; const s = e[0] * i[4] + e[2] * i[5] + e[4]; const l = e[1] * i[4] + e[3] * i[5] + e[5]; return t[0] = n, t[1] = o, t[2] = a, t[3] = r, t[4] = s, t[5] = l, t; } function St(t, e, i) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t; } function Mt(t, e, i) { const n = e[0]; const o = e[2]; const a = e[4]; const r = e[1]; const s = e[3]; const l = e[5]; const u = Math.sin(i); const h = Math.cos(i); return t[0] = n * h + r * u, t[1] = -n * u + r * h, t[2] = o * h + s * u, t[3] = -o * u + h * s, t[4] = h * a + u * l, t[5] = h * l - u * a, t; } function It(t, e, i) { const n = i[0]; const o = i[1]; return t[0] = e[0] * n, t[1] = e[1] * o, t[2] = e[2] * n, t[3] = e[3] * o, t[4] = e[4] * n, t[5] = e[5] * o, t; } function Tt(t, e) { const i = e[0]; const n = e[2]; const o = e[4]; const a = e[1]; const r = e[3]; const s = e[5]; let l = i * r - a * n; return l ? (l = 1 / l, t[0] = r * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - r * o) * l, t[5] = (a * o - i * s) * l, t) : null; } function At(t) { const e = xt(); return wt(e, t), e; } function Dt(t) { return t > Iw || t < -Iw; } function Ct(t) { this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = t.loop != null && t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1; } function Lt(t) { return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t; } function kt(t) { return (t = Math.round(t)) < 0 ? 0 : t > 360 ? 360 : t; } function Pt(t) { return t < 0 ? 0 : t > 1 ? 1 : t; } function Nt(t) { return Lt(t.length && t.charAt(t.length - 1) === "%" ? parseFloat(t) / 100 * 255 : parseInt(t, 10)); } function Ot(t) { return Pt(t.length && t.charAt(t.length - 1) === "%" ? parseFloat(t) / 100 : parseFloat(t)); } function Et(t, e, i) { return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t; } function Rt(t, e, i) { return t + (e - t) * i; } function zt(t, e, i, n, o) { return t[0] = e, t[1] = i, t[2] = n, t[3] = o, t; } function Bt(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t; } function Vt(t, e) { Vw && Bt(Vw, e), Vw = Bw.put(t, Vw || e.slice()); } function Gt(t, e) { if (t) { e = e || []; const i = Bw.get(t); if (i) return Bt(e, i); const n = (t += "").replace(/ /g, "").toLowerCase(); if (n in zw) return Bt(e, zw[n]), Vt(t, e), e; if (n.charAt(0) !== "#") { const o = n.indexOf("("); const a = n.indexOf(")"); if (o !== -1 && a + 1 === n.length) { const r = n.substr(0, o); const s = n.substr(o + 1, a - (o + 1)).split(","); let l = 1; switch (r) { case "rgba": if (s.length !== 4) return void zt(e, 0, 0, 0, 1); l = Ot(s.pop()); case "rgb": return s.length !== 3 ? void zt(e, 0, 0, 0, 1) : (zt(e, Nt(s[0]), Nt(s[1]), Nt(s[2]), l), Vt(t, e), e); case "hsla": return s.length !== 4 ? void zt(e, 0, 0, 0, 1) : (s[3] = Ot(s[3]), Ft(s, e), Vt(t, e), e); case "hsl": return s.length !== 3 ? void zt(e, 0, 0, 0, 1) : (Ft(s, e), Vt(t, e), e); default: return; } }zt(e, 0, 0, 0, 1); } else { if (n.length === 4) return (u = parseInt(n.substr(1), 16)) >= 0 && u <= 4095 ? (zt(e, (3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1), Vt(t, e), e) : void zt(e, 0, 0, 0, 1); if (n.length === 7) { var u = parseInt(n.substr(1), 16); return u >= 0 && u <= 16777215 ? (zt(e, (16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1), Vt(t, e), e) : void zt(e, 0, 0, 0, 1); } } } } function Ft(t, e) { const i = (parseFloat(t[0]) % 360 + 360) % 360 / 360; const n = Ot(t[1]); const o = Ot(t[2]); const a = o <= 0.5 ? o * (n + 1) : o + n - o * n; const r = 2 * o - a; return e = e || [], zt(e, Lt(255 * Et(r, a, i + 1 / 3)), Lt(255 * Et(r, a, i)), Lt(255 * Et(r, a, i - 1 / 3)), 1), t.length === 4 && (e[3] = t[3]), e; } function Wt(t) { if (t) { let e; let i; const n = t[0] / 255; const o = t[1] / 255; const a = t[2] / 255; const r = Math.min(n, o, a); const s = Math.max(n, o, a); const l = s - r; const u = (s + r) / 2; if (l === 0)e = 0, i = 0; else { i = u < 0.5 ? l / (s + r) : l / (2 - s - r); const h = ((s - n) / 6 + l / 2) / l; const c = ((s - o) / 6 + l / 2) / l; const d = ((s - a) / 6 + l / 2) / l; n === s ? e = d - c : o === s ? e = 1 / 3 + h - d : a === s && (e = 2 / 3 + c - h), e < 0 && (e += 1), e > 1 && (e -= 1); } const f = [360 * e, i, u]; return t[3] != null && f.push(t[3]), f; } } function Ht(t, e) { const i = Gt(t); if (i) { for (let n = 0; n < 3; n++)i[n] = e < 0 ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0, i[n] > 255 ? i[n] = 255 : t[n] < 0 && (i[n] = 0); return qt(i, i.length === 4 ? "rgba" : "rgb"); } } function Zt(t) { const e = Gt(t); if (e) return ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1); } function Ut(t, e, i) { if (e && e.length && t >= 0 && t <= 1) { i = i || []; const n = t * (e.length - 1); const o = Math.floor(n); const a = Math.ceil(n); const r = e[o]; const s = e[a]; const l = n - o; return i[0] = Lt(Rt(r[0], s[0], l)), i[1] = Lt(Rt(r[1], s[1], l)), i[2] = Lt(Rt(r[2], s[2], l)), i[3] = Pt(Rt(r[3], s[3], l)), i; } } function Xt(t, e, i) {
    if (e && e.length && t >= 0 && t <= 1) {
      const n = t * (e.length - 1); const o = Math.floor(n); const a = Math.ceil(n); const r = Gt(e[o]); const s = Gt(e[a]); const l = n - o; const u = qt([Lt(Rt(r[0], s[0], l)), Lt(Rt(r[1], s[1], l)), Lt(Rt(r[2], s[2], l)), Pt(Rt(r[3], s[3], l))], "rgba"); return i ? {
        color: u, leftIndex: o, rightIndex: a, value: n,
      } : u;
    }
  } function jt(t, e, i, n) { if (t = Gt(t)) return t = Wt(t), e != null && (t[0] = kt(e)), i != null && (t[1] = Ot(i)), n != null && (t[2] = Ot(n)), qt(Ft(t), "rgba"); } function Yt(t, e) { if ((t = Gt(t)) && e != null) return t[3] = Pt(e), qt(t, "rgba"); } function qt(t, e) { if (t && t.length) { let i = `${t[0]},${t[1]},${t[2]}`; return e !== "rgba" && e !== "hsva" && e !== "hsla" || (i += `,${t[3]}`), `${e}(${i})`; } } function Kt(t, e) { return t[e]; } function $t(t, e, i) { t[e] = i; } function Jt(t, e, i) { return (e - t) * i + t; } function Qt(t, e, i) { return i > 0.5 ? e : t; } function te(t, e, i, n, o) { const a = t.length; if (o === 1) for (s = 0; s < a; s++)n[s] = Jt(t[s], e[s], i); else for (var r = a && t[0].length, s = 0; s < a; s++) for (let l = 0; l < r; l++)n[s][l] = Jt(t[s][l], e[s][l], i); } function ee(t, e, i) { const n = t.length; const o = e.length; if (n !== o) if (n > o)t.length = o; else for (r = n; r < o; r++)t.push(i === 1 ? e[r] : Hw.call(e[r])); for (var a = t[0] && t[0].length, r = 0; r < t.length; r++) if (i === 1)isNaN(t[r]) && (t[r] = e[r]); else for (let s = 0; s < a; s++)isNaN(t[r][s]) && (t[r][s] = e[r][s]); } function ie(t, e, i) { if (t === e) return !0; const n = t.length; if (n !== e.length) return !1; if (i === 1) { for (a = 0; a < n; a++) if (t[a] !== e[a]) return !1; } else for (var o = t[0].length, a = 0; a < n; a++) for (let r = 0; r < o; r++) if (t[a][r] !== e[a][r]) return !1; return !0; } function ne(t, e, i, n, o, a, r, s, l) { const u = t.length; if (l === 1) for (c = 0; c < u; c++)s[c] = oe(t[c], e[c], i[c], n[c], o, a, r); else for (var h = t[0].length, c = 0; c < u; c++) for (let d = 0; d < h; d++)s[c][d] = oe(t[c][d], e[c][d], i[c][d], n[c][d], o, a, r); } function oe(t, e, i, n, o, a, r) { const s = 0.5 * (i - t); const l = 0.5 * (n - e); return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * a + s * o + e; } function ae(t) { if (c(t)) { const e = t.length; if (c(t[0])) { for (var i = [], n = 0; n < e; n++)i.push(Hw.call(t[n])); return i; } return Hw.call(t); } return t; } function re(t) { return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), `rgba(${t.join(",")})`; } function se(t) { const e = t[t.length - 1].value; return c(e && e[0]) ? 2 : 1; } function le(t, e, i, n, o, a) {
    const r = t._getter; const s = t._setter; const l = e === "spline"; const u = n.length; if (u) {
      let h; const d = c(n[0].value); let f = !1; let p = !1; const g = d ? se(n) : 0; n.sort((t, e) => t.time - e.time), h = n[u - 1].time; for (var m = [], v = [], y = n[0].value, x = !0, _ = 0; _ < u; _++) { m.push(n[_].time / h); let w = n[_].value; if (d && ie(w, y, g) || !d && w === y || (x = !1), y = w, typeof w === "string") { const b = Gt(w); b ? (w = b, f = !0) : p = !0; }v.push(w); } if (a || !x) {
        for (var S = v[u - 1], _ = 0; _ < u - 1; _++)d ? ee(v[_], S, g) : !isNaN(v[_]) || isNaN(S) || p || f || (v[_] = S); d && ee(r(t._target, o), S, g); let M; let I; let T; let A; let D; let C; let L = 0; let k = 0; if (f) var P = [0, 0, 0, 0]; const N = new Ct({
          target: t._target, life: h, loop: t._loop, delay: t._delay, onframe(t, e) { let i; if (e < 0)i = 0; else if (e < k) { for (i = M = Math.min(L + 1, u - 1); i >= 0 && !(m[i] <= e); i--);i = Math.min(i, u - 2); } else { for (i = L; i < u && !(m[i] > e); i++);i = Math.min(i - 1, u - 2); }L = i, k = e; const n = m[i + 1] - m[i]; if (n !== 0) if (I = (e - m[i]) / n, l) if (A = v[i], T = v[i === 0 ? i : i - 1], D = v[i > u - 2 ? u - 1 : i + 1], C = v[i > u - 3 ? u - 1 : i + 2], d)ne(T, A, D, C, I, I * I, I * I * I, r(t, o), g); else { if (f)a = ne(T, A, D, C, I, I * I, I * I * I, P, 1), a = re(P); else { if (p) return Qt(A, D, I); a = oe(T, A, D, C, I, I * I, I * I * I); }s(t, o, a); } else if (d)te(v[i], v[i + 1], I, r(t, o), g); else { var a; if (f)te(v[i], v[i + 1], I, P, 1), a = re(P); else { if (p) return Qt(v[i], v[i + 1], I); a = Jt(v[i], v[i + 1], I); }s(t, o, a); } }, ondestroy: i,
        }); return e && e !== "spline" && (N.easing = e), N;
      }
    }
  } function ue(t, e, i, n, o, a, r, s) { _(n) ? (a = o, o = n, n = 0) : x(o) ? (a = o, o = "linear", n = 0) : x(n) ? (a = n, n = 0) : x(i) ? (a = i, i = 500) : i || (i = 500), t.stopAnimation(), he(t, "", t, e, i, n, s); const l = t.animators.slice(); let u = l.length; u || a && a(); for (let h = 0; h < l.length; h++)l[h].done(() => { --u || a && a(); }).start(o, r); } function he(t, e, i, n, o, a, r) { const s = {}; let l = 0; for (const u in n)n.hasOwnProperty(u) && (i[u] != null ? w(n[u]) && !c(n[u]) ? he(t, e ? `${e}.${u}` : u, i[u], n[u], o, a, r) : (r ? (s[u] = i[u], ce(t, e, u, n[u])) : s[u] = n[u], l++) : n[u] == null || r || ce(t, e, u, n[u])); l > 0 && t.animate(e, !1).when(o == null ? 500 : o, s).delay(a || 0); } function ce(t, e, i, n) { if (e) { const o = {}; o[e] = {}, o[e][i] = n, t.attr(o); } else t.attr(i, n); } function de(t, e, i, n) { i < 0 && (t += i, i = -i), n < 0 && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n; } function fe(t) { for (var e = 0; t >= eb;)e |= 1 & t, t >>= 1; return t + e; } function pe(t, e, i, n) { let o = e + 1; if (o === i) return 1; if (n(t[o++], t[e]) < 0) { for (;o < i && n(t[o], t[o - 1]) < 0;)o++; ge(t, e, o); } else for (;o < i && n(t[o], t[o - 1]) >= 0;)o++; return o - e; } function ge(t, e, i) { for (i--; e < i;) { const n = t[e]; t[e++] = t[i], t[i--] = n; } } function me(t, e, i, n, o) { for (n === e && n++; n < i; n++) { for (var a, r = t[n], s = e, l = n; s < l;)o(r, t[a = s + l >>> 1]) < 0 ? l = a : s = a + 1; let u = n - s; switch (u) { case 3: t[s + 3] = t[s + 2]; case 2: t[s + 2] = t[s + 1]; case 1: t[s + 1] = t[s]; break; default: for (;u > 0;)t[s + u] = t[s + u - 1], u--; }t[s] = r; } } function ve(t, e, i, n, o, a) { let r = 0; let s = 0; let l = 1; if (a(t, e[i + o]) > 0) { for (s = n - o; l < s && a(t, e[i + o + l]) > 0;)r = l, (l = 1 + (l << 1)) <= 0 && (l = s); l > s && (l = s), r += o, l += o; } else { for (s = o + 1; l < s && a(t, e[i + o - l]) <= 0;)r = l, (l = 1 + (l << 1)) <= 0 && (l = s); l > s && (l = s); const u = r; r = o - l, l = o - u; } for (r++; r < l;) { const h = r + (l - r >>> 1); a(t, e[i + h]) > 0 ? r = h + 1 : l = h; } return l; } function ye(t, e, i, n, o, a) { let r = 0; let s = 0; let l = 1; if (a(t, e[i + o]) < 0) { for (s = o + 1; l < s && a(t, e[i + o - l]) < 0;)r = l, (l = 1 + (l << 1)) <= 0 && (l = s); l > s && (l = s); const u = r; r = o - l, l = o - u; } else { for (s = n - o; l < s && a(t, e[i + o + l]) >= 0;)r = l, (l = 1 + (l << 1)) <= 0 && (l = s); l > s && (l = s), r += o, l += o; } for (r++; r < l;) { const h = r + (l - r >>> 1); a(t, e[i + h]) < 0 ? l = h : r = h + 1; } return l; } function xe(t, e) { function i(i) { let s = a[i]; let u = r[i]; const h = a[i + 1]; let c = r[i + 1]; r[i] = u + c, i === l - 3 && (a[i + 1] = a[i + 2], r[i + 1] = r[i + 2]), l--; const d = ye(t[h], t, s, u, 0, e); s += d, (u -= d) !== 0 && (c = ve(t[s + u - 1], t, h, c, c - 1, e)) !== 0 && (u <= c ? n(s, u, h, c) : o(s, u, h, c)); } function n(i, n, o, a) { let r = 0; for (r = 0; r < n; r++)u[r] = t[i + r]; let l = 0; let h = o; let c = i; if (t[c++] = t[h++], --a != 0) if (n !== 1) { for (var d, f, p, g = s; ;) { d = 0, f = 0, p = !1; do { if (e(t[h], u[l]) < 0) { if (t[c++] = t[h++], f++, d = 0, --a == 0) { p = !0; break; } } else if (t[c++] = u[l++], d++, f = 0, --n == 1) { p = !0; break; } } while ((d | f) < g);if (p) break; do { if ((d = ye(t[h], u, l, n, 0, e)) !== 0) { for (r = 0; r < d; r++)t[c + r] = u[l + r]; if (c += d, l += d, (n -= d) <= 1) { p = !0; break; } } if (t[c++] = t[h++], --a == 0) { p = !0; break; } if ((f = ve(u[l], t, h, a, 0, e)) !== 0) { for (r = 0; r < f; r++)t[c + r] = t[h + r]; if (c += f, h += f, (a -= f) === 0) { p = !0; break; } } if (t[c++] = u[l++], --n == 1) { p = !0; break; }g--; } while (d >= ib || f >= ib);if (p) break; g < 0 && (g = 0), g += 2; } if ((s = g) < 1 && (s = 1), n === 1) { for (r = 0; r < a; r++)t[c + r] = t[h + r]; t[c + a] = u[l]; } else { if (n === 0) throw new Error(); for (r = 0; r < n; r++)t[c + r] = u[l + r]; } } else { for (r = 0; r < a; r++)t[c + r] = t[h + r]; t[c + a] = u[l]; } else for (r = 0; r < n; r++)t[c + r] = u[l + r]; } function o(i, n, o, a) { let r = 0; for (r = 0; r < a; r++)u[r] = t[o + r]; let l = i + n - 1; let h = a - 1; let c = o + a - 1; let d = 0; let f = 0; if (t[c--] = t[l--], --n != 0) if (a !== 1) { for (var p = s; ;) { let g = 0; let m = 0; let v = !1; do { if (e(u[h], t[l]) < 0) { if (t[c--] = t[l--], g++, m = 0, --n == 0) { v = !0; break; } } else if (t[c--] = u[h--], m++, g = 0, --a == 1) { v = !0; break; } } while ((g | m) < p);if (v) break; do { if ((g = n - ye(u[h], t, i, n, n - 1, e)) != 0) { for (n -= g, f = (c -= g) + 1, d = (l -= g) + 1, r = g - 1; r >= 0; r--)t[f + r] = t[d + r]; if (n === 0) { v = !0; break; } } if (t[c--] = u[h--], --a == 1) { v = !0; break; } if ((m = a - ve(t[l], u, 0, a, a - 1, e)) != 0) { for (a -= m, f = (c -= m) + 1, d = (h -= m) + 1, r = 0; r < m; r++)t[f + r] = u[d + r]; if (a <= 1) { v = !0; break; } } if (t[c--] = t[l--], --n == 0) { v = !0; break; }p--; } while (g >= ib || m >= ib);if (v) break; p < 0 && (p = 0), p += 2; } if ((s = p) < 1 && (s = 1), a === 1) { for (f = (c -= n) + 1, d = (l -= n) + 1, r = n - 1; r >= 0; r--)t[f + r] = t[d + r]; t[c] = u[h]; } else { if (a === 0) throw new Error(); for (d = c - (a - 1), r = 0; r < a; r++)t[d + r] = u[r]; } } else { for (f = (c -= n) + 1, d = (l -= n) + 1, r = n - 1; r >= 0; r--)t[f + r] = t[d + r]; t[c] = u[h]; } else for (d = c - (a - 1), r = 0; r < a; r++)t[d + r] = u[r]; } let a; let r; var s = ib; var l = 0; var u = []; a = [], r = [], this.mergeRuns = function () { for (;l > 1;) { let t = l - 2; if (t >= 1 && r[t - 1] <= r[t] + r[t + 1] || t >= 2 && r[t - 2] <= r[t] + r[t - 1])r[t - 1] < r[t + 1] && t--; else if (r[t] > r[t + 1]) break; i(t); } }, this.forceMergeRuns = function () { for (;l > 1;) { let t = l - 2; t > 0 && r[t - 1] < r[t + 1] && t--, i(t); } }, this.pushRun = function (t, e) { a[l] = t, r[l] = e, l += 1; }; } function _e(t, e, i, n) { i || (i = 0), n || (n = t.length); let o = n - i; if (!(o < 2)) { let a = 0; if (o < eb) return a = pe(t, i, n, e), void me(t, i, n, i + a, e); const r = new xe(t, e); const s = fe(o); do { if ((a = pe(t, i, n, e)) < s) { let l = o; l > s && (l = s), me(t, i, i + l, i + a, e), a = l; }r.pushRun(i, a), r.mergeRuns(), o -= a, i += a; } while (o !== 0);r.forceMergeRuns(); } } function we(t, e) { return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel; } function be(t, e, i) { let n = e.x == null ? 0 : e.x; let o = e.x2 == null ? 1 : e.x2; let a = e.y == null ? 0 : e.y; let r = e.y2 == null ? 0 : e.y2; return e.global || (n = n * i.width + i.x, o = o * i.width + i.x, a = a * i.height + i.y, r = r * i.height + i.y), n = isNaN(n) ? 0 : n, o = isNaN(o) ? 1 : o, a = isNaN(a) ? 0 : a, r = isNaN(r) ? 0 : r, t.createLinearGradient(n, a, o, r); } function Se(t, e, i) { const n = i.width; const o = i.height; const a = Math.min(n, o); let r = e.x == null ? 0.5 : e.x; let s = e.y == null ? 0.5 : e.y; let l = e.r == null ? 0.5 : e.r; return e.global || (r = r * n + i.x, s = s * o + i.y, l *= a), t.createRadialGradient(r, s, 0, r, s, l); } function Me() { return !1; } function Ie(t, e, i) { const n = iw(); const o = e.getWidth(); const a = e.getHeight(); const r = n.style; return r && (r.position = "absolute", r.left = 0, r.top = 0, r.width = `${o}px`, r.height = `${a}px`, n.setAttribute("data-zr-dom-id", t)), n.width = o * i, n.height = a * i, n; } function Te(t) { if (typeof t === "string") { const e = mb.get(t); return e && e.image; } return t; } function Ae(t, e, i, n, o) { if (t) { if (typeof t === "string") { if (e && e.__zrImageSrc === t || !i) return e; const a = mb.get(t); const r = { hostEl: i, cb: n, cbPayload: o }; return a ? !Ce(e = a.image) && a.pending.push(r) : ((e = new Image()).onload = e.onerror = De, mb.put(t, e.__cachedImgObj = { image: e, pending: [r] }), e.src = e.__zrImageSrc = t), e; } return t; } return e; } function De() { const t = this.__cachedImgObj; this.onload = this.onerror = this.__cachedImgObj = null; for (let e = 0; e < t.pending.length; e++) { const i = t.pending[e]; const n = i.cb; n && n(this, i.cbPayload), i.hostEl.dirty(); }t.pending.length = 0; } function Ce(t) { return t && t.width && t.height; } function Le(t, e) { const i = `${t}:${e = e || wb}`; if (vb[i]) return vb[i]; for (var n = (`${t}`).split("\n"), o = 0, a = 0, r = n.length; a < r; a++)o = Math.max(We(n[a], e).width, o); return yb > xb && (yb = 0, vb = {}), yb++, vb[i] = o, o; } function ke(t, e, i, n, o, a, r, s) { return r ? Ne(t, e, i, n, o, r, a, s) : Pe(t, e, i, n, o, a, s); } function Pe(t, e, i, n, o, a, r) { const s = He(t, e, o, a, r); let l = Le(t, e); o && (l += o[1] + o[3]); const u = s.outerHeight; const h = new de(Oe(0, l, i), Ee(0, u, n), l, u); return h.lineHeight = s.lineHeight, h; } function Ne(t, e, i, n, o, a, r, s) {
    const l = Ze(t, {
      rich: r, truncate: s, font: e, textAlign: i, textPadding: o, textLineHeight: a,
    }); const u = l.outerWidth; const h = l.outerHeight; return new de(Oe(0, u, i), Ee(0, h, n), u, h);
  } function Oe(t, e, i) { return i === "right" ? t -= e : i === "center" && (t -= e / 2), t; } function Ee(t, e, i) { return i === "middle" ? t -= e / 2 : i === "bottom" && (t -= e), t; } function Re(t, e, i) {
    let n = e.x; let o = e.y; const a = e.height; const r = e.width; const s = a / 2; let l = "left"; let u = "top"; switch (t) { case "left": n -= i, o += s, l = "right", u = "middle"; break; case "right": n += i + r, o += s, u = "middle"; break; case "top": n += r / 2, o -= i, l = "center", u = "bottom"; break; case "bottom": n += r / 2, o += a + i, l = "center"; break; case "inside": n += r / 2, o += s, l = "center", u = "middle"; break; case "insideLeft": n += i, o += s, u = "middle"; break; case "insideRight": n += r - i, o += s, l = "right", u = "middle"; break; case "insideTop": n += r / 2, o += i, l = "center"; break; case "insideBottom": n += r / 2, o += a - i, l = "center", u = "bottom"; break; case "insideTopLeft": n += i, o += i; break; case "insideTopRight": n += r - i, o += i, l = "right"; break; case "insideBottomLeft": n += i, o += a - i, u = "bottom"; break; case "insideBottomRight": n += r - i, o += a - i, l = "right", u = "bottom"; } return {
      x: n, y: o, textAlign: l, textVerticalAlign: u,
    };
  } function ze(t, e, i, n, o) { if (!e) return ""; const a = (`${t}`).split("\n"); o = Be(e, i, n, o); for (let r = 0, s = a.length; r < s; r++)a[r] = Ve(a[r], o); return a.join("\n"); } function Be(t, e, i, n) { (n = a({}, n)).font = e; var i = A(i, "..."); n.maxIterations = A(n.maxIterations, 2); const o = n.minChar = A(n.minChar, 0); n.cnCharWidth = Le("国", e); const r = n.ascCharWidth = Le("a", e); n.placeholder = A(n.placeholder, ""); for (var s = t = Math.max(0, t - 1), l = 0; l < o && s >= r; l++)s -= r; let u = Le(i, e); return u > s && (i = "", u = 0), s = t - u, n.ellipsis = i, n.ellipsisWidth = u, n.contentWidth = s, n.containerWidth = t, n; } function Ve(t, e) { const i = e.containerWidth; const n = e.font; const o = e.contentWidth; if (!i) return ""; let a = Le(t, n); if (a <= i) return t; for (let r = 0; ;r++) { if (a <= o || r >= e.maxIterations) { t += e.ellipsis; break; } const s = r === 0 ? Ge(t, o, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(t.length * o / a) : 0; a = Le(t = t.substr(0, s), n); } return t === "" && (t = e.placeholder), t; } function Ge(t, e, i, n) { for (var o = 0, a = 0, r = t.length; a < r && o < e; a++) { const s = t.charCodeAt(a); o += s >= 0 && s <= 127 ? i : n; } return a; } function Fe(t) { return Le("国", t); } function We(t, e) { return bb.measureText(t, e); } function He(t, e, i, n, o) {
    t != null && (t += ""); const a = A(n, Fe(e)); let r = t ? t.split("\n") : []; const s = r.length * a; let l = s; if (i && (l += i[0] + i[2]), t && o) { const u = o.outerHeight; const h = o.outerWidth; if (u != null && l > u)t = "", r = []; else if (h != null) for (let c = Be(h - (i ? i[1] + i[3] : 0), e, o.ellipsis, { minChar: o.minChar, placeholder: o.placeholder }), d = 0, f = r.length; d < f; d++)r[d] = Ve(r[d], c); } return {
      lines: r, height: s, outerHeight: l, lineHeight: a,
    };
  } function Ze(t, e) { const i = { lines: [], width: 0, height: 0 }; if (t != null && (t += ""), !t) return i; for (var n, o = _b.lastIndex = 0; (n = _b.exec(t)) != null;) { const a = n.index; a > o && Ue(i, t.substring(o, a)), Ue(i, n[2], n[1]), o = _b.lastIndex; }o < t.length && Ue(i, t.substring(o, t.length)); const r = i.lines; let s = 0; let l = 0; const u = []; const h = e.textPadding; const c = e.truncate; let d = c && c.outerWidth; let f = c && c.outerHeight; h && (d != null && (d -= h[1] + h[3]), f != null && (f -= h[0] + h[2])); for (L = 0; L < r.length; L++) { for (var p = r[L], g = 0, m = 0, v = 0; v < p.tokens.length; v++) { const y = (k = p.tokens[v]).styleName && e.rich[k.styleName] || {}; const x = k.textPadding = y.textPadding; const _ = k.font = y.font || e.font; let w = k.textHeight = A(y.textHeight, Fe(_)); if (x && (w += x[0] + x[2]), k.height = w, k.lineHeight = D(y.textLineHeight, e.textLineHeight, w), k.textAlign = y && y.textAlign || e.textAlign, k.textVerticalAlign = y && y.textVerticalAlign || "middle", f != null && s + k.lineHeight > f) return { lines: [], width: 0, height: 0 }; k.textWidth = Le(k.text, _); let b = y.textWidth; const S = b == null || b === "auto"; if (typeof b === "string" && b.charAt(b.length - 1) === "%")k.percentWidth = b, u.push(k), b = 0; else { if (S) { b = k.textWidth; const M = y.textBackgroundColor; let I = M && M.image; I && Ce(I = Te(I)) && (b = Math.max(b, I.width * w / I.height)); } const T = x ? x[1] + x[3] : 0; b += T; const C = d != null ? d - m : null; C != null && C < b && (!S || C < T ? (k.text = "", k.textWidth = b = 0) : (k.text = ze(k.text, C - T, _, c.ellipsis, { minChar: c.minChar }), k.textWidth = Le(k.text, _), b = k.textWidth + T)); }m += k.width = b, y && (g = Math.max(g, k.lineHeight)); }p.width = m, p.lineHeight = g, s += g, l = Math.max(l, m); }i.outerWidth = i.width = A(e.textWidth, l), i.outerHeight = i.height = A(e.textHeight, s), h && (i.outerWidth += h[1] + h[3], i.outerHeight += h[0] + h[2]); for (var L = 0; L < u.length; L++) { var k = u[L]; const P = k.percentWidth; k.width = parseInt(P, 10) / 100 * l; } return i; } function Ue(t, e, i) { for (let n = e === "", o = e.split("\n"), a = t.lines, r = 0; r < o.length; r++) { const s = o[r]; const l = { styleName: i, text: s, isLineHolder: !s && !n }; if (r)a.push({ tokens: [l] }); else { const u = (a[a.length - 1] || (a[0] = { tokens: [] })).tokens; const h = u.length; h === 1 && u[0].isLineHolder ? u[0] = l : (s || !h || n) && u.push(l); } } } function Xe(t) { const e = (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, `${t.fontSize || 12}px`, t.fontFamily || "sans-serif"].join(" "); return e && P(e) || t.textFont || t.font; } function je(t, e) { let i; let n; let o; let a; let r = e.x; let s = e.y; let l = e.width; let u = e.height; const h = e.r; l < 0 && (r += l, l = -l), u < 0 && (s += u, u = -u), typeof h === "number" ? i = n = o = a = h : h instanceof Array ? h.length === 1 ? i = n = o = a = h[0] : h.length === 2 ? (i = o = h[0], n = a = h[1]) : h.length === 3 ? (i = h[0], n = a = h[1], o = h[2]) : (i = h[0], n = h[1], o = h[2], a = h[3]) : i = n = o = a = 0; let c; i + n > l && (i *= l / (c = i + n), n *= l / c), o + a > l && (o *= l / (c = o + a), a *= l / c), n + o > u && (n *= u / (c = n + o), o *= u / c), i + a > u && (i *= u / (c = i + a), a *= u / c), t.moveTo(r + i, s), t.lineTo(r + l - n, s), n !== 0 && t.arc(r + l - n, s + n, n, -Math.PI / 2, 0), t.lineTo(r + l, s + u - o), o !== 0 && t.arc(r + l - o, s + u - o, o, 0, Math.PI / 2), t.lineTo(r + a, s + u), a !== 0 && t.arc(r + a, s + u - a, a, Math.PI / 2, Math.PI), t.lineTo(r, s + i), i !== 0 && t.arc(r + i, s + i, i, Math.PI, 1.5 * Math.PI); } function Ye(t) { return qe(t), d(t.rich, qe), t; } function qe(t) { if (t) { t.font = Xe(t); let e = t.textAlign; e === "middle" && (e = "center"), t.textAlign = e == null || Mb[e] ? e : "left"; let i = t.textVerticalAlign || t.textBaseline; i === "center" && (i = "middle"), t.textVerticalAlign = i == null || Ib[i] ? i : "top", t.textPadding && (t.textPadding = L(t.textPadding)); } } function Ke(t, e, i, n, o, a) { n.rich ? Je(t, e, i, n, o, a) : $e(t, e, i, n, o, a); } function $e(t, e, i, n, o, a) { let r; const s = ii(n); let l = !1; const u = e.__attrCachedBy === rb.PLAIN_TEXT; a !== sb ? (a && (r = a.style, l = !s && u && r), e.__attrCachedBy = s ? rb.NONE : rb.PLAIN_TEXT) : u && (e.__attrCachedBy = rb.NONE); const h = n.font || Sb; l && h === (r.font || Sb) || (e.font = h); let c = t.__computedFont; t.__styleFont !== h && (t.__styleFont = h, c = t.__computedFont = e.font); const d = n.textPadding; const f = n.textLineHeight; let p = t.__textCotentBlock; p && !t.__dirtyText || (p = t.__textCotentBlock = He(i, c, d, f, n.truncate)); const g = p.outerHeight; const m = p.lines; const v = p.lineHeight; const y = ai(g, n, o); const x = y.baseX; const _ = y.baseY; const w = y.textAlign || "left"; const b = y.textVerticalAlign; ti(e, n, o, x, _); const S = Ee(_, g, b); let M = x; let I = S; if (s || d) { let T = Le(i, c); d && (T += d[1] + d[3]); const A = Oe(x, T, w); s && ni(t, e, n, A, S, T, g), d && (M = hi(x, w, d), I += d[0]); }e.textAlign = w, e.textBaseline = "middle", e.globalAlpha = n.opacity || 1; for (B = 0; B < Tb.length; B++) { const D = Tb[B]; const C = D[0]; const L = D[1]; const k = n[C]; l && k === r[C] || (e[L] = ab(e, L, k || D[2])); }I += v / 2; const P = n.textStrokeWidth; const N = l ? r.textStrokeWidth : null; const O = !l || P !== N; const E = !l || O || n.textStroke !== r.textStroke; const R = si(n.textStroke, P); const z = li(n.textFill); if (R && (O && (e.lineWidth = P), E && (e.strokeStyle = R)), z && (l && n.textFill === r.textFill || (e.fillStyle = z)), m.length === 1)R && e.strokeText(m[0], M, I), z && e.fillText(m[0], M, I); else for (var B = 0; B < m.length; B++)R && e.strokeText(m[B], M, I), z && e.fillText(m[B], M, I), I += v; } function Je(t, e, i, n, o, a) { a !== sb && (e.__attrCachedBy = rb.NONE); let r = t.__textCotentBlock; r && !t.__dirtyText || (r = t.__textCotentBlock = Ze(i, n)), Qe(t, e, r, n, o); } function Qe(t, e, i, n, o) { const a = i.width; const r = i.outerWidth; const s = i.outerHeight; const l = n.textPadding; const u = ai(s, n, o); const h = u.baseX; const c = u.baseY; const d = u.textAlign; const f = u.textVerticalAlign; ti(e, n, o, h, c); const p = Oe(h, r, d); const g = Ee(c, s, f); let m = p; let v = g; l && (m += l[3], v += l[0]); const y = m + a; ii(n) && ni(t, e, n, p, g, r, s); for (let x = 0; x < i.lines.length; x++) { for (var _, w = i.lines[x], b = w.tokens, S = b.length, M = w.lineHeight, I = w.width, T = 0, A = m, D = y, C = S - 1; T < S && (!(_ = b[T]).textAlign || _.textAlign === "left");)ei(t, e, _, n, M, v, A, "left"), I -= _.width, A += _.width, T++; for (;C >= 0 && (_ = b[C]).textAlign === "right";)ei(t, e, _, n, M, v, D, "right"), I -= _.width, D -= _.width, C--; for (A += (a - (A - m) - (y - D) - I) / 2; T <= C;)ei(t, e, _ = b[T], n, M, v, A + _.width / 2, "center"), A += _.width, T++; v += M; } } function ti(t, e, i, n, o) { if (i && e.textRotation) { const a = e.textOrigin; a === "center" ? (n = i.width / 2 + i.x, o = i.height / 2 + i.y) : a && (n = a[0] + i.x, o = a[1] + i.y), t.translate(n, o), t.rotate(-e.textRotation), t.translate(-n, -o); } } function ei(t, e, i, n, o, a, r, s) { const l = n.rich[i.styleName] || {}; l.text = i.text; const u = i.textVerticalAlign; let h = a + o / 2; u === "top" ? h = a + i.height / 2 : u === "bottom" && (h = a + o - i.height / 2), !i.isLineHolder && ii(l) && ni(t, e, l, s === "right" ? r - i.width : s === "center" ? r - i.width / 2 : r, h - i.height / 2, i.width, i.height); const c = i.textPadding; c && (r = hi(r, s, c), h -= i.height / 2 - c[2] - i.textHeight / 2), ri(e, "shadowBlur", D(l.textShadowBlur, n.textShadowBlur, 0)), ri(e, "shadowColor", l.textShadowColor || n.textShadowColor || "transparent"), ri(e, "shadowOffsetX", D(l.textShadowOffsetX, n.textShadowOffsetX, 0)), ri(e, "shadowOffsetY", D(l.textShadowOffsetY, n.textShadowOffsetY, 0)), ri(e, "textAlign", s), ri(e, "textBaseline", "middle"), ri(e, "font", i.font || Sb); const d = si(l.textStroke || n.textStroke, p); const f = li(l.textFill || n.textFill); var p = A(l.textStrokeWidth, n.textStrokeWidth); d && (ri(e, "lineWidth", p), ri(e, "strokeStyle", d), e.strokeText(i.text, r, h)), f && (ri(e, "fillStyle", f), e.fillText(i.text, r, h)); } function ii(t) { return !!(t.textBackgroundColor || t.textBorderWidth && t.textBorderColor); } function ni(t, e, i, n, o, a, r) {
    const s = i.textBackgroundColor; const l = i.textBorderWidth; const u = i.textBorderColor; const h = _(s); if (ri(e, "shadowBlur", i.textBoxShadowBlur || 0), ri(e, "shadowColor", i.textBoxShadowColor || "transparent"), ri(e, "shadowOffsetX", i.textBoxShadowOffsetX || 0), ri(e, "shadowOffsetY", i.textBoxShadowOffsetY || 0), h || l && u) {
      e.beginPath(); const c = i.textBorderRadius; c ? je(e, {
        x: n, y: o, width: a, height: r, r: c,
      }) : e.rect(n, o, a, r), e.closePath();
    } if (h) if (ri(e, "fillStyle", s), i.fillOpacity != null) { f = e.globalAlpha; e.globalAlpha = i.fillOpacity * i.opacity, e.fill(), e.globalAlpha = f; } else e.fill(); else if (w(s)) { let d = s.image; (d = Ae(d, null, t, oi, s)) && Ce(d) && e.drawImage(d, n, o, a, r); } if (l && u) if (ri(e, "lineWidth", l), ri(e, "strokeStyle", u), i.strokeOpacity != null) { var f = e.globalAlpha; e.globalAlpha = i.strokeOpacity * i.opacity, e.stroke(), e.globalAlpha = f; } else e.stroke();
  } function oi(t, e) { e.image = t; } function ai(t, e, i) {
    let n = e.x || 0; let o = e.y || 0; let a = e.textAlign; let r = e.textVerticalAlign; if (i) { const s = e.textPosition; if (s instanceof Array)n = i.x + ui(s[0], i.width), o = i.y + ui(s[1], i.height); else { const l = Re(s, i, e.textDistance); n = l.x, o = l.y, a = a || l.textAlign, r = r || l.textVerticalAlign; } const u = e.textOffset; u && (n += u[0], o += u[1]); } return {
      baseX: n, baseY: o, textAlign: a, textVerticalAlign: r,
    };
  } function ri(t, e, i) { return t[e] = ab(t, e, i), t[e]; } function si(t, e) { return t == null || e <= 0 || t === "transparent" || t === "none" ? null : t.image || t.colorStops ? "#000" : t; } function li(t) { return t == null || t === "none" ? null : t.image || t.colorStops ? "#000" : t; } function ui(t, e) { return typeof t === "string" ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t; } function hi(t, e, i) { return e === "right" ? t - i[1] : e === "center" ? t + i[3] / 2 - i[1] / 2 : t + i[3]; } function ci(t, e) { return t != null && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding); } function di(t) { t = t || {}, Kw.call(this, t); for (const e in t)t.hasOwnProperty(e) && e !== "style" && (this[e] = t[e]); this.style = new ub(t.style, this), this._rect = null, this.__clipPaths = []; } function fi(t) { di.call(this, t); } function pi(t) { return parseInt(t, 10); } function gi(t) { return !!t && (!!t.__builtin__ || typeof t.resize === "function" && typeof t.refresh === "function"); } function mi(t, e, i) { return Cb.copy(t.getBoundingRect()), t.transform && Cb.applyTransform(t.transform), Lb.width = e, Lb.height = i, !Cb.intersect(Lb); } function vi(t, e) { if (t === e) return !1; if (!t || !e || t.length !== e.length) return !0; for (let i = 0; i < t.length; i++) if (t[i] !== e[i]) return !0; } function yi(t, e) { for (let i = 0; i < t.length; i++) { const n = t[i]; n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e); } } function xi(t, e) { const i = document.createElement("div"); return i.style.cssText = `${["position:relative", "overflow:hidden", `width:${t}px`, `height:${e}px`, "padding:0", "margin:0", "border-width:0"].join(";")};`, i; } function _i(t) { return t === "mousewheel" && U_.browser.firefox ? "DOMMouseScroll" : t; } function wi(t) { t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(() => { t._touching = !1; }, 700); } function bi(t) { const e = t.pointerType; return e === "pen" || e === "touch"; } function Si(t) { function e(t, e) { return function () { if (!e._touching) return t.apply(e, arguments); }; }d(Ob, (e) => { t._handlers[e] = m(zb[e], t); }), d(Rb, (e) => { t._handlers[e] = m(zb[e], t); }), d(Nb, (i) => { t._handlers[i] = e(zb[i], t); }); } function Mi(t) { function e(e, i) { d(e, (e) => { ht(t, _i(e), i._handlers[e]); }, i); }fw.call(this), this.dom = t, this._touching = !1, this._touchTimer, this._handlers = {}, Si(this), U_.pointerEventsSupported ? e(Rb, this) : (U_.touchEventsSupported && e(Ob, this), e(Nb, this)); } function Ii(t, e) { const i = new Wb(H_(), t, e); return Fb[i.id] = i, i; } function Ti(t, e) { Gb[t] = e; } function Ai(t) { delete Fb[t]; } function Di(t) { return t instanceof Array ? t : t == null ? [] : [t]; } function Ci(t, e, i) { if (t) { t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {}; for (let n = 0, o = i.length; n < o; n++) { const a = i[n]; !t.emphasis[e].hasOwnProperty(a) && t[e].hasOwnProperty(a) && (t.emphasis[e][a] = t[e][a]); } } } function Li(t) { return !Ub(t) || Xb(t) || t instanceof Date ? t : t.value; } function ki(t) { return Ub(t) && !(t instanceof Array); } function Pi(t, e) { e = (e || []).slice(); const i = f(t || [], (t, e) => ({ exist: t })); return Zb(e, (t, n) => { if (Ub(t)) { for (o = 0; o < i.length; o++) if (!i[o].option && t.id != null && i[o].exist.id === `${t.id}`) return i[o].option = t, void (e[n] = null); for (var o = 0; o < i.length; o++) { const a = i[o].exist; if (!(i[o].option || a.id != null && t.id != null || t.name == null || Ei(t) || Ei(a) || a.name !== `${t.name}`)) return i[o].option = t, void (e[n] = null); } } }), Zb(e, (t, e) => { if (Ub(t)) { for (var n = 0; n < i.length; n++) { const o = i[n].exist; if (!i[n].option && !Ei(o) && t.id == null) { i[n].option = t; break; } }n >= i.length && i.push({ option: t }); } }), i; } function Ni(t) { const e = R(); Zb(t, (t, i) => { const n = t.exist; n && e.set(n.id, t); }), Zb(t, (t, i) => { const n = t.option; k(!n || n.id == null || !e.get(n.id) || e.get(n.id) === t, `id duplicates: ${n && n.id}`), n && n.id != null && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {}); }), Zb(t, (t, i) => { const n = t.exist; const o = t.option; const a = t.keyInfo; if (Ub(o)) { if (a.name = o.name != null ? `${o.name}` : n ? n.name : jb + i, n)a.id = n.id; else if (o.id != null)a.id = `${o.id}`; else { let r = 0; do { a.id = `\0${a.name}\0${r++}`; } while (e.get(a.id)); }e.set(a.id, t); } }); } function Oi(t) { const e = t.name; return !(!e || !e.indexOf(jb)); } function Ei(t) { return Ub(t) && t.id && (`${t.id}`).indexOf("\0_ec_\0") === 0; } function Ri(t, e) { function i(t, e, i) { for (let n = 0, o = t.length; n < o; n++) for (let a = t[n].seriesId, r = Di(t[n].dataIndex), s = i && i[a], l = 0, u = r.length; l < u; l++) { const h = r[l]; s && s[h] ? s[h] = null : (e[a] || (e[a] = {}))[h] = 1; } } function n(t, e) { const i = []; for (const o in t) if (t.hasOwnProperty(o) && t[o] != null) if (e)i.push(+o); else { const a = n(t[o], !0); a.length && i.push({ seriesId: o, dataIndex: a }); } return i; } const o = {}; const a = {}; return i(t || [], o), i(e || [], a, o), [n(o), n(a)]; } function zi(t, e) { return e.dataIndexInside != null ? e.dataIndexInside : e.dataIndex != null ? y(e.dataIndex) ? f(e.dataIndex, e => t.indexOfRawIndex(e)) : t.indexOfRawIndex(e.dataIndex) : e.name != null ? y(e.name) ? f(e.name, e => t.indexOfName(e)) : t.indexOfName(e.name) : void 0; } function Bi() { const t = `__\0ec_inner_${qb++}_${Math.random().toFixed(5)}`; return function (e) { return e[t] || (e[t] = {}); }; } function Vi(t, e, i) { if (_(e)) { const n = {}; n[`${e}Index`] = 0, e = n; } const o = i && i.defaultMainType; !o || Gi(e, `${o}Index`) || Gi(e, `${o}Id`) || Gi(e, `${o}Name`) || (e[`${o}Index`] = 0); const a = {}; return Zb(e, (n, o) => { var n = e[o]; if (o !== "dataIndex" && o !== "dataIndexInside") { const r = o.match(/^(\w+)(Index|Id|Name)$/) || []; const s = r[1]; const u = (r[2] || "").toLowerCase(); if (!(!s || !u || n == null || u === "index" && n === "none" || i && i.includeMainTypes && l(i.includeMainTypes, s) < 0)) { const h = { mainType: s }; u === "index" && n === "all" || (h[u] = n); const c = t.queryComponents(h); a[`${s}Models`] = c, a[`${s}Model`] = c[0]; } } else a[o] = n; }), a; } function Gi(t, e) { return t && t.hasOwnProperty(e); } function Fi(t, e, i) { t.setAttribute ? t.setAttribute(e, i) : t[e] = i; } function Wi(t, e) { return t.getAttribute ? t.getAttribute(e) : t[e]; } function Hi(t) { return t === "auto" ? U_.domSupported ? "html" : "richText" : t || "html"; } function Zi(t) { const e = { main: "", sub: "" }; return t && (t = t.split(Kb), e.main = t[0] || "", e.sub = t[1] || ""), e; } function Ui(t) { k(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), `componentType "${t}" illegal`); } function Xi(t, e) { t.$constructor = t, t.extend = function (t) { const e = this; const i = function () { t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments); }; return a(i.prototype, t), i.extend = this.extend, i.superCall = Yi, i.superApply = qi, u(i, this), i.superClass = e, i; }; } function ji(t) { const e = ["__\0is_clz", Jb++, Math.random().toFixed(3)].join("_"); t.prototype[e] = !0, t.isInstance = function (t) { return !(!t || !t[e]); }; } function Yi(t, e) { const i = C(arguments, 2); return this.superClass.prototype[e].apply(t, i); } function qi(t, e, i) { return this.superClass.prototype[e].apply(t, i); } function Ki(t, e) { function i(t) { let e = n[t.main]; return e && e[$b] || ((e = n[t.main] = {})[$b] = !0), e; }e = e || {}; var n = {}; if (t.registerClass = function (t, e) { return e && (Ui(e), (e = Zi(e)).sub ? e.sub !== $b && (i(e)[e.sub] = t) : n[e.main] = t), t; }, t.getClass = function (t, e, i) { let o = n[t]; if (o && o[$b] && (o = e ? o[e] : null), i && !o) throw new Error(e ? `Component ${t}.${e || ""} not exists. Load it first.` : `${t}.type should be specified.`); return o; }, t.getClassesByMainType = function (t) { t = Zi(t); const e = []; const i = n[t.main]; return i && i[$b] ? d(i, (t, i) => { i !== $b && e.push(t); }) : e.push(i), e; }, t.hasClass = function (t) { return t = Zi(t), !!n[t.main]; }, t.getAllClassMainTypes = function () { const t = []; return d(n, (e, i) => { t.push(i); }), t; }, t.hasSubTypes = function (t) { t = Zi(t); const e = n[t.main]; return e && e[$b]; }, t.parseClassType = Zi, e.registerWhenExtend) { const o = t.extend; o && (t.extend = function (e) { const i = o.call(this, e); return t.registerClass(i, e.type); }); } return t; } function $i(t) { return t > -rS && t < rS; } function Ji(t) { return t > rS || t < -rS; } function Qi(t, e, i, n, o) { const a = 1 - o; return a * a * (a * t + 3 * o * e) + o * o * (o * n + 3 * a * i); } function tn(t, e, i, n, o) { const a = 1 - o; return 3 * (((e - t) * a + 2 * (i - e) * o) * a + (n - i) * o * o); } function en(t, e, i, n, o, a) { const r = n + 3 * (e - i) - t; const s = 3 * (i - 2 * e + t); const l = 3 * (e - t); const u = t - o; const h = s * s - 3 * r * l; const c = s * l - 9 * r * u; const d = l * l - 3 * s * u; let f = 0; if ($i(h) && $i(c))$i(s) ? a[0] = 0 : (M = -l / s) >= 0 && M <= 1 && (a[f++] = M); else { const p = c * c - 4 * h * d; if ($i(p)) { const g = c / h; var m = -g / 2; (M = -s / r + g) >= 0 && M <= 1 && (a[f++] = M), m >= 0 && m <= 1 && (a[f++] = m); } else if (p > 0) { const v = aS(p); let y = h * s + 1.5 * r * (-c + v); let x = h * s + 1.5 * r * (-c - v); (M = (-s - ((y = y < 0 ? -oS(-y, uS) : oS(y, uS)) + (x = x < 0 ? -oS(-x, uS) : oS(x, uS)))) / (3 * r)) >= 0 && M <= 1 && (a[f++] = M); } else { const _ = (2 * h * s - 3 * r * c) / (2 * aS(h * h * h)); const w = Math.acos(_) / 3; const b = aS(h); const S = Math.cos(w); var M = (-s - 2 * b * S) / (3 * r); var m = (-s + b * (S + lS * Math.sin(w))) / (3 * r); const I = (-s + b * (S - lS * Math.sin(w))) / (3 * r); M >= 0 && M <= 1 && (a[f++] = M), m >= 0 && m <= 1 && (a[f++] = m), I >= 0 && I <= 1 && (a[f++] = I); } } return f; } function nn(t, e, i, n, o) { const a = 6 * i - 12 * e + 6 * t; const r = 9 * e + 3 * n - 3 * t - 9 * i; const s = 3 * e - 3 * t; let l = 0; if ($i(r))Ji(a) && (c = -s / a) >= 0 && c <= 1 && (o[l++] = c); else { const u = a * a - 4 * r * s; if ($i(u))o[0] = -a / (2 * r); else if (u > 0) { const h = aS(u); var c = (-a + h) / (2 * r); const d = (-a - h) / (2 * r); c >= 0 && c <= 1 && (o[l++] = c), d >= 0 && d <= 1 && (o[l++] = d); } } return l; } function on(t, e, i, n, o, a) { const r = (e - t) * o + t; const s = (i - e) * o + e; const l = (n - i) * o + i; const u = (s - r) * o + r; const h = (l - s) * o + s; const c = (h - u) * o + u; a[0] = t, a[1] = r, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = n; } function an(t, e, i, n, o, a, r, s, l, u, h) { let c; let d; let f; let p; let g; let m = 0.005; let v = 1 / 0; hS[0] = l, hS[1] = u; for (let y = 0; y < 1; y += 0.05)cS[0] = Qi(t, i, o, r, y), cS[1] = Qi(e, n, a, s, y), (p = hw(hS, cS)) < v && (c = y, v = p); v = 1 / 0; for (let x = 0; x < 32 && !(m < sS); x++)d = c - m, f = c + m, cS[0] = Qi(t, i, o, r, d), cS[1] = Qi(e, n, a, s, d), p = hw(cS, hS), d >= 0 && p < v ? (c = d, v = p) : (dS[0] = Qi(t, i, o, r, f), dS[1] = Qi(e, n, a, s, f), g = hw(dS, hS), f <= 1 && g < v ? (c = f, v = g) : m *= 0.5); return h && (h[0] = Qi(t, i, o, r, c), h[1] = Qi(e, n, a, s, c)), aS(v); } function rn(t, e, i, n) { const o = 1 - n; return o * (o * t + 2 * n * e) + n * n * i; } function sn(t, e, i, n) { return 2 * ((1 - n) * (e - t) + n * (i - e)); } function ln(t, e, i, n, o) { const a = t - 2 * e + i; const r = 2 * (e - t); const s = t - n; let l = 0; if ($i(a))Ji(r) && (c = -s / r) >= 0 && c <= 1 && (o[l++] = c); else { const u = r * r - 4 * a * s; if ($i(u))(c = -r / (2 * a)) >= 0 && c <= 1 && (o[l++] = c); else if (u > 0) { const h = aS(u); var c = (-r + h) / (2 * a); const d = (-r - h) / (2 * a); c >= 0 && c <= 1 && (o[l++] = c), d >= 0 && d <= 1 && (o[l++] = d); } } return l; } function un(t, e, i) { const n = t + i - 2 * e; return n === 0 ? 0.5 : (t - e) / n; } function hn(t, e, i, n, o) { const a = (e - t) * n + t; const r = (i - e) * n + e; const s = (r - a) * n + a; o[0] = t, o[1] = a, o[2] = s, o[3] = s, o[4] = r, o[5] = i; } function cn(t, e, i, n, o, a, r, s, l) { let u; let h = 0.005; let c = 1 / 0; hS[0] = r, hS[1] = s; for (let d = 0; d < 1; d += 0.05)cS[0] = rn(t, i, o, d), cS[1] = rn(e, n, a, d), (m = hw(hS, cS)) < c && (u = d, c = m); c = 1 / 0; for (let f = 0; f < 32 && !(h < sS); f++) { const p = u - h; const g = u + h; cS[0] = rn(t, i, o, p), cS[1] = rn(e, n, a, p); var m = hw(cS, hS); if (p >= 0 && m < c)u = p, c = m; else { dS[0] = rn(t, i, o, g), dS[1] = rn(e, n, a, g); const v = hw(dS, hS); g <= 1 && v < c ? (u = g, c = v) : h *= 0.5; } } return l && (l[0] = rn(t, i, o, u), l[1] = rn(e, n, a, u)), aS(c); } function dn(t, e, i) { if (t.length !== 0) { let n; let o = t[0]; let a = o[0]; let r = o[0]; let s = o[1]; let l = o[1]; for (n = 1; n < t.length; n++)o = t[n], a = fS(a, o[0]), r = pS(r, o[0]), s = fS(s, o[1]), l = pS(l, o[1]); e[0] = a, e[1] = s, i[0] = r, i[1] = l; } } function fn(t, e, i, n, o, a) { o[0] = fS(t, i), o[1] = fS(e, n), a[0] = pS(t, i), a[1] = pS(e, n); } function pn(t, e, i, n, o, a, r, s, l, u) { let h; const c = nn; const d = Qi; let f = c(t, i, o, r, wS); for (l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0, h = 0; h < f; h++) { const p = d(t, i, o, r, wS[h]); l[0] = fS(p, l[0]), u[0] = pS(p, u[0]); } for (f = c(e, n, a, s, bS), h = 0; h < f; h++) { const g = d(e, n, a, s, bS[h]); l[1] = fS(g, l[1]), u[1] = pS(g, u[1]); }l[0] = fS(t, l[0]), u[0] = pS(t, u[0]), l[0] = fS(r, l[0]), u[0] = pS(r, u[0]), l[1] = fS(e, l[1]), u[1] = pS(e, u[1]), l[1] = fS(s, l[1]), u[1] = pS(s, u[1]); } function gn(t, e, i, n, o, a, r, s) { const l = un; const u = rn; const h = pS(fS(l(t, i, o), 1), 0); const c = pS(fS(l(e, n, a), 1), 0); const d = u(t, i, o, h); const f = u(e, n, a, c); r[0] = fS(t, o, d), r[1] = fS(e, a, f), s[0] = pS(t, o, d), s[1] = pS(e, a, f); } function mn(t, e, i, n, o, a, r, s, l) { const u = tt; const h = et; const c = Math.abs(o - a); if (c % vS < 1e-4 && c > 1e-4) return s[0] = t - i, s[1] = e - n, l[0] = t + i, void (l[1] = e + n); if (yS[0] = mS(o) * i + t, yS[1] = gS(o) * n + e, xS[0] = mS(a) * i + t, xS[1] = gS(a) * n + e, u(s, yS, xS), h(l, yS, xS), (o %= vS) < 0 && (o += vS), (a %= vS) < 0 && (a += vS), o > a && !r ? a += vS : o < a && r && (o += vS), r) { const d = a; a = o, o = d; } for (let f = 0; f < a; f += Math.PI / 2)f > o && (_S[0] = mS(f) * i + t, _S[1] = gS(f) * n + e, u(s, _S, s), h(l, _S, l)); } function vn(t, e, i, n, o, a, r) { if (o === 0) return !1; const s = o; let l = 0; let u = t; if (r > e + s && r > n + s || r < e - s && r < n - s || a > t + s && a > i + s || a < t - s && a < i - s) return !1; if (t === i) return Math.abs(a - t) <= s / 2; const h = (l = (e - n) / (t - i)) * a - r + (u = (t * n - i * e) / (t - i)); return h * h / (l * l + 1) <= s / 2 * s / 2; } function yn(t, e, i, n, o, a, r, s, l, u, h) { if (l === 0) return !1; const c = l; return !(h > e + c && h > n + c && h > a + c && h > s + c || h < e - c && h < n - c && h < a - c && h < s - c || u > t + c && u > i + c && u > o + c && u > r + c || u < t - c && u < i - c && u < o - c && u < r - c) && an(t, e, i, n, o, a, r, s, u, h, null) <= c / 2; } function xn(t, e, i, n, o, a, r, s, l) { if (r === 0) return !1; const u = r; return !(l > e + u && l > n + u && l > a + u || l < e - u && l < n - u && l < a - u || s > t + u && s > i + u && s > o + u || s < t - u && s < i - u && s < o - u) && cn(t, e, i, n, o, a, s, l, null) <= u / 2; } function _n(t) { return (t %= RS) < 0 && (t += RS), t; } function wn(t, e, i, n, o, a, r, s, l) { if (r === 0) return !1; const u = r; s -= t, l -= e; const h = Math.sqrt(s * s + l * l); if (h - u > i || h + u < i) return !1; if (Math.abs(n - o) % zS < 1e-4) return !0; if (a) { const c = n; n = _n(o), o = _n(c); } else n = _n(n), o = _n(o); n > o && (o += zS); let d = Math.atan2(l, s); return d < 0 && (d += zS), d >= n && d <= o || d + zS >= n && d + zS <= o; } function bn(t, e, i, n, o, a) { if (a > e && a > n || a < e && a < n) return 0; if (n === e) return 0; let r = n < e ? 1 : -1; const s = (a - e) / (n - e); s !== 1 && s !== 0 || (r = n < e ? 0.5 : -0.5); const l = s * (i - t) + t; return l === o ? 1 / 0 : l > o ? r : 0; } function Sn(t, e) { return Math.abs(t - e) < GS; } function Mn() { const t = WS[0]; WS[0] = WS[1], WS[1] = t; } function In(t, e, i, n, o, a, r, s, l, u) { if (u > e && u > n && u > a && u > s || u < e && u < n && u < a && u < s) return 0; const h = en(e, n, a, s, u, FS); if (h === 0) return 0; for (var c, d, f = 0, p = -1, g = 0; g < h; g++) { const m = FS[g]; const v = m === 0 || m === 1 ? 0.5 : 1; Qi(t, i, o, r, m) < l || (p < 0 && (p = nn(e, n, a, s, WS), WS[1] < WS[0] && p > 1 && Mn(), c = Qi(e, n, a, s, WS[0]), p > 1 && (d = Qi(e, n, a, s, WS[1]))), p === 2 ? m < WS[0] ? f += c < e ? v : -v : m < WS[1] ? f += d < c ? v : -v : f += s < d ? v : -v : m < WS[0] ? f += c < e ? v : -v : f += s < c ? v : -v); } return f; } function Tn(t, e, i, n, o, a, r, s) { if (s > e && s > n && s > a || s < e && s < n && s < a) return 0; const l = ln(e, n, a, s, FS); if (l === 0) return 0; const u = un(e, n, a); if (u >= 0 && u <= 1) { for (var h = 0, c = rn(e, n, a, u), d = 0; d < l; d++) { f = FS[d] === 0 || FS[d] === 1 ? 0.5 : 1; (p = rn(t, i, o, FS[d])) < r || (FS[d] < u ? h += c < e ? f : -f : h += a < c ? f : -f); } return h; } var f = FS[0] === 0 || FS[0] === 1 ? 0.5 : 1; var p = rn(t, i, o, FS[0]); return p < r ? 0 : a < e ? f : -f; } function An(t, e, i, n, o, a, r, s) { if ((s -= e) > i || s < -i) return 0; u = Math.sqrt(i * i - s * s); FS[0] = -u, FS[1] = u; const l = Math.abs(n - o); if (l < 1e-4) return 0; if (l % VS < 1e-4) { n = 0, o = VS; p = a ? 1 : -1; return r >= FS[0] + t && r <= FS[1] + t ? p : 0; } if (a) { var u = n; n = _n(o), o = _n(u); } else n = _n(n), o = _n(o); n > o && (o += VS); for (var h = 0, c = 0; c < 2; c++) { const d = FS[c]; if (d + t > r) { let f = Math.atan2(s, d); var p = a ? 1 : -1; f < 0 && (f = VS + f), (f >= n && f <= o || f + VS >= n && f + VS <= o) && (f > Math.PI / 2 && f < 1.5 * Math.PI && (p = -p), h += p); } } return h; } function Dn(t, e, i, n, o) { for (var a = 0, r = 0, s = 0, l = 0, u = 0, h = 0; h < t.length;) { const c = t[h++]; switch (c === BS.M && h > 1 && (i || (a += bn(r, s, l, u, n, o))), h === 1 && (l = r = t[h], u = s = t[h + 1]), c) { case BS.M: r = l = t[h++], s = u = t[h++]; break; case BS.L: if (i) { if (vn(r, s, t[h], t[h + 1], e, n, o)) return !0; } else a += bn(r, s, t[h], t[h + 1], n, o) || 0; r = t[h++], s = t[h++]; break; case BS.C: if (i) { if (yn(r, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], e, n, o)) return !0; } else a += In(r, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], n, o) || 0; r = t[h++], s = t[h++]; break; case BS.Q: if (i) { if (xn(r, s, t[h++], t[h++], t[h], t[h + 1], e, n, o)) return !0; } else a += Tn(r, s, t[h++], t[h++], t[h], t[h + 1], n, o) || 0; r = t[h++], s = t[h++]; break; case BS.A: var d = t[h++]; var f = t[h++]; var p = t[h++]; var g = t[h++]; var m = t[h++]; var v = t[h++]; h += 1; var y = 1 - t[h++]; var x = Math.cos(m) * p + d; var _ = Math.sin(m) * g + f; h > 1 ? a += bn(r, s, x, _, n, o) : (l = x, u = _); var w = (n - d) * g / p + d; if (i) { if (wn(d, f, g, m, m + v, y, e, w, o)) return !0; } else a += An(d, f, g, m, m + v, y, w, o); r = Math.cos(m + v) * p + d, s = Math.sin(m + v) * g + f; break; case BS.R: l = r = t[h++], u = s = t[h++]; var x = l + t[h++]; var _ = u + t[h++]; if (i) { if (vn(l, u, x, u, e, n, o) || vn(x, u, x, _, e, n, o) || vn(x, _, l, _, e, n, o) || vn(l, _, l, u, e, n, o)) return !0; } else a += bn(x, u, x, _, n, o), a += bn(l, _, l, u, n, o); break; case BS.Z: if (i) { if (vn(r, s, l, u, e, n, o)) return !0; } else a += bn(r, s, l, u, n, o); r = l, s = u; } } return i || Sn(s, u) || (a += bn(r, s, l, u, n, o) || 0), a !== 0; } function Cn(t, e, i) { return Dn(t, 0, !1, e, i); } function Ln(t, e, i, n) { return Dn(t, e, !0, i, n); } function kn(t) { di.call(this, t), this.path = null; } function Pn(t, e, i, n, o, a, r, s, l, u, h) { const c = l * (tM / 180); const d = QS(c) * (t - i) / 2 + JS(c) * (e - n) / 2; const f = -1 * JS(c) * (t - i) / 2 + QS(c) * (e - n) / 2; const p = d * d / (r * r) + f * f / (s * s); p > 1 && (r *= $S(p), s *= $S(p)); const g = (o === a ? -1 : 1) * $S((r * r * (s * s) - r * r * (f * f) - s * s * (d * d)) / (r * r * (f * f) + s * s * (d * d))) || 0; const m = g * r * f / s; const v = g * -s * d / r; const y = (t + i) / 2 + QS(c) * m - JS(c) * v; const x = (e + n) / 2 + JS(c) * m + QS(c) * v; const _ = nM([1, 0], [(d - m) / r, (f - v) / s]); const w = [(d - m) / r, (f - v) / s]; const b = [(-1 * d - m) / r, (-1 * f - v) / s]; let S = nM(w, b); iM(w, b) <= -1 && (S = tM), iM(w, b) >= 1 && (S = 0), a === 0 && S > 0 && (S -= 2 * tM), a === 1 && S < 0 && (S += 2 * tM), h.addData(u, y, x, r, s, _, S, c, a); } function Nn(t) { if (!t) return new ES(); for (var e, i = 0, n = 0, o = i, a = n, r = new ES(), s = ES.CMD, l = t.match(oM), u = 0; u < l.length; u++) { for (var h, c = l[u], d = c.charAt(0), f = c.match(aM) || [], p = f.length, g = 0; g < p; g++)f[g] = parseFloat(f[g]); for (let m = 0; m < p;) { var v; var y; var x; var _; var w; var b; var S; let M = i; let I = n; switch (d) { case "l": i += f[m++], n += f[m++], h = s.L, r.addData(h, i, n); break; case "L": i = f[m++], n = f[m++], h = s.L, r.addData(h, i, n); break; case "m": i += f[m++], n += f[m++], h = s.M, r.addData(h, i, n), o = i, a = n, d = "l"; break; case "M": i = f[m++], n = f[m++], h = s.M, r.addData(h, i, n), o = i, a = n, d = "L"; break; case "h": i += f[m++], h = s.L, r.addData(h, i, n); break; case "H": i = f[m++], h = s.L, r.addData(h, i, n); break; case "v": n += f[m++], h = s.L, r.addData(h, i, n); break; case "V": n = f[m++], h = s.L, r.addData(h, i, n); break; case "C": h = s.C, r.addData(h, f[m++], f[m++], f[m++], f[m++], f[m++], f[m++]), i = f[m - 2], n = f[m - 1]; break; case "c": h = s.C, r.addData(h, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n), i += f[m - 2], n += f[m - 1]; break; case "S": v = i, y = n; var T = r.len(); var A = r.data; e === s.C && (v += i - A[T - 4], y += n - A[T - 3]), h = s.C, M = f[m++], I = f[m++], i = f[m++], n = f[m++], r.addData(h, v, y, M, I, i, n); break; case "s": v = i, y = n; var T = r.len(); var A = r.data; e === s.C && (v += i - A[T - 4], y += n - A[T - 3]), h = s.C, M = i + f[m++], I = n + f[m++], i += f[m++], n += f[m++], r.addData(h, v, y, M, I, i, n); break; case "Q": M = f[m++], I = f[m++], i = f[m++], n = f[m++], h = s.Q, r.addData(h, M, I, i, n); break; case "q": M = f[m++] + i, I = f[m++] + n, i += f[m++], n += f[m++], h = s.Q, r.addData(h, M, I, i, n); break; case "T": v = i, y = n; var T = r.len(); var A = r.data; e === s.Q && (v += i - A[T - 4], y += n - A[T - 3]), i = f[m++], n = f[m++], h = s.Q, r.addData(h, v, y, i, n); break; case "t": v = i, y = n; var T = r.len(); var A = r.data; e === s.Q && (v += i - A[T - 4], y += n - A[T - 3]), i += f[m++], n += f[m++], h = s.Q, r.addData(h, v, y, i, n); break; case "A": x = f[m++], _ = f[m++], w = f[m++], b = f[m++], S = f[m++], Pn(M = i, I = n, i = f[m++], n = f[m++], b, S, x, _, w, h = s.A, r); break; case "a": x = f[m++], _ = f[m++], w = f[m++], b = f[m++], S = f[m++], Pn(M = i, I = n, i += f[m++], n += f[m++], b, S, x, _, w, h = s.A, r); } }d !== "z" && d !== "Z" || (h = s.Z, r.addData(h), i = o, n = a), e = h; } return r.toStatic(), r; } function On(t, e) { const i = Nn(t); return e = e || {}, e.buildPath = function (t) { if (t.setData)t.setData(i.data), (e = t.getContext()) && t.rebuildPath(e); else { var e = t; i.rebuildPath(e); } }, e.applyTransform = function (t) { KS(i, t), this.dirty(!0); }, e; } function En(t, e) { return new kn(On(t, e)); } function Rn(t, e) { return kn.extend(On(t, e)); } function zn(t, e, i, n, o, a, r) { const s = 0.5 * (i - t); const l = 0.5 * (n - e); return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * a + s * o + e; } function Bn(t, e, i) { let n = e.points; const o = e.smooth; if (n && n.length >= 2) { if (o && o !== "spline") { const a = fM(n, o, i, e.smoothConstraint); t.moveTo(n[0][0], n[0][1]); for (var r = n.length, s = 0; s < (i ? r : r - 1); s++) { const l = a[2 * s]; const u = a[2 * s + 1]; const h = n[(s + 1) % r]; t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]); } } else { o === "spline" && (n = dM(n, i)), t.moveTo(n[0][0], n[0][1]); for (var s = 1, c = n.length; s < c; s++)t.lineTo(n[s][0], n[s][1]); }i && t.closePath(); } } function Vn(t, e, i) { const n = i && i.lineWidth; if (e && n) { const o = e.x1; const a = e.x2; const r = e.y1; const s = e.y2; mM(2 * o) === mM(2 * a) ? t.x1 = t.x2 = Fn(o, n, !0) : (t.x1 = o, t.x2 = a), mM(2 * r) === mM(2 * s) ? t.y1 = t.y2 = Fn(r, n, !0) : (t.y1 = r, t.y2 = s); } } function Gn(t, e, i) { const n = i && i.lineWidth; if (e && n) { const o = e.x; const a = e.y; const r = e.width; const s = e.height; t.x = Fn(o, n, !0), t.y = Fn(a, n, !0), t.width = Math.max(Fn(o + r, n, !1) - t.x, r === 0 ? 0 : 1), t.height = Math.max(Fn(a + s, n, !1) - t.y, s === 0 ? 0 : 1); } } function Fn(t, e, i) { const n = mM(2 * t); return (n + mM(e)) % 2 == 0 ? n / 2 : (n + (i ? 1 : -1)) / 2; } function Wn(t, e, i) { const n = t.cpx2; const o = t.cpy2; return n === null || o === null ? [(i ? tn : Qi)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? tn : Qi)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? sn : rn)(t.x1, t.cpx1, t.x2, e), (i ? sn : rn)(t.y1, t.cpy1, t.y2, e)]; } function Hn(t) { di.call(this, t), this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.notClear = !0; } function Zn(t) { return kn.extend(t); } function Un(t, e, i, n) { const o = En(t, e); return i && (n === "center" && (i = jn(i, o.getBoundingRect())), Yn(o, i)), o; } function Xn(t, e, i) {
    var n = new fi({
      style: {
        image: t, x: e.x, y: e.y, width: e.width, height: e.height,
      },
      onload(t) { if (i === "center") { const o = { width: t.width, height: t.height }; n.setStyle(jn(e, o)); } },
    }); return n;
  } function jn(t, e) {
    let i; const n = e.width / e.height; let o = t.height * n; return i = o <= t.width ? t.height : (o = t.width) / n, {
      x: t.x + t.width / 2 - o / 2, y: t.y + t.height / 2 - i / 2, width: o, height: i,
    };
  } function Yn(t, e) { if (t.applyTransform) { const i = t.getBoundingRect().calculateTransform(e); t.applyTransform(i); } } function qn(t) { const e = t.shape; const i = t.style.lineWidth; return CM(2 * e.x1) === CM(2 * e.x2) && (e.x1 = e.x2 = $n(e.x1, i, !0)), CM(2 * e.y1) === CM(2 * e.y2) && (e.y1 = e.y2 = $n(e.y1, i, !0)), t; } function Kn(t) { const e = t.shape; const i = t.style.lineWidth; const n = e.x; const o = e.y; const a = e.width; const r = e.height; return e.x = $n(e.x, i, !0), e.y = $n(e.y, i, !0), e.width = Math.max($n(n + a, i, !1) - e.x, a === 0 ? 0 : 1), e.height = Math.max($n(o + r, i, !1) - e.y, r === 0 ? 0 : 1), t; } function $n(t, e, i) { const n = CM(2 * t); return (n + CM(e)) % 2 == 0 ? n / 2 : (n + (i ? 1 : -1)) / 2; } function Jn(t) { return t != null && t !== "none"; } function Qn(t) { if (typeof t !== "string") return t; let e = EM.get(t); return e || (e = Ht(t, -0.1), RM < 1e4 && (EM.set(t, e), RM++)), e; } function to(t) { if (t.__hoverStlDirty) { t.__hoverStlDirty = !1; const e = t.__hoverStl; if (e) { const i = t.__cachedNormalStl = {}; t.__cachedNormalZ2 = t.z2; const n = t.style; for (const o in e)e[o] != null && (i[o] = n[o]); i.fill = n.fill, i.stroke = n.stroke; } else t.__cachedNormalStl = t.__cachedNormalZ2 = null; } } function eo(t) { const e = t.__hoverStl; if (e && !t.__highlighted) { const i = t.useHoverLayer; t.__highlighted = i ? "layer" : "plain"; const n = t.__zr; if (n || !i) { let o = t; let a = t.style; i && (a = (o = n.addHover(t)).style), wo(a), i || to(o), a.extendFrom(e), io(a, e, "fill"), io(a, e, "stroke"), _o(a), i || (t.dirty(!1), t.z2 += NM); } } } function io(t, e, i) { !Jn(e[i]) && Jn(t[i]) && (t[i] = Qn(t[i])); } function no(t) { const e = t.__highlighted; if (e) if (t.__highlighted = !1, e === "layer")t.__zr && t.__zr.removeHover(t); else if (e) { const i = t.style; const n = t.__cachedNormalStl; n && (wo(i), t.setStyle(n), _o(i)); const o = t.__cachedNormalZ2; o != null && t.z2 - o === NM && (t.z2 = o); } } function oo(t, e) { t.isGroup ? t.traverse((t) => { !t.isGroup && e(t); }) : e(t); } function ao(t, e) { e = t.__hoverStl = !1 !== e && (e || {}), t.__hoverStlDirty = !0, t.__highlighted && (t.__cachedNormalStl = null, no(t), eo(t)); } function ro(t) { return t && t.__isEmphasisEntered; } function so(t) { this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasisEntered && oo(this, eo); } function lo(t) { this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasisEntered && oo(this, no); } function uo() { this.__isEmphasisEntered = !0, oo(this, eo); } function ho() { this.__isEmphasisEntered = !1, oo(this, no); } function co(t, e, i) { t.isGroup ? t.traverse((t) => { !t.isGroup && ao(t, t.hoverStyle || e); }) : ao(t, t.hoverStyle || e), fo(t, i); } function fo(t, e) { const i = !1 === e; if (t.__hoverSilentOnTouch = e != null && e.hoverSilentOnTouch, !i || t.__hoverStyleTrigger) { const n = i ? "off" : "on"; t[n]("mouseover", so)[n]("mouseout", lo), t[n]("emphasis", uo)[n]("normal", ho), t.__hoverStyleTrigger = !i; } } function po(t, e, i, n, o, a, r) { let s; const l = (o = o || PM).labelFetcher; const u = o.labelDataIndex; const h = o.labelDimIndex; const c = i.getShallow("show"); const d = n.getShallow("show"); (c || d) && (l && (s = l.getFormattedLabel(u, "normal", null, h)), s == null && (s = x(o.defaultText) ? o.defaultText(u, o) : o.defaultText)); const f = c ? s : null; const p = d ? A(l ? l.getFormattedLabel(u, "emphasis", null, h) : null, s) : null; f == null && p == null || (go(t, i, a, o), go(e, n, r, o, !0)), t.text = f, e.text = p; } function go(t, e, i, n, o) { return mo(t, e, n, o), i && a(t, i), t; } function mo(t, e, i, n) { if ((i = i || PM).isRectText) { let o = e.getShallow("position") || (n ? null : "inside"); o === "outside" && (o = "top"), t.textPosition = o, t.textOffset = e.getShallow("offset"); let a = e.getShallow("rotate"); a != null && (a *= Math.PI / 180), t.textRotation = a, t.textDistance = A(e.getShallow("distance"), n ? null : 5); } let r; const s = e.ecModel; const l = s && s.option.textStyle; const u = vo(e); if (u) { r = {}; for (const h in u) if (u.hasOwnProperty(h)) { const c = e.getModel(["rich", h]); yo(r[h] = {}, c, l, i, n); } } return t.rich = r, yo(t, e, l, i, n, !0), i.forceRich && !i.textStyle && (i.textStyle = {}), t; } function vo(t) { for (var e; t && t !== t.ecModel;) { const i = (t.option || PM).rich; if (i) { e = e || {}; for (const n in i)i.hasOwnProperty(n) && (e[n] = 1); }t = t.parentModel; } return e; } function yo(t, e, i, n, o, a) { i = !o && i || PM, t.textFill = xo(e.getShallow("color"), n) || i.color, t.textStroke = xo(e.getShallow("textBorderColor"), n) || i.textBorderColor, t.textStrokeWidth = A(e.getShallow("textBorderWidth"), i.textBorderWidth), t.insideRawTextPosition = t.textPosition, o || (a && (t.insideRollbackOpt = n, _o(t)), t.textFill == null && (t.textFill = n.autoColor)), t.fontStyle = e.getShallow("fontStyle") || i.fontStyle, t.fontWeight = e.getShallow("fontWeight") || i.fontWeight, t.fontSize = e.getShallow("fontSize") || i.fontSize, t.fontFamily = e.getShallow("fontFamily") || i.fontFamily, t.textAlign = e.getShallow("align"), t.textVerticalAlign = e.getShallow("verticalAlign") || e.getShallow("baseline"), t.textLineHeight = e.getShallow("lineHeight"), t.textWidth = e.getShallow("width"), t.textHeight = e.getShallow("height"), t.textTag = e.getShallow("tag"), a && n.disableBox || (t.textBackgroundColor = xo(e.getShallow("backgroundColor"), n), t.textPadding = e.getShallow("padding"), t.textBorderColor = xo(e.getShallow("borderColor"), n), t.textBorderWidth = e.getShallow("borderWidth"), t.textBorderRadius = e.getShallow("borderRadius"), t.textBoxShadowColor = e.getShallow("shadowColor"), t.textBoxShadowBlur = e.getShallow("shadowBlur"), t.textBoxShadowOffsetX = e.getShallow("shadowOffsetX"), t.textBoxShadowOffsetY = e.getShallow("shadowOffsetY")), t.textShadowColor = e.getShallow("textShadowColor") || i.textShadowColor, t.textShadowBlur = e.getShallow("textShadowBlur") || i.textShadowBlur, t.textShadowOffsetX = e.getShallow("textShadowOffsetX") || i.textShadowOffsetX, t.textShadowOffsetY = e.getShallow("textShadowOffsetY") || i.textShadowOffsetY; } function xo(t, e) { return t !== "auto" ? t : e && e.autoColor ? e.autoColor : null; } function _o(t) { const e = t.insideRollbackOpt; if (e && t.textFill == null) { let i; const n = e.useInsideStyle; const o = t.insideRawTextPosition; const a = e.autoColor; !1 !== n && (!0 === n || e.isRectText && o && typeof o === "string" && o.indexOf("inside") >= 0) ? (i = { textFill: null, textStroke: t.textStroke, textStrokeWidth: t.textStrokeWidth }, t.textFill = "#fff", t.textStroke == null && (t.textStroke = a, t.textStrokeWidth == null && (t.textStrokeWidth = 2))) : a != null && (i = { textFill: null }, t.textFill = a), i && (t.insideRollback = i); } } function wo(t) { const e = t.insideRollback; e && (t.textFill = e.textFill, t.textStroke = e.textStroke, t.textStrokeWidth = e.textStrokeWidth, t.insideRollback = null); } function bo(t, e) { const i = e || e.getModel("textStyle"); return P([t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", `${t.fontSize || i && i.getShallow("fontSize") || 12}px`, t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"].join(" ")); } function So(t, e, i, n, o, a) { if (typeof o === "function" && (a = o, o = null), n && n.isAnimationEnabled()) { const r = t ? "Update" : ""; let s = n.getShallow(`animationDuration${r}`); const l = n.getShallow(`animationEasing${r}`); let u = n.getShallow(`animationDelay${r}`); typeof u === "function" && (u = u(o, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, o) : null)), typeof s === "function" && (s = s(o)), s > 0 ? e.animateTo(i, s, u || 0, l, a, !!a) : (e.stopAnimation(), e.attr(i), a && a()); } else e.stopAnimation(), e.attr(i), a && a(); } function Mo(t, e, i, n, o) { So(!0, t, e, i, n, o); } function Io(t, e, i, n, o) { So(!1, t, e, i, n, o); } function To(t, e) { for (var i = _t([]); t && t !== e;)bt(i, t.getLocalTransform(), i), t = t.parent; return i; } function Ao(t, e, i) { return e && !c(e) && (e = Tw.getLocalTransform(e)), i && (e = Tt([], e)), Q([], t, e); } function Do(t, e, i) { const n = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]); const o = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]); let a = [t === "left" ? -n : t === "right" ? n : 0, t === "top" ? -o : t === "bottom" ? o : 0]; return a = Ao(a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top"; } function Co(t, e, i, n) { function o(t) { const e = { position: F(t.position), rotation: t.rotation }; return t.shape && (e.shape = a({}, t.shape)), e; } if (t && e) { const r = (function (t) { const e = {}; return t.traverse((t) => { !t.isGroup && t.anid && (e[t.anid] = t); }), e; }(t)); e.traverse((t) => { if (!t.isGroup && t.anid) { const e = r[t.anid]; if (e) { const n = o(t); t.attr(o(e)), Mo(t, n, i, t.dataIndex); } } }); } } function Lo(t, e) { return f(t, (t) => { let i = t[0]; i = LM(i, e.x), i = kM(i, e.x + e.width); let n = t[1]; return n = LM(n, e.y), n = kM(n, e.y + e.height), [i, n]; }); } function ko(t, e, i) {
    const n = (e = a({ rectHover: !0 }, e)).style = { strokeNoScale: !0 }; if (i = i || {
      x: -1, y: -1, width: 2, height: 2,
    }, t) return t.indexOf("image://") === 0 ? (n.image = t.slice(8), r(n, i), new fi(e)) : Un(t.replace("path://", ""), e, i, "center");
  } function Po(t, e, i) { this.parentModel = e, this.ecModel = i, this.option = t; } function No(t, e, i) { for (let n = 0; n < e.length && (!e[n] || (t = t && typeof t === "object" ? t[e[n]] : null) != null); n++);return t == null && i && (t = i.get(e)), t; } function Oo(t, e) { const i = HM(t).getParent; return i ? i.call(t, e) : t.parentModel; } function Eo(t) { return [t || "", ZM++, Math.random().toFixed(5)].join("_"); } function Ro(t) { return t.replace(/^\s+/, "").replace(/\s+$/, ""); } function zo(t, e, i, n) { const o = e[1] - e[0]; const a = i[1] - i[0]; if (o === 0) return a === 0 ? i[0] : (i[0] + i[1]) / 2; if (n) if (o > 0) { if (t <= e[0]) return i[0]; if (t >= e[1]) return i[1]; } else { if (t >= e[0]) return i[0]; if (t <= e[1]) return i[1]; } else { if (t === e[0]) return i[0]; if (t === e[1]) return i[1]; } return (t - e[0]) / o * a + i[0]; } function Bo(t, e) { switch (t) { case "center": case "middle": t = "50%"; break; case "left": case "top": t = "0%"; break; case "right": case "bottom": t = "100%"; } return typeof t === "string" ? Ro(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : t == null ? NaN : +t; } function Vo(t, e, i) { return e == null && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), i ? t : +t; } function Go(t) { return t.sort((t, e) => t - e), t; } function Fo(t) { if (t = +t, isNaN(t)) return 0; for (var e = 1, i = 0; Math.round(t * e) / e !== t;)e *= 10, i++; return i; } function Wo(t) { const e = t.toString(); const i = e.indexOf("e"); if (i > 0) { const n = +e.slice(i + 1); return n < 0 ? -n : 0; } const o = e.indexOf("."); return o < 0 ? 0 : e.length - 1 - o; } function Ho(t, e) { const i = Math.log; const n = Math.LN10; const o = Math.floor(i(t[1] - t[0]) / n); const a = Math.round(i(Math.abs(e[1] - e[0])) / n); const r = Math.min(Math.max(-o + a, 0), 20); return isFinite(r) ? r : 20; } function Zo(t, e, i) { if (!t[e]) return 0; const n = p(t, (t, e) => t + (isNaN(e) ? 0 : e), 0); if (n === 0) return 0; for (var o = Math.pow(10, i), a = f(t, t => (isNaN(t) ? 0 : t) / n * o * 100), r = 100 * o, s = f(a, t => Math.floor(t)), l = p(s, (t, e) => t + e, 0), u = f(a, (t, e) => t - s[e]); l < r;) { for (var h = Number.NEGATIVE_INFINITY, c = null, d = 0, g = u.length; d < g; ++d)u[d] > h && (h = u[d], c = d); ++s[c], u[c] = 0, ++l; } return s[e] / o; } function Uo(t) { const e = 2 * Math.PI; return (t % e + e) % e; } function Xo(t) { return t > -UM && t < UM; } function jo(t) { if (t instanceof Date) return t; if (typeof t === "string") { const e = jM.exec(t); if (!e) return new Date(NaN); if (e[8]) { let i = +e[4] || 0; return e[8].toUpperCase() !== "Z" && (i -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, +e[7] || 0)); } return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0); } return t == null ? new Date(NaN) : new Date(Math.round(t)); } function Yo(t) { return Math.pow(10, qo(t)); } function qo(t) { return Math.floor(Math.log(t) / Math.LN10); } function Ko(t, e) { let i; const n = qo(t); const o = Math.pow(10, n); const a = t / o; return i = e ? a < 1.5 ? 1 : a < 2.5 ? 2 : a < 4 ? 3 : a < 7 ? 5 : 10 : a < 1 ? 1 : a < 2 ? 2 : a < 3 ? 3 : a < 5 ? 5 : 10, t = i * o, n >= -20 ? +t.toFixed(n < 0 ? -n : 0) : t; } function $o(t) { function e(t, i, n) { return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] == (n ? -1 : 1) || !n && e(t, i, 1)); }t.sort((t, i) => (e(t, i, 0) ? -1 : 1)); for (let i = -1 / 0, n = 1, o = 0; o < t.length;) { for (var a = t[o].interval, r = t[o].close, s = 0; s < 2; s++)a[s] <= i && (a[s] = i, r[s] = s ? 1 : 1 - n), i = a[s], n = r[s]; a[0] === a[1] && r[0] * r[1] != 1 ? t.splice(o, 1) : o++; } return t; } function Jo(t) { return t - parseFloat(t) >= 0; } function Qo(t) { return isNaN(t) ? "-" : (t = (`${t}`).split("."))[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? `.${t[1]}` : ""); } function ta(t, e) { return t = (t || "").toLowerCase().replace(/-(.)/g, (t, e) => e.toUpperCase()), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t; } function ea(t) { return t == null ? "" : (`${t}`).replace(KM, (t, e) => $M[e]); } function ia(t, e, i) { y(e) || (e = [e]); const n = e.length; if (!n) return ""; for (var o = e[0].$vars || [], a = 0; a < o.length; a++) { const r = JM[a]; t = t.replace(QM(r), QM(r, 0)); } for (let s = 0; s < n; s++) for (let l = 0; l < o.length; l++) { const u = e[s][o[l]]; t = t.replace(QM(JM[l], s), i ? ea(u) : u); } return t; } function na(t, e, i) { return d(e, (e, n) => { t = t.replace(`{${n}}`, i ? ea(e) : e); }), t; } function oa(t, e) { const i = (t = _(t) ? { color: t, extraCssText: e } : t || {}).color; const n = t.type; var e = t.extraCssText; const o = t.renderMode || "html"; const a = t.markerId || "X"; return i ? o === "html" ? n === "subItem" ? `<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:${ea(i)};${e || ""}"></span>` : `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${ea(i)};${e || ""}"></span>` : { renderMode: o, content: `{marker${a}|}  `, style: { color: i } } : ""; } function aa(t, e) { return t += "", "0000".substr(0, e - t.length) + t; } function ra(t, e, i) {
    t !== "week" && t !== "month" && t !== "quarter" && t !== "half-year" && t !== "year" || (t = "MM-dd\nyyyy"); const n = jo(e); const o = i ? "UTC" : ""; const a = n[`get${o}FullYear`](); const r = n[`get${o}Month`]() + 1; const s = n[`get${o}Date`](); const l = n[`get${o}Hours`](); const u = n[`get${o}Minutes`](); const h = n[`get${o}Seconds`](); const c = n[`get${o}Milliseconds`](); return t = t.replace("MM", aa(r, 2)).replace("M", r).replace("yyyy", a).replace("yy", a % 100)
      .replace("dd", aa(s, 2))
      .replace("d", s)
      .replace("hh", aa(l, 2))
      .replace("h", l)
      .replace("mm", aa(u, 2))
      .replace("m", u)
      .replace("ss", aa(h, 2))
      .replace("s", h)
      .replace("SSS", aa(c, 3));
  } function sa(t) { return t ? t.charAt(0).toUpperCase() + t.substr(1) : t; } function la(t, e, i, n, o) { let a = 0; let r = 0; n == null && (n = 1 / 0), o == null && (o = 1 / 0); let s = 0; e.eachChild((l, u) => { let h; let c; const d = l.position; const f = l.getBoundingRect(); const p = e.childAt(u + 1); const g = p && p.getBoundingRect(); if (t === "horizontal") { const m = f.width + (g ? -g.x + f.x : 0); (h = a + m) > n || l.newline ? (a = 0, h = m, r += s + i, s = f.height) : s = Math.max(s, f.height); } else { const v = f.height + (g ? -g.y + f.y : 0); (c = r + v) > o || l.newline ? (a += s + i, r = 0, c = v, s = f.width) : s = Math.max(s, f.width); }l.newline || (d[0] = a, d[1] = r, t === "horizontal" ? a = h + i : r = c + i); }); } function ua(t, e, i) { const n = e.width; const o = e.height; let a = Bo(t.x, n); let r = Bo(t.y, o); let s = Bo(t.x2, n); let l = Bo(t.y2, o); return (isNaN(a) || isNaN(parseFloat(t.x))) && (a = 0), (isNaN(s) || isNaN(parseFloat(t.x2))) && (s = n), (isNaN(r) || isNaN(parseFloat(t.y))) && (r = 0), (isNaN(l) || isNaN(parseFloat(t.y2))) && (l = o), i = qM(i || 0), { width: Math.max(s - a - i[1] - i[3], 0), height: Math.max(l - r - i[0] - i[2], 0) }; } function ha(t, e, i) { i = qM(i || 0); const n = e.width; const o = e.height; let a = Bo(t.left, n); let r = Bo(t.top, o); const s = Bo(t.right, n); const l = Bo(t.bottom, o); let u = Bo(t.width, n); let h = Bo(t.height, o); const c = i[2] + i[0]; const d = i[1] + i[3]; const f = t.aspect; switch (isNaN(u) && (u = n - s - d - a), isNaN(h) && (h = o - l - c - r), f != null && (isNaN(u) && isNaN(h) && (f > n / o ? u = 0.8 * n : h = 0.8 * o), isNaN(u) && (u = f * h), isNaN(h) && (h = u / f)), isNaN(a) && (a = n - s - u - d), isNaN(r) && (r = o - l - h - c), t.left || t.right) { case "center": a = n / 2 - u / 2 - i[3]; break; case "right": a = n - u - d; } switch (t.top || t.bottom) { case "middle": case "center": r = o / 2 - h / 2 - i[0]; break; case "bottom": r = o - h - c; }a = a || 0, r = r || 0, isNaN(u) && (u = n - d - a - (s || 0)), isNaN(h) && (h = o - c - r - (l || 0)); const p = new de(a + i[3], r + i[0], u, h); return p.margin = i, p; } function ca(t, e, i, n, o) { const a = !o || !o.hv || o.hv[0]; const s = !o || !o.hv || o.hv[1]; const l = o && o.boundingMode || "all"; if (a || s) { let u; if (l === "raw")u = t.type === "group" ? new de(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect(); else if (u = t.getBoundingRect(), t.needLocalTransform()) { const h = t.getLocalTransform(); (u = u.clone()).applyTransform(h); }e = ha(r({ width: u.width, height: u.height }, e), i, n); const c = t.position; const d = a ? e.x - u.x : 0; const f = s ? e.y - u.y : 0; t.attr("position", l === "raw" ? [d, f] : [c[0] + d, c[1] + f]); } } function da(t, e) { return t[aI[e][0]] != null || t[aI[e][1]] != null && t[aI[e][2]] != null; } function fa(t, e, i) { function n(i, n) { const r = {}; let l = 0; const u = {}; let h = 0; if (nI(i, (e) => { u[e] = t[e]; }), nI(i, (t) => { o(e, t) && (r[t] = u[t] = e[t]), a(r, t) && l++, a(u, t) && h++; }), s[n]) return a(e, i[1]) ? u[i[2]] = null : a(e, i[2]) && (u[i[1]] = null), u; if (h !== 2 && l) { if (l >= 2) return r; for (let c = 0; c < i.length; c++) { const d = i[c]; if (!o(r, d) && o(t, d)) { r[d] = t[d]; break; } } return r; } return u; } function o(t, e) { return t.hasOwnProperty(e); } function a(t, e) { return t[e] != null && t[e] !== "auto"; } function r(t, e, i) { nI(t, (t) => { e[t] = i[t]; }); }!w(i) && (i = {}); var s = i.ignoreSize; !y(s) && (s = [s, s]); const l = n(aI[0], 0); const u = n(aI[1], 1); r(aI[0], t, l), r(aI[1], t, u); } function pa(t) { return ga({}, t); } function ga(t, e) { return e && t && nI(oI, (i) => { e.hasOwnProperty(i) && (t[i] = e[i]); }), t; } function ma(t, e) { for (var i = t.length, n = 0; n < i; n++) if (t[n].length > e) return t[n]; return t[i - 1]; } function va(t) {
    const e = t.get("coordinateSystem"); const i = {
      coordSysName: e, coordSysDims: [], axisMap: R(), categoryAxisMap: R(),
    }; const n = pI[e]; if (n) return n(t, i, i.axisMap, i.categoryAxisMap), i;
  } function ya(t) { return t.get("type") === "category"; } function xa(t) { this.fromDataset = t.fromDataset, this.data = t.data || (t.sourceFormat === yI ? {} : []), this.sourceFormat = t.sourceFormat || xI, this.seriesLayoutBy = t.seriesLayoutBy || wI, this.dimensionsDefine = t.dimensionsDefine, this.encodeDefine = t.encodeDefine && R(t.encodeDefine), this.startIndex = t.startIndex || 0, this.dimensionsDetectCount = t.dimensionsDetectCount; } function _a(t) { const e = t.option.source; let i = xI; if (S(e))i = _I; else if (y(e)) { e.length === 0 && (i = mI); for (let n = 0, o = e.length; n < o; n++) { const a = e[n]; if (a != null) { if (y(a)) { i = mI; break; } if (w(a)) { i = vI; break; } } } } else if (w(e)) { for (const r in e) if (e.hasOwnProperty(r) && c(e[r])) { i = yI; break; } } else if (e != null) throw new Error("Invalid data"); SI(t).sourceFormat = i; } function wa(t) { return SI(t).source; } function ba(t) { SI(t).datasetMap = R(); } function Sa(t) {
    const e = t.option; let i = e.data; let n = S(i) ? _I : gI; let o = !1; let a = e.seriesLayoutBy; let r = e.sourceHeader; let s = e.dimensions; const l = Ca(t); if (l) { const u = l.option; i = u.source, n = SI(l).sourceFormat, o = !0, a = a || u.seriesLayoutBy, r == null && (r = u.sourceHeader), s = s || u.dimensions; } const h = Ma(i, n, a, r, s); let c = e.encode; !c && l && (c = Da(t, l, i, n, a, h)), SI(t).source = new xa({
      data: i, fromDataset: o, seriesLayoutBy: a, sourceFormat: n, dimensionsDefine: h.dimensionsDefine, startIndex: h.startIndex, dimensionsDetectCount: h.dimensionsDetectCount, encodeDefine: c,
    });
  } function Ma(t, e, i, n, o) {
    if (!t) return { dimensionsDefine: Ia(o) }; let a; let r; let s; if (e === mI)n === "auto" || n == null ? Ta((t) => { t != null && t !== "-" && (_(t) ? r == null && (r = 1) : r = 0); }, i, t, 10) : r = n ? 1 : 0, o || r !== 1 || (o = [], Ta((t, e) => { o[e] = t != null ? t : ""; }, i, t)), a = o ? o.length : i === bI ? t.length : t[0] ? t[0].length : null; else if (e === vI)o || (o = Aa(t), s = !0); else if (e === yI)o || (o = [], s = !0, d(t, (t, e) => { o.push(e); })); else if (e === gI) { const l = Li(t[0]); a = y(l) && l.length || 1; } let u; return s && d(o, (t, e) => { (w(t) ? t.name : t) === "name" && (u = e); }), {
      startIndex: r, dimensionsDefine: Ia(o), dimensionsDetectCount: a, potentialNameDimIndex: u,
    };
  } function Ia(t) { if (t) { const e = R(); return f(t, (t, i) => { if ((t = a({}, w(t) ? t : { name: t })).name == null) return t; t.name += "", t.displayName == null && (t.displayName = t.name); const n = e.get(t.name); return n ? t.name += `-${n.count++}` : e.set(t.name, { count: 1 }), t; }); } } function Ta(t, e, i, n) { if (n == null && (n = 1 / 0), e === bI) for (a = 0; a < i.length && a < n; a++)t(i[a] ? i[a][0] : null, a); else for (var o = i[0] || [], a = 0; a < o.length && a < n; a++)t(o[a], a); } function Aa(t) { for (var e, i = 0; i < t.length && !(e = t[i++]););if (e) { const n = []; return d(e, (t, e) => { n.push(e); }), n; } } function Da(t, e, i, n, o, a) { const r = va(t); const s = {}; const l = []; const u = []; const h = t.subType; const c = R(["pie", "map", "funnel"]); const f = R(["line", "bar", "pictorialBar", "scatter", "effectScatter", "candlestick", "boxplot"]); if (r && f.get(h) != null) { const p = t.ecModel; const g = SI(p).datasetMap; const m = `${e.uid}_${o}`; const v = g.get(m) || g.set(m, { categoryWayDim: 1, valueWayDim: 0 }); d(r.coordSysDims, (t) => { if (r.firstCategoryDimIndex == null) { e = v.valueWayDim++; s[t] = e, u.push(e); } else if (r.categoryAxisMap.get(t))s[t] = 0, l.push(0); else { var e = v.categoryWayDim++; s[t] = e, u.push(e); } }); } else if (c.get(h) != null) { for (var y, x = 0; x < 5 && y == null; x++)ka(i, n, o, a.dimensionsDefine, a.startIndex, x) || (y = x); if (y != null) { s.value = y; const _ = a.potentialNameDimIndex || Math.max(y - 1, 0); u.push(_), l.push(_); } } return l.length && (s.itemName = l), u.length && (s.seriesName = u), s; } function Ca(t) { const e = t.option; if (!e.data) return t.ecModel.getComponent("dataset", e.datasetIndex || 0); } function La(t, e) { return ka(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e); } function ka(t, e, i, n, o, a) { function r(t) { return (t == null || !isFinite(t) || t === "") && (!(!_(t) || t === "-") || void 0); } let s; if (S(t)) return !1; let l; if (n && (l = w(l = n[a]) ? l.name : l), e === mI) if (i === bI) { for (var u = t[a], h = 0; h < (u || []).length && h < 5; h++) if ((s = r(u[o + h])) != null) return s; } else for (h = 0; h < t.length && h < 5; h++) { const c = t[o + h]; if (c && (s = r(c[a])) != null) return s; } else if (e === vI) { if (!l) return; for (h = 0; h < t.length && h < 5; h++) if ((d = t[h]) && (s = r(d[l])) != null) return s; } else if (e === yI) { if (!l) return; if (!(u = t[l]) || S(u)) return !1; for (h = 0; h < u.length && h < 5; h++) if ((s = r(u[h])) != null) return s; } else if (e === gI) for (h = 0; h < t.length && h < 5; h++) { var d = t[h]; const f = Li(d); if (!y(f)) return !1; if ((s = r(f[a])) != null) return s; } return !1; } function Pa(t, e) { if (e) { const i = e.seiresIndex; const n = e.seriesId; const o = e.seriesName; return i != null && t.componentIndex !== i || n != null && t.id !== n || o != null && t.name !== o; } } function Na(t, e) { const o = t.color && !t.colorLayer; d(e, (e, a) => { a === "colorLayer" && o || uI.hasClass(a) || (typeof e === "object" ? t[a] = t[a] ? n(t[a], e, !1) : i(e) : t[a] == null && (t[a] = e)); }); } function Oa(t) { t = t, this.option = {}, this.option[MI] = 1, this._componentsMap = R({ series: [] }), this._seriesIndices, this._seriesIndicesMap, Na(t, this._theme.option), n(t, cI, !1), this.mergeOption(t); } function Ea(t, e) { y(e) || (e = e ? [e] : []); const i = {}; return d(e, (e) => { i[e] = (t.get(e) || []).slice(); }), i; } function Ra(t, e, i) { return e.type ? e.type : i ? i.subType : uI.determineSubType(t, e); } function za(t, e) { t._seriesIndicesMap = R(t._seriesIndices = f(e, t => t.componentIndex) || []); } function Ba(t, e) { return e.hasOwnProperty("subType") ? g(t, t => t.subType === e.subType) : t; } function Va(t) { d(TI, function (e) { this[e] = m(t[e], t); }, this); } function Ga() { this._coordinateSystems = []; } function Fa(t) { this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption; } function Wa(t, e, i) {
    let n; let o; let a = []; const r = []; const s = t.timeline; if (t.baseOption && (o = t.baseOption), (s || t.options) && (o = o || {}, a = (t.options || []).slice()), t.media) { o = o || {}; const l = t.media; DI(l, (t) => { t && t.option && (t.query ? r.push(t) : n || (n = t)); }); } return o || (o = t), o.timeline || (o.timeline = s), DI([o].concat(a).concat(f(r, t => t.option)), (t) => { DI(e, (e) => { e(t, i); }); }), {
      baseOption: o, timelineOptions: a, mediaDefault: n, mediaList: r,
    };
  } function Ha(t, e, i) { const n = { width: e, height: i, aspectratio: e / i }; let o = !0; return d(t, (t, e) => { const i = e.match(PI); if (i && i[1] && i[2]) { const a = i[1]; const r = i[2].toLowerCase(); Za(n[r], t, a) || (o = !1); } }), o; } function Za(t, e, i) { return i === "min" ? t >= e : i === "max" ? t <= e : t === e; } function Ua(t, e) { return t.join(",") === e.join(","); } function Xa(t, e) { DI(e = e || {}, (e, i) => { if (e != null) { let n = t[i]; if (uI.hasClass(i)) { e = Di(e); const o = Pi(n = Di(n), e); t[i] = LI(o, t => (t.option && t.exist ? kI(t.exist, t.option, !0) : t.exist || t.option)); } else t[i] = kI(n, e, !0); } }); } function ja(t) { const e = t && t.itemStyle; if (e) for (let i = 0, o = EI.length; i < o; i++) { const a = EI[i]; const r = e.normal; const s = e.emphasis; r && r[a] && (t[a] = t[a] || {}, t[a].normal ? n(t[a].normal, r[a]) : t[a].normal = r[a], r[a] = null), s && s[a] && (t[a] = t[a] || {}, t[a].emphasis ? n(t[a].emphasis, s[a]) : t[a].emphasis = s[a], s[a] = null); } } function Ya(t, e, i) { if (t && t[e] && (t[e].normal || t[e].emphasis)) { const n = t[e].normal; const o = t[e].emphasis; n && (i ? (t[e].normal = t[e].emphasis = null, r(t[e], n)) : t[e] = n), o && (t.emphasis = t.emphasis || {}, t.emphasis[e] = o); } } function qa(t) { Ya(t, "itemStyle"), Ya(t, "lineStyle"), Ya(t, "areaStyle"), Ya(t, "label"), Ya(t, "labelLine"), Ya(t, "upperLabel"), Ya(t, "edgeLabel"); } function Ka(t, e) { const i = OI(t) && t[e]; const n = OI(i) && i.textStyle; if (n) for (let o = 0, a = Yb.length; o < a; o++) { var e = Yb[o]; n.hasOwnProperty(e) && (i[e] = n[e]); } } function $a(t) { t && (qa(t), Ka(t, "label"), t.emphasis && Ka(t.emphasis, "label")); } function Ja(t) { if (OI(t)) { ja(t), qa(t), Ka(t, "label"), Ka(t, "upperLabel"), Ka(t, "edgeLabel"), t.emphasis && (Ka(t.emphasis, "label"), Ka(t.emphasis, "upperLabel"), Ka(t.emphasis, "edgeLabel")); let e = t.markPoint; e && (ja(e), $a(e)); let i = t.markLine; i && (ja(i), $a(i)); const n = t.markArea; n && $a(n); let o = t.data; if (t.type === "graph") { o = o || t.nodes; const a = t.links || t.edges; if (a && !S(a)) for (s = 0; s < a.length; s++)$a(a[s]); d(t.categories, (t) => { qa(t); }); } if (o && !S(o)) for (s = 0; s < o.length; s++)$a(o[s]); if ((e = t.markPoint) && e.data) for (var r = e.data, s = 0; s < r.length; s++)$a(r[s]); if ((i = t.markLine) && i.data) for (var l = i.data, s = 0; s < l.length; s++)y(l[s]) ? ($a(l[s][0]), $a(l[s][1])) : $a(l[s]); t.type === "gauge" ? (Ka(t, "axisLabel"), Ka(t, "title"), Ka(t, "detail")) : t.type === "treemap" ? (Ya(t.breadcrumb, "itemStyle"), d(t.levels, (t) => { qa(t); })) : t.type === "tree" && qa(t.leaves); } } function Qa(t) { return y(t) ? t : t ? [t] : []; } function tr(t) { return (y(t) ? t[0] : t) || {}; } function er(t, e) { e = e.split(","); for (var i = t, n = 0; n < e.length && (i = i && i[e[n]]) != null; n++);return i; } function ir(t, e, i, n) { e = e.split(","); for (var o, a = t, r = 0; r < e.length - 1; r++)a[o = e[r]] == null && (a[o] = {}), a = a[o]; (n || a[e[r]] == null) && (a[e[r]] = i); } function nr(t) { d(zI, (e) => { e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]); }); } function or(t) { d(t, (e, i) => { const n = []; const o = [NaN, NaN]; const a = [e.stackResultDimension, e.stackedOverDimension]; const r = e.data; const s = e.isStackedByIndex; const l = r.map(a, (a, l, u) => { let h = r.get(e.stackedDimension, u); if (isNaN(h)) return o; let c; let d; s ? d = r.getRawIndex(u) : c = r.get(e.stackedByDimension, u); for (var f = NaN, p = i - 1; p >= 0; p--) { const g = t[p]; if (s || (d = g.data.rawIndexOf(g.stackedByDimension, c)), d >= 0) { const m = g.data.getByRawIndex(g.stackResultDimension, d); if (h >= 0 && m > 0 || h <= 0 && m < 0) { h += m, f = m; break; } } } return n[0] = h, n[1] = f, n; }); r.hostModel.setData(l), e.data = l; }); } function ar(t, e) { xa.isInstance(t) || (t = xa.seriesDataToSource(t)), this._source = t; const i = this._data = t.data; const n = t.sourceFormat; n === _I && (this._offset = 0, this._dimSize = e, this._data = i), a(this, FI[n === mI ? `${n}_${t.seriesLayoutBy}` : n]); } function rr() { return this._data.length; } function sr(t) { return this._data[t]; } function lr(t) { for (let e = 0; e < t.length; e++) this._data.push(t[e]); } function ur(t, e, i, n) { return i != null ? t[i] : t; } function hr(t, e, i, n) { return cr(t[n], this._dimensionInfos[e]); } function cr(t, e) { const i = e && e.type; if (i === "ordinal") { const n = e && e.ordinalMeta; return n ? n.parseAndCollect(t) : t; } return i === "time" && typeof t !== "number" && t != null && t !== "-" && (t = +jo(t)), t == null || t === "" ? NaN : +t; } function dr(t, e, i) { if (t) { const n = t.getRawDataItem(e); if (n != null) { let o; let a; const r = t.getProvider().getSource().sourceFormat; const s = t.getDimensionInfo(i); return s && (o = s.name, a = s.index), WI[r](n, e, a, o); } } } function fr(t, e, i) { if (t) { const n = t.getProvider().getSource().sourceFormat; if (n === gI || n === vI) { let o = t.getRawDataItem(e); return n !== gI || w(o) || (o = null), o ? o[i] : void 0; } } } function pr(t) { return new gr(t); } function gr(t) { t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0, this.context; } function mr(t, e, i, n, o, a) {
    jI.reset(i, n, o, a), t._callingProgress = e, t._callingProgress({
      start: i, end: n, count: n - i, next: jI.next,
    }, t.context);
  } function vr(t, e) { t._dueIndex = t._outputDueEnd = t._dueEnd = 0, t._settedOutputEnd = null; let i; let n; !e && t._reset && ((i = t._reset(t.context)) && i.progress && (n = i.forceFirstProgress, i = i.progress), y(i) && !i.length && (i = null)), t._progress = i, t._modBy = t._modDataCount = null; const o = t._downstream; return o && o.dirty(), n; } function yr(t) { const e = t.name; Oi(t) || (t.name = xr(t) || e); } function xr(t) { const e = t.getRawData(); const i = []; return d(e.mapDimension("seriesName", !0), (t) => { const n = e.getDimensionInfo(t); n.displayName && i.push(n.displayName); }), i.join(" "); } function _r(t) { return t.model.getRawData().count(); } function wr(t) { const e = t.model; return e.setData(e.getRawData().cloneShallow()), br; } function br(t, e) { t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData); } function Sr(t, e) { d(t.CHANGABLE_METHODS, (i) => { t.wrapMethod(i, v(Mr, e)); }); } function Mr(t) { const e = Ir(t); e && e.setOutputEnd(this.count()); } function Ir(t) { const e = (t.ecModel || {}).scheduler; const i = e && e.getPipeline(t.uid); if (i) { let n = i.currentTask; if (n) { const o = n.agentStubMap; o && (n = o.get(t.uid)); } return n; } } function Tr() { this.group = new tb(), this.uid = Eo("viewChart"), this.renderTask = pr({ plan: Cr, reset: Lr }), this.renderTask.context = { view: this }; } function Ar(t, e) { if (t && (t.trigger(e), t.type === "group")) for (let i = 0; i < t.childCount(); i++)Ar(t.childAt(i), e); } function Dr(t, e, i) { const n = zi(t, e); n != null ? d(Di(n), (e) => { Ar(t.getItemGraphicEl(e), i); }) : t.eachItemGraphicEl((t) => { Ar(t, i); }); } function Cr(t) { return tT(t.model); } function Lr(t) { const e = t.model; const i = t.ecModel; const n = t.api; const o = t.payload; const a = e.pipelineContext.progressiveRender; const r = t.view; const s = o && QI(o).updateMethod; const l = a ? "incrementalPrepareRender" : s && r[s] ? s : "render"; return l !== "render" && r[l](e, i, n, o), iT[l]; } function kr(t, e, i) { function n() { h = (new Date()).getTime(), c = null, t.apply(r, s || []); } let o; let a; let r; let s; let l; let u = 0; var h = 0; var c = null; e = e || 0; const d = function () { o = (new Date()).getTime(), r = this, s = arguments; const t = l || e; const d = l || i; l = null, a = o - (d ? u : h) - t, clearTimeout(c), d ? c = setTimeout(n, t) : a >= 0 ? n() : c = setTimeout(n, -a), u = o; }; return d.clear = function () { c && (clearTimeout(c), c = null); }, d.debounceNextCall = function (t) { l = t; }, d; } function Pr(t, e, i, n) { let o = t[e]; if (o) { const a = o[nT] || o; const r = o[aT]; if (o[oT] !== i || r !== n) { if (i == null || !n) return t[e] = a; (o = t[e] = kr(a, i, n === "debounce"))[nT] = a, o[aT] = n, o[oT] = i; } return o; } } function Nr(t, e) { const i = t[e]; i && i[nT] && (t[e] = i[nT]); } function Or(t, e, i, n) { this.ecInstance = t, this.api = e, this.unfinished; var i = this._dataProcessorHandlers = i.slice(); var n = this._visualHandlers = n.slice(); this._allHandlers = i.concat(n), this._stageTaskMap = R(); } function Er(t, e, i, n, o) { function a(t, e) { return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id)); }o = o || {}; let r; d(e, (e, s) => { if (!o.visualType || o.visualType === e.visualType) { const l = t._stageTaskMap.get(e.uid); const u = l.seriesTaskMap; const h = l.overallTask; if (h) { let c; const d = h.agentStubMap; d.each((t) => { a(o, t) && (t.dirty(), c = !0); }), c && h.dirty(), cT(h, n); const f = t.getPerformArgs(h, o.block); d.each((t) => { t.perform(f); }), r |= h.perform(f); } else u && u.each((s, l) => { a(o, s) && s.dirty(); const u = t.getPerformArgs(s, o.block); u.skip = !e.performRawSeries && i.isSeriesFiltered(s.context.model), cT(s, n), r |= s.perform(u); }); } }), t.unfinished |= r; } function Rr(t, e, i, n, o) {
    function a(i) {
      const a = i.uid; const s = r.get(a) || r.set(a, pr({ plan: Wr, reset: Hr, count: Ur })); s.context = {
        model: i, ecModel: n, api: o, useClearVisual: e.isVisual && !e.isLayout, plan: e.plan, reset: e.reset, scheduler: t,
      }, Xr(t, i, s);
    } var r = i.seriesTaskMap || (i.seriesTaskMap = R()); const s = e.seriesType; const l = e.getTargetSeries; e.createOnAllSeries ? n.eachRawSeries(a) : s ? n.eachRawSeriesByType(s, a) : l && l(n, o).each(a); const u = t._pipelineMap; r.each((t, e) => { u.get(e) || (t.dispose(), r.removeKey(e)); });
  } function zr(t, e, i, n, o) {
    function a(e) { const i = e.uid; let n = s.get(i); n || (n = s.set(i, pr({ reset: Vr, onDirty: Fr })), r.dirty()), n.context = { model: e, overallProgress: h, modifyOutputEnd: c }, n.agent = r, n.__block = h, Xr(t, e, n); } var r = i.overallTask = i.overallTask || pr({ reset: Br }); r.context = {
      ecModel: n, api: o, overallReset: e.overallReset, scheduler: t,
    }; var s = r.agentStubMap = r.agentStubMap || R(); const l = e.seriesType; const u = e.getTargetSeries; var h = !0; var c = e.modifyOutputEnd; l ? n.eachRawSeriesByType(l, a) : u ? u(n, o).each(a) : (h = !1, d(n.getSeries(), a)); const f = t._pipelineMap; s.each((t, e) => { f.get(e) || (t.dispose(), r.dirty(), s.removeKey(e)); });
  } function Br(t) { t.overallReset(t.ecModel, t.api, t.payload); } function Vr(t, e) { return t.overallProgress && Gr; } function Gr() { this.agent.dirty(), this.getDownstream().dirty(); } function Fr() { this.agent && this.agent.dirty(); } function Wr(t) { return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload); } function Hr(t) { t.useClearVisual && t.data.clearAllVisual(); const e = t.resetDefines = Di(t.reset(t.model, t.ecModel, t.api, t.payload)); return e.length > 1 ? f(e, (t, e) => Zr(e)) : dT; } function Zr(t) { return function (e, i) { const n = i.data; const o = i.resetDefines[t]; if (o && o.dataEach) for (let a = e.start; a < e.end; a++)o.dataEach(n, a); else o && o.progress && o.progress(e, n); }; } function Ur(t) { return t.data.count(); } function Xr(t, e, i) { const n = e.uid; const o = t._pipelineMap.get(n); !o.head && (o.head = i), o.tail && o.tail.pipe(i), o.tail = i, i.__idxInPipeline = o.count++, i.__pipeline = o; } function jr(t) { fT = null; try { t(pT, gT); } catch (t) {} return fT; } function Yr(t, e) { for (const i in e.prototype)t[i] = B; } function qr(t) { for (_(t) && (t = (new DOMParser()).parseFromString(t, "text/xml")), t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1;)t = t.nextSibling; return t; } function Kr() { this._defs = {}, this._root = null, this._isDefine = !1, this._isText = !1; } function $r(t, e) { for (let i = t.firstChild; i;) { if (i.nodeType === 1) { let n = i.getAttribute("offset"); n = n.indexOf("%") > 0 ? parseInt(n, 10) / 100 : n ? parseFloat(n) : 0; const o = i.getAttribute("stop-color") || "#000000"; e.addColorStop(n, o); }i = i.nextSibling; } } function Jr(t, e) { t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), r(e.__inheritedStyle, t.__inheritedStyle)); } function Qr(t) { for (var e = P(t).split(wT), i = [], n = 0; n < e.length; n += 2) { const o = parseFloat(e[n]); const a = parseFloat(e[n + 1]); i.push([o, a]); } return i; } function ts(t, e, i, n) { const o = e.__inheritedStyle || {}; const r = e.type === "text"; if (t.nodeType === 1 && (is(t, e), a(o, ns(t)), !n)) for (const s in MT) if (MT.hasOwnProperty(s)) { const l = t.getAttribute(s); l != null && (o[MT[s]] = l); } const u = r ? "textFill" : "fill"; const h = r ? "textStroke" : "stroke"; e.style = e.style || new ub(); const c = e.style; o.fill != null && c.set(u, es(o.fill, i)), o.stroke != null && c.set(h, es(o.stroke, i)), d(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], (t) => { const e = t === "lineWidth" && r ? "textStrokeWidth" : t; o[t] != null && c.set(e, parseFloat(o[t])); }), o.textBaseline && o.textBaseline !== "auto" || (o.textBaseline = "alphabetic"), o.textBaseline === "alphabetic" && (o.textBaseline = "bottom"), o.textAlign === "start" && (o.textAlign = "left"), o.textAlign === "end" && (o.textAlign = "right"), d(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], (t) => { o[t] != null && c.set(t, o[t]); }), o.lineDash && (e.style.lineDash = P(o.lineDash).split(wT)), c[h] && c[h] !== "none" && (e[h] = !0), e.__inheritedStyle = o; } function es(t, e) { const i = e && t && t.match(IT); return i ? e[P(i[1])] : t; } function is(t, e) { let i = t.getAttribute("transform"); if (i) { let n = null; const o = []; (i = i.replace(/,/g, " ")).replace(TT, (t, e, i) => { o.push(e, i); }); for (let a = o.length - 1; a > 0; a -= 2) { let r = o[a]; const s = o[a - 1]; switch (n = n || xt(), s) { case "translate": r = P(r).split(wT), St(n, n, [parseFloat(r[0]), parseFloat(r[1] || 0)]); break; case "scale": r = P(r).split(wT), It(n, n, [parseFloat(r[0]), parseFloat(r[1] || r[0])]); break; case "rotate": r = P(r).split(wT), Mt(n, n, parseFloat(r[0])); break; case "skew": r = P(r).split(wT), console.warn("Skew transform is not supported yet"); break; case "matrix": r = P(r).split(wT); n[0] = parseFloat(r[0]), n[1] = parseFloat(r[1]), n[2] = parseFloat(r[2]), n[3] = parseFloat(r[3]), n[4] = parseFloat(r[4]), n[5] = parseFloat(r[5]); } }e.setLocalTransform(n); } } function ns(t) { const e = t.getAttribute("style"); const i = {}; if (!e) return i; const n = {}; AT.lastIndex = 0; for (var o; (o = AT.exec(e)) != null;)n[o[1]] = o[2]; for (const a in MT)MT.hasOwnProperty(a) && n[a] != null && (i[MT[a]] = n[a]); return i; } function os(t, e, i) { const n = e / t.width; const o = i / t.height; const a = Math.min(n, o); return { scale: [a, a], position: [-(t.x + t.width / 2) * a + e / 2, -(t.y + t.height / 2) * a + i / 2] }; } function as(t, e) { return (new Kr()).parse(t, e); } function rs(t) { return function (e, i, n) { e = e && e.toLowerCase(), fw.prototype[t].call(this, e, i, n); }; } function ss() { fw.call(this); } function ls(t, e, n) {
    function o(t, e) { return t.__prio - e.__prio; }n = n || {}, typeof e === "string" && (e = QT[e]), this.id, this.group, this._dom = t; const a = this._zr = Ii(t, {
      renderer: n.renderer || "canvas", devicePixelRatio: n.devicePixelRatio, width: n.width, height: n.height,
    }); this._throttledZrFlush = kr(m(a.flush, a), 17), (e = i(e)) && VI(e, !0), this._theme = e, this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new Ga(); const r = this._api = Ts(this); _e(JT, o), _e(qT, o), this._scheduler = new Or(this, r, qT, JT), fw.call(this, this._ecEventProcessor = new As()), this._messageCenter = new ss(), this._initEvents(), this.resize = m(this.resize, this), this._pendingActions = [], a.animation.on("frame", this._onframe, this), ms(a, this), N(this);
  } function us(t, e, i) { let n; const o = this._model; const a = this._coordSysMgr.getCoordinateSystems(); e = Vi(o, e); for (let r = 0; r < a.length; r++) { const s = a[r]; if (s[t] && (n = s[t](o, e, i)) != null) return n; } } function hs(t) { const e = t._model; const i = t._scheduler; i.restorePipelines(e), i.prepareStageTasks(), vs(t, "component", e, i), vs(t, "chart", e, i), i.plan(); } function cs(t, e, i, n, o) { function a(n) { n && n.__alive && n[e] && n[e](n.__model, r, t._api, i); } var r = t._model; if (n) { const s = {}; s[`${n}Id`] = i[`${n}Id`], s[`${n}Index`] = i[`${n}Index`], s[`${n}Name`] = i[`${n}Name`]; const l = { mainType: n, query: s }; o && (l.subType = o); let u = i.excludeSeriesId; u != null && (u = R(Di(u))), r && r.eachComponent(l, (e) => { u && u.get(e.id) != null || a(t[n === "series" ? "_chartsMap" : "_componentsMap"][e.__viewId]); }, t); } else PT(t._componentsViews.concat(t._chartsViews), a); } function ds(t, e) { const i = t._chartsMap; const n = t._scheduler; e.eachSeries((t) => { n.updateStreamModes(t, i[t.__viewId]); }); } function fs(t, e) { const i = t.type; const n = t.escapeConnect; const o = jT[i]; const s = o.actionInfo; let l = (s.update || "update").split(":"); const u = l.pop(); l = l[0] != null && ET(l[0]), this[FT] = !0; let h = [t]; let c = !1; t.batch && (c = !0, h = f(t.batch, e => e = r(a({}, e), t), e.batch = null, e)); let d; const p = []; const g = i === "highlight" || i === "downplay"; PT(h, function (t) { d = o.action(t, this._model, this._api), (d = d || a({}, t)).type = s.event || d.type, p.push(d), g ? cs(this, u, t, "series") : l && cs(this, u, t, l.main, l.sub); }, this), u === "none" || g || l || (this[WT] ? (hs(this), UT.update.call(this, t), this[WT] = !1) : UT[u].call(this, t)), d = c ? { type: s.event || i, escapeConnect: n, batch: p } : p[0], this[FT] = !1, !e && this._messageCenter.trigger(d.type, d); } function ps(t) { for (let e = this._pendingActions; e.length;) { const i = e.shift(); fs.call(this, i, t); } } function gs(t) { !t && this.trigger("updated"); } function ms(t, e) { t.on("rendered", () => { e.trigger("rendered"), !t.animation.isFinished() || e[WT] || e._scheduler.unfinished || e._pendingActions.length || e.trigger("finished"); }); } function vs(t, e, i, n) { function o(t) { const e = `_ec_${t.id}_${t.type}`; let o = s[e]; if (!o) { const h = ET(t.type); (o = new (a ? KI.getClass(h.main, h.sub) : Tr.getClass(h.sub))()).init(i, u), s[e] = o, r.push(o), l.add(o.group); }t.__viewId = o.__id = e, o.__alive = !0, o.__model = t, o.group.__ecComponentInfo = { mainType: t.mainType, index: t.componentIndex }, !a && n.prepareView(o, t, i, u); } for (var a = e === "component", r = a ? t._componentsViews : t._chartsViews, s = a ? t._componentsMap : t._chartsMap, l = t._zr, u = t._api, h = 0; h < r.length; h++)r[h].__alive = !1; a ? i.eachComponent((t, e) => { t !== "series" && o(e); }) : i.eachSeries(o); for (h = 0; h < r.length;) { const c = r[h]; c.__alive ? h++ : (!a && c.renderTask.dispose(), l.remove(c.group), c.dispose(i, u), r.splice(h, 1), delete s[c.__id], c.__id = c.group.__ecComponentInfo = null); } } function ys(t) { t.clearColorPalette(), t.eachSeries((t) => { t.clearColorPalette(); }); } function xs(t, e, i, n) { _s(t, e, i, n), PT(t._chartsViews, (t) => { t.__alive = !1; }), ws(t, e, i, n), PT(t._chartsViews, (t) => { t.__alive || t.remove(e, i); }); } function _s(t, e, i, n, o) { PT(o || t._componentsViews, (t) => { const o = t.__model; t.render(o, e, i, n), Is(o, t); }); } function ws(t, e, i, n, o) { let a; const r = t._scheduler; e.eachSeries((e) => { const i = t._chartsMap[e.__viewId]; i.__alive = !0; const s = i.renderTask; r.updatePayload(s, n), o && o.get(e.uid) && s.dirty(), a |= s.perform(r.getPerformArgs(s)), i.group.silent = !!e.get("silent"), Is(e, i), Ms(e, i); }), r.unfinished |= a, Ss(t._zr, e), lT(t._zr.dom, e); } function bs(t, e) { PT($T, (i) => { i(t, e); }); } function Ss(t, e) { const i = t.storage; let n = 0; i.traverse((t) => { t.isGroup || n++; }), n > e.get("hoverLayerThreshold") && !U_.node && i.traverse((t) => { t.isGroup || (t.useHoverLayer = !0); }); } function Ms(t, e) { const i = t.get("blendMode") || null; e.group.traverse((t) => { t.isGroup || t.style.blend !== i && t.setStyle("blend", i), t.eachPendingDisplayable && t.eachPendingDisplayable((t) => { t.setStyle("blend", i); }); }); } function Is(t, e) { const i = t.get("z"); const n = t.get("zlevel"); e.group.traverse((t) => { t.type !== "group" && (i != null && (t.z = i), n != null && (t.zlevel = n)); }); } function Ts(t) { const e = t._coordSysMgr; return a(new Va(t), { getCoordinateSystems: m(e.getCoordinateSystems, e), getComponentByElement(e) { for (;e;) { const i = e.__ecComponentInfo; if (i != null) return t._model.getComponent(i.mainType, i.index); e = e.parent; } } }); } function As() { this.eventInfo; } function Ds(t) { function e(t, e) { for (let n = 0; n < t.length; n++)t[n][i] = e; } var i = "__connectUpdateStatus"; PT(YT, (n, o) => { t._messageCenter.on(o, (n) => { if (iA[t.group] && t[i] !== 0) { if (n && n.escapeConnect) return; const o = t.makeActionFromEvent(n); const a = []; PT(eA, (e) => { e !== t && e.group === t.group && a.push(e); }), e(a, 0), PT(a, (t) => { t[i] !== 1 && t.dispatchAction(o); }), e(a, 2); } }); }); } function Cs(t) { iA[t] = !1; } function Ls(t) { return eA[Wi(t, aA)]; } function ks(t, e) { QT[t] = e; } function Ps(t) { KT.push(t); } function Ns(t, e) { Bs(qT, t, e, zT); } function Os(t, e, i) { typeof e === "function" && (i = e, e = ""); const n = OT(t) ? t.type : [t, t = { event: e }][0]; t.event = (t.event || n).toLowerCase(), e = t.event, kT(HT.test(n) && HT.test(e)), jT[n] || (jT[n] = { action: i, actionInfo: t }), YT[e] = n; } function Es(t, e) { Ga.register(t, e); } function Rs(t, e) { Bs(JT, t, e, BT, "layout"); } function zs(t, e) { Bs(JT, t, e, VT, "visual"); } function Bs(t, e, i, n, o) { (NT(e) || OT(e)) && (i = e, e = n); const a = Or.wrapStageHandler(i, o); return a.__prio = e, a.__raw = i, t.push(a), a; } function Vs(t, e) { tA[t] = e; } function Gs(t) { return uI.extend(t); } function Fs(t) { return KI.extend(t); } function Ws(t) { return qI.extend(t); } function Hs(t) { return Tr.extend(t); } function Zs(t) { return t; } function Us(t, e, i, n, o) { this._old = t, this._new = e, this._oldKeyGetter = i || Zs, this._newKeyGetter = n || Zs, this.context = o; } function Xs(t, e, i, n, o) { for (let a = 0; a < t.length; a++) { const r = `_ec_${o[n](t[a], a)}`; let s = e[r]; s == null ? (i.push(r), e[r] = a) : (s.length || (e[r] = s = [s]), s.push(a)); } } function js(t) { const e = {}; const i = e.encode = {}; const n = R(); let o = []; let a = []; d(t.dimensions, (e) => { const r = t.getDimensionInfo(e); const s = r.coordDim; if (s) { let l = i[s]; i.hasOwnProperty(s) || (l = i[s] = []), l[r.coordDimIndex] = e, r.isExtraCoord || (n.set(s, 1), qs(r.type) && (o[0] = e)), r.defaultTooltip && a.push(e); }lA.each((t, e) => { let n = i[e]; i.hasOwnProperty(e) || (n = i[e] = []); const o = r.otherDims[e]; o != null && !1 !== o && (n[o] = r.name); }); }); let r = []; const s = {}; n.each((t, e) => { const n = i[e]; s[e] = n[0], r = r.concat(n); }), e.dataDimsOnCoord = r, e.encodeFirstDimNotExtra = s; const l = i.label; l && l.length && (o = l.slice()); const u = i.tooltip; return u && u.length ? a = u.slice() : a.length || (a = o.slice()), i.defaultedLabel = o, i.defaultedTooltip = a, e; } function Ys(t) { return t === "category" ? "ordinal" : t === "time" ? "time" : "float"; } function qs(t) { return !(t === "ordinal" || t === "time"); } function Ks(t) { return t._rawCount > 65535 ? fA : gA; } function $s(t) { const e = t.constructor; return e === Array ? t.slice() : new e(t); } function Js(t, e) { d(mA.concat(e.__wrappedMethods || []), (i) => { e.hasOwnProperty(i) && (t[i] = e[i]); }), t.__wrappedMethods = e.__wrappedMethods, d(vA, (n) => { t[n] = i(e[n]); }), t._calculationInfo = a(e._calculationInfo); } function Qs(t, e, i, n, o) { const a = dA[e.type]; const r = n - 1; const s = e.name; const l = t[s][r]; if (l && l.length < i) { for (var u = new a(Math.min(o - r * i, i)), h = 0; h < l.length; h++)u[h] = l[h]; t[s][r] = u; } for (let c = n * i; c < o; c += i)t[s].push(new a(Math.min(o - c, i))); } function tl(t) { const e = t._invertedIndicesMap; d(e, (i, n) => { const o = t._dimensionInfos[n].ordinalMeta; if (o) { i = e[n] = new pA(o.categories.length); for (a = 0; a < i.length; a++)i[a] = hA; for (var a = 0; a < t._count; a++)i[t.get(n, a)] = a; } }); } function el(t, e, i) { let n; if (e != null) { const o = t._chunkSize; const a = Math.floor(i / o); const r = i % o; const s = t.dimensions[e]; const l = t._storage[s][a]; if (l) { n = l[r]; const u = t._dimensionInfos[s].ordinalMeta; u && u.categories.length && (n = u.categories[n]); } } return n; } function il(t) { return t; } function nl(t) { return t < this._count && t >= 0 ? this._indices[t] : -1; } function ol(t, e) { let i = t._idList[e]; return i == null && (i = el(t, t._idDimIdx, e)), i == null && (i = cA + e), i; } function al(t) { return y(t) || (t = [t]), t; } function rl(t, e) { const i = t.dimensions; const n = new yA(f(i, t.getDimensionInfo, t), t.hostModel); Js(n, t); for (let o = n._storage = {}, a = t._storage, r = 0; r < i.length; r++) { const s = i[r]; a[s] && (l(e, s) >= 0 ? (o[s] = sl(a[s]), n._rawExtent[s] = ll(), n._extent[s] = null) : o[s] = a[s]); } return n; } function sl(t) { for (var e = new Array(t.length), i = 0; i < t.length; i++)e[i] = $s(t[i]); return e; } function ll() { return [1 / 0, -1 / 0]; } function ul(t, e, n) { function o(t, e, i) { lA.get(e) != null ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, h.set(e, !0)); }xa.isInstance(e) || (e = xa.seriesDataToSource(e)), n = n || {}, t = (t || []).slice(); for (var s = (n.dimsDef || []).slice(), l = R(n.encodeDef), u = R(), h = R(), c = [], f = hl(e, t, s, n.dimCount), p = 0; p < f; p++) { const g = s[p] = a({}, w(s[p]) ? s[p] : { name: s[p] }); const m = g.name; var v = c[p] = { otherDims: {} }; m != null && u.get(m) == null && (v.name = v.displayName = m, u.set(m, p)), g.type != null && (v.type = g.type), g.displayName != null && (v.displayName = g.displayName); }l.each((t, e) => { if ((t = Di(t).slice()).length === 1 && t[0] < 0)l.set(e, !1); else { const i = l.set(e, []); d(t, (t, n) => { _(t) && (t = u.get(t)), t != null && t < f && (i[n] = t, o(c[t], e, n)); }); } }); let y = 0; d(t, (t, e) => { let n; var t; let a; let s; if (_(t))n = t, t = {}; else { n = t.name; const u = t.ordinalMeta; t.ordinalMeta = null, (t = i(t)).ordinalMeta = u, a = t.dimsDef, s = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null; } let h = l.get(n); if (!1 !== h) { if (!(h = Di(h)).length) for (let f = 0; f < (a && a.length || 1); f++) { for (;y < c.length && c[y].coordDim != null;)y++; y < c.length && h.push(y++); }d(h, (e, i) => { const l = c[e]; if (o(r(l, t), n, i), l.name == null && a) { let u = a[i]; !w(u) && (u = { name: u }), l.name = l.displayName = u.name, l.defaultTooltip = u.defaultTooltip; }s && r(l.otherDims, s); }); } }); const x = n.generateCoord; let b = n.generateCoordCount; const S = b != null; b = x ? b || 1 : 0; for (let M = x || "value", I = 0; I < f; I++)(v = c[I] = c[I] || {}).coordDim == null && (v.coordDim = cl(M, h, S), v.coordDimIndex = 0, (!x || b <= 0) && (v.isExtraCoord = !0), b--), v.name == null && (v.name = cl(v.coordDim, u)), v.type == null && La(e, I, v.name) && (v.type = "ordinal"); return c; } function hl(t, e, i, n) { let o = Math.max(t.dimensionsDetectCount || 1, e.length, i.length, n || 0); return d(e, (t) => { const e = t.dimsDef; e && (o = Math.max(o, e.length)); }), o; } function cl(t, e, i) { if (i || e.get(t) != null) { for (var n = 0; e.get(t + n) != null;)n++; t += n; } return e.set(t, !0), t; } function dl(t, e, i) {
    let n; let o; let a; let r; let s = (i = i || {}).byIndex; const l = i.stackedCoordDimension; const u = !(!t || !t.get("stack")); if (d(e, (t, i) => { _(t) && (e[i] = t = { name: t }), u && !t.isExtraCoord && (s || n || !t.ordinalMeta || (n = t), o || t.type === "ordinal" || t.type === "time" || l && l !== t.coordDim || (o = t)); }), !o || s || n || (s = !0), o) {
      a = "__\0ecstackresult", r = "__\0ecstackedover", n && (n.createInvertedIndices = !0); const h = o.coordDim; const c = o.type; let f = 0; d(e, (t) => { t.coordDim === h && f++; }), e.push({
        name: a, coordDim: h, coordDimIndex: f, type: c, isExtraCoord: !0, isCalculationCoord: !0,
      }), f++, e.push({
        name: r, coordDim: r, coordDimIndex: f, type: c, isExtraCoord: !0, isCalculationCoord: !0,
      });
    } return {
      stackedDimension: o && o.name, stackedByDimension: n && n.name, isStackedByIndex: s, stackedOverDimension: r, stackResultDimension: a,
    };
  } function fl(t, e) { return !!e && e === t.getCalculationInfo("stackedDimension"); } function pl(t, e) { return fl(t, e) ? t.getCalculationInfo("stackResultDimension") : e; } function gl(t, e, i) { i = i || {}, xa.isInstance(t) || (t = xa.seriesDataToSource(t)); let n; const o = e.get("coordinateSystem"); const a = Ga.get(o); const r = va(e); r && (n = f(r.coordSysDims, (t) => { const e = { name: t }; const i = r.axisMap.get(t); if (i) { const n = i.get("type"); e.type = Ys(n); } return e; })), n || (n = a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice()) || ["x", "y"]); let s; let l; const u = wA(t, { coordDimensions: n, generateCoord: i.generateCoord }); r && d(u, (t, e) => { const i = t.coordDim; const n = r.categoryAxisMap.get(i); n && (s == null && (s = e), t.ordinalMeta = n.getOrdinalMeta()), t.otherDims.itemName != null && (l = !0); }), l || s == null || (u[s].otherDims.itemName = 0); const h = dl(e, u); const c = new yA(u, e); c.setCalculationInfo(h); const p = s != null && ml(t) ? function (t, e, i, n) { return n === s ? i : this.defaultDimValueGetter(t, e, i, n); } : null; return c.hasItemOption = !1, c.initData(t, null, p), c; } function ml(t) { if (t.sourceFormat === gI) { const e = vl(t.data || []); return e != null && !y(Li(e)); } } function vl(t) { for (var e = 0; e < t.length && t[e] == null;)e++; return t[e]; } function yl(t) { this._setting = t || {}, this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments); } function xl(t) { this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this._map; } function _l(t) { return t._map || (t._map = R(t.categories)); } function wl(t) { return w(t) && t.value != null ? t.value : `${t}`; } function bl(t, e, i, n) { const o = {}; const a = t[1] - t[0]; let r = o.interval = Ko(a / e, !0); i != null && r < i && (r = o.interval = i), n != null && r > n && (r = o.interval = n); const s = o.intervalPrecision = Sl(r); return Il(o.niceTickExtent = [IA(Math.ceil(t[0] / r) * r, s), IA(Math.floor(t[1] / r) * r, s)], t), o; } function Sl(t) { return Wo(t) + 2; } function Ml(t, e, i) { t[e] = Math.max(Math.min(t[e], i[1]), i[0]); } function Il(t, e) { !isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), Ml(t, 0, e), Ml(t, 1, e), t[0] > t[1] && (t[0] = t[1]); } function Tl(t, e, i, n) { const o = []; if (!t) return o; e[0] < i[0] && o.push(e[0]); for (let a = i[0]; a <= i[1] && (o.push(a), (a = IA(a + t, n)) !== o[o.length - 1]);) if (o.length > 1e4) return []; return e[1] > (o.length ? o[o.length - 1] : i[1]) && o.push(e[1]), o; } function Al(t) { return t.get("stack") || DA + t.seriesIndex; } function Dl(t) { return t.dim + t.index; } function Cl(t) { const e = []; const i = t.axis; if (i.type === "category") { for (var n = i.getBandWidth(), o = 0; o < t.count; o++)e.push(r({ bandWidth: n, axisKey: "axis0", stackId: DA + o }, t)); for (var a = Pl(e), s = [], o = 0; o < t.count; o++) { const l = a.axis0[DA + o]; l.offsetCenter = l.offset + l.width / 2, s.push(l); } return s; } } function Ll(t, e) { const i = []; return e.eachSeriesByType(t, (t) => { El(t) && !Rl(t) && i.push(t); }), i; } function kl(t) {
    const e = []; return d(t, (t) => {
      const i = t.getData(); const n = t.coordinateSystem.getBaseAxis(); const o = n.getExtent(); const a = n.type === "category" ? n.getBandWidth() : Math.abs(o[1] - o[0]) / i.count(); const r = Bo(t.get("barWidth"), a); const s = Bo(t.get("barMaxWidth"), a); const l = t.get("barGap"); const u = t.get("barCategoryGap"); e.push({
        bandWidth: a, barWidth: r, barMaxWidth: s, barGap: l, barCategoryGap: u, axisKey: Dl(n), stackId: Al(t),
      });
    }), Pl(e);
  } function Pl(t) {
    const e = {}; d(t, (t, i) => {
      const n = t.axisKey; const o = t.bandWidth; const a = e[n] || {
        bandWidth: o, remainedWidth: o, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {},
      }; const r = a.stacks; e[n] = a; const s = t.stackId; r[s] || a.autoWidthCount++, r[s] = r[s] || { width: 0, maxWidth: 0 }; let l = t.barWidth; l && !r[s].width && (r[s].width = l, l = Math.min(a.remainedWidth, l), a.remainedWidth -= l); const u = t.barMaxWidth; u && (r[s].maxWidth = u); const h = t.barGap; h != null && (a.gap = h); const c = t.barCategoryGap; c != null && (a.categoryGap = c);
    }); const i = {}; return d(e, (t, e) => { i[e] = {}; const n = t.stacks; const o = t.bandWidth; const a = Bo(t.categoryGap, o); const r = Bo(t.gap, 1); let s = t.remainedWidth; let l = t.autoWidthCount; let u = (s - a) / (l + (l - 1) * r); u = Math.max(u, 0), d(n, (t, e) => { let i = t.maxWidth; i && i < u && (i = Math.min(i, s), t.width && (i = Math.min(i, t.width)), s -= i, t.width = i, l--); }), u = (s - a) / (l + (l - 1) * r), u = Math.max(u, 0); let h; let c = 0; d(n, (t, e) => { t.width || (t.width = u), h = t, c += t.width * (1 + r); }), h && (c -= h.width * r); let f = -c / 2; d(n, (t, n) => { i[e][n] = i[e][n] || { offset: f, width: t.width }, f += t.width * (1 + r); }); }), i;
  } function Nl(t, e, i) { if (t && e) { let n = t[Dl(e)]; return n != null && i != null && (n = n[Al(i)]), n; } } function Ol(t, e) {
    const i = Ll(t, e); const n = kl(i); const o = {}; d(i, (t) => {
      const e = t.getData(); const i = t.coordinateSystem; const a = i.getBaseAxis(); const r = Al(t); const s = n[Dl(a)][r]; const l = s.offset; const u = s.width; const h = i.getOtherAxis(a); const c = t.get("barMinHeight") || 0; o[r] = o[r] || [], e.setLayout({ offset: l, size: u }); for (let d = e.mapDimension(h.dim), f = e.mapDimension(a.dim), p = fl(e, d), g = h.isHorizontal(), m = zl(a, h, p), v = 0, y = e.count(); v < y; v++) {
        const x = e.get(d, v); const _ = e.get(f, v); if (!isNaN(x)) {
          const w = x >= 0 ? "p" : "n"; let b = m; p && (o[r][_] || (o[r][_] = { p: m, n: m }), b = o[r][_][w]); var S; var M; var I; var T; if (g)S = b, M = (A = i.dataToPoint([x, _]))[1] + l, I = A[0] - m, T = u, Math.abs(I) < c && (I = (I < 0 ? -1 : 1) * c), p && (o[r][_][w] += I); else { var A = i.dataToPoint([_, x]); S = A[0] + l, M = b, I = u, T = A[1] - m, Math.abs(T) < c && (T = (T <= 0 ? -1 : 1) * c), p && (o[r][_][w] += T); }e.setItemLayout(v, {
            x: S, y: M, width: I, height: T,
          });
        }
      }
    }, this);
  } function El(t) { return t.coordinateSystem && t.coordinateSystem.type === "cartesian2d"; } function Rl(t) { return t.pipelineContext && t.pipelineContext.large; } function zl(t, e, i) { let n; let o; const a = e.getGlobalExtent(); a[0] > a[1] ? (n = a[1], o = a[0]) : (n = a[0], o = a[1]); let r = e.toGlobalCoord(e.dataToCoord(0)); return r < n && (r = n), r > o && (r = o), r; } function Bl(t, e) { return GA(t, VA(e)); } function Vl(t, e) { let i; let n; let o; const a = t.type; let r = e.getMin(); let s = e.getMax(); const l = r != null; const u = s != null; const h = t.getExtent(); a === "ordinal" ? i = e.getCategories().length : (y(n = e.get("boundaryGap")) || (n = [n || 0, n || 0]), typeof n[0] === "boolean" && (n = [0, 0]), n[0] = Bo(n[0], 1), n[1] = Bo(n[1], 1), o = h[1] - h[0] || Math.abs(h[0])), r == null && (r = a === "ordinal" ? i ? 0 : NaN : h[0] - n[0] * o), s == null && (s = a === "ordinal" ? i ? i - 1 : NaN : h[1] + n[1] * o), r === "dataMin" ? r = h[0] : typeof r === "function" && (r = r({ min: h[0], max: h[1] })), s === "dataMax" ? s = h[1] : typeof s === "function" && (s = s({ min: h[0], max: h[1] })), (r == null || !isFinite(r)) && (r = NaN), (s == null || !isFinite(s)) && (s = NaN), t.setBlank(I(r) || I(s) || a === "ordinal" && !t.getOrdinalMeta().categories.length), e.getNeedCrossZero() && (r > 0 && s > 0 && !l && (r = 0), r < 0 && s < 0 && !u && (s = 0)); const c = e.ecModel; if (c && a === "time") { let f; const p = Ll("bar", c); if (d(p, (t) => { f |= t.getBaseAxis() === e.axis; }), f) { const g = kl(p); const m = Gl(r, s, e, g); r = m.min, s = m.max; } } return [r, s]; } function Gl(t, e, i, n) { const o = i.axis.getExtent(); const a = o[1] - o[0]; const r = Nl(n, i.axis); if (void 0 === r) return { min: t, max: e }; let s = 1 / 0; d(r, (t) => { s = Math.min(t.offset, s); }); let l = -1 / 0; d(r, (t) => { l = Math.max(t.offset + t.width, l); }), s = Math.abs(s), l = Math.abs(l); const u = s + l; const h = e - t; const c = h / (1 - (s + l) / a) - h; return e += c * (l / u), t -= c * (s / u), { min: t, max: e }; } function Fl(t, e) {
    const i = Vl(t, e); const n = e.getMin() != null; const o = e.getMax() != null; const a = e.get("splitNumber"); t.type === "log" && (t.base = e.get("logBase")); const r = t.type; t.setExtent(i[0], i[1]), t.niceExtent({
      splitNumber: a, fixMin: n, fixMax: o, minInterval: r === "interval" || r === "time" ? e.get("minInterval") : null, maxInterval: r === "interval" || r === "time" ? e.get("maxInterval") : null,
    }); const s = e.get("interval"); s != null && t.setInterval && t.setInterval(s);
  } function Wl(t, e) { if (e = e || t.get("type")) switch (e) { case "category": return new MA(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), [1 / 0, -1 / 0]); case "value": return new AA(); default: return (yl.getClass(e) || AA).create(t); } } function Hl(t) { const e = t.scale.getExtent(); const i = e[0]; const n = e[1]; return !(i > 0 && n > 0 || i < 0 && n < 0); } function Zl(t) { let e = t.getLabelModel().get("formatter"); const i = t.type === "category" ? t.scale.getExtent()[0] : null; return typeof e === "string" ? e = (function (e) { return function (i) { return i = t.scale.getLabel(i), e.replace("{value}", i != null ? i : ""); }; }(e)) : typeof e === "function" ? function (n, o) { return i != null && (o = n - i), e(Ul(t, n), o); } : function (e) { return t.scale.getLabel(e); }; } function Ul(t, e) { return t.type === "category" ? t.scale.getLabel(e) : e; } function Xl(t) { const e = t.model; const i = t.scale; if (e.get("axisLabel.show") && !i.isBlank()) { let n; let o; const a = t.type === "category"; const r = i.getExtent(); o = a ? i.count() : (n = i.getTicks()).length; let s; const l = t.getLabelModel(); const u = Zl(t); let h = 1; o > 40 && (h = Math.ceil(o / 40)); for (let c = 0; c < o; c += h) { const d = u(n ? n[c] : r[0] + c); const f = jl(l.getTextRect(d), l.get("rotate") || 0); s ? s.union(f) : s = f; } return s; } } function jl(t, e) { const i = e * Math.PI / 180; const n = t.plain(); const o = n.width; const a = n.height; const r = o * Math.cos(i) + a * Math.sin(i); const s = o * Math.sin(i) + a * Math.cos(i); return new de(n.x, n.y, r, s); } function Yl(t) { const e = t.get("interval"); return e == null ? "auto" : e; } function ql(t) { return t.type === "category" && Yl(t.getLabelModel()) === 0; } function Kl(t, e) { if (this.type !== "image") { const i = this.style; const n = this.shape; n && n.symbolType === "line" ? i.stroke = t : this.__isEmptyBrush ? (i.stroke = t, i.fill = e || "#fff") : (i.fill && (i.fill = t), i.stroke && (i.stroke = t)), this.dirty(!1); } } function $l(t, e, i, n, o, a, r) {
    const s = t.indexOf("empty") === 0; s && (t = t.substr(5, 1).toLowerCase() + t.substr(6)); let l; return l = t.indexOf("image://") === 0 ? Xn(t.slice(8), new de(e, i, n, o), r ? "center" : "cover") : t.indexOf("path://") === 0 ? Un(t.slice(7), {}, new de(e, i, n, o), r ? "center" : "cover") : new QA({
      shape: {
        symbolType: t, x: e, y: i, width: n, height: o,
      },
    }), l.__isEmptyBrush = s, l.setColor = Kl, l.setColor(a), l;
  } function Jl(t, e) { return Math.abs(t - e) < iD; } function Ql(t, e, i) { let n = 0; let o = t[0]; if (!o) return !1; for (let a = 1; a < t.length; a++) { const r = t[a]; n += bn(o[0], o[1], r[0], r[1], e, i), o = r; } const s = t[0]; return Jl(o[0], s[0]) && Jl(o[1], s[1]) || (n += bn(o[0], o[1], s[0], s[1], e, i)), n !== 0; } function tu(t, e, i) { if (this.name = t, this.geometries = e, i)i = [i[0], i[1]]; else { const n = this.getBoundingRect(); i = [n.x + n.width / 2, n.y + n.height / 2]; } this.center = i; } function eu(t) { if (!t.UTF8Encoding) return t; let e = t.UTF8Scale; e == null && (e = 1024); for (let i = t.features, n = 0; n < i.length; n++) for (let o = i[n].geometry, a = o.coordinates, r = o.encodeOffsets, s = 0; s < a.length; s++) { const l = a[s]; if (o.type === "Polygon")a[s] = iu(l, r[s], e); else if (o.type === "MultiPolygon") for (let u = 0; u < l.length; u++) { const h = l[u]; l[u] = iu(h, r[s][u], e); } } return t.UTF8Encoding = !1, t; } function iu(t, e, i) { for (var n = [], o = e[0], a = e[1], r = 0; r < t.length; r += 2) { let s = t.charCodeAt(r) - 64; let l = t.charCodeAt(r + 1) - 64; s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), o = s += o, a = l += a, n.push([s / i, l / i]); } return n; } function nu(t) { return t.type === "category" ? au(t) : lu(t); } function ou(t, e) { return t.type === "category" ? su(t, e) : { ticks: t.scale.getTicks() }; } function au(t) { const e = t.getLabelModel(); const i = ru(t, e); return !e.get("show") || t.scale.isBlank() ? { labels: [], labelCategoryInterval: i.labelCategoryInterval } : i; } function ru(t, e) { const i = uu(t, "labels"); const n = Yl(e); const o = hu(i, n); if (o) return o; let a; let r; return a = x(n) ? mu(t, n) : gu(t, r = n === "auto" ? du(t) : n), cu(i, n, { labels: a, labelCategoryInterval: r }); } function su(t, e) { const i = uu(t, "ticks"); const n = Yl(e); const o = hu(i, n); if (o) return o; let a; let r; if (e.get("show") && !t.scale.isBlank() || (a = []), x(n))a = mu(t, n, !0); else if (n === "auto") { const s = ru(t, t.getLabelModel()); r = s.labelCategoryInterval, a = f(s.labels, t => t.tickValue); } else a = gu(t, r = n, !0); return cu(i, n, { ticks: a, tickCategoryInterval: r }); } function lu(t) { const e = t.scale.getTicks(); const i = Zl(t); return { labels: f(e, (e, n) => ({ formattedLabel: i(e, n), rawLabel: t.scale.getLabel(e), tickValue: e })) }; } function uu(t, e) { return oD(t)[e] || (oD(t)[e] = []); } function hu(t, e) { for (let i = 0; i < t.length; i++) if (t[i].key === e) return t[i].value; } function cu(t, e, i) { return t.push({ key: e, value: i }), i; } function du(t) { const e = oD(t).autoInterval; return e != null ? e : oD(t).autoInterval = t.calculateCategoryInterval(); } function fu(t) { const e = pu(t); const i = Zl(t); const n = (e.axisRotate - e.labelRotate) / 180 * Math.PI; const o = t.scale; const a = o.getExtent(); const r = o.count(); if (a[1] - a[0] < 1) return 0; let s = 1; r > 40 && (s = Math.max(1, Math.floor(r / 40))); for (var l = a[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(n)), c = Math.abs(u * Math.sin(n)), d = 0, f = 0; l <= a[1]; l += s) { let p = 0; let g = 0; const m = ke(i(l), e.font, "center", "top"); p = 1.3 * m.width, g = 1.3 * m.height, d = Math.max(d, p, 7), f = Math.max(f, g, 7); } let v = d / h; let y = f / c; isNaN(v) && (v = 1 / 0), isNaN(y) && (y = 1 / 0); let x = Math.max(0, Math.floor(Math.min(v, y))); const _ = oD(t.model); const w = _.lastAutoInterval; const b = _.lastTickCount; return w != null && b != null && Math.abs(w - x) <= 1 && Math.abs(b - r) <= 1 && w > x ? x = w : (_.lastTickCount = r, _.lastAutoInterval = x), x; } function pu(t) { const e = t.getLabelModel(); return { axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0, labelRotate: e.get("rotate") || 0, font: e.getFont() }; } function gu(t, e, i) { function n(t) { l.push(i ? t : { formattedLabel: o(t), rawLabel: a.getLabel(t), tickValue: t }); } var o = Zl(t); var a = t.scale; const r = a.getExtent(); const s = t.getLabelModel(); var l = []; const u = Math.max((e || 0) + 1, 1); let h = r[0]; const c = a.count(); h !== 0 && u > 1 && c / u > 2 && (h = Math.round(Math.ceil(h / u) * u)); const d = ql(t); const f = s.get("showMinLabel") || d; const p = s.get("showMaxLabel") || d; f && h !== r[0] && n(r[0]); for (var g = h; g <= r[1]; g += u)n(g); return p && g !== r[1] && n(r[1]), l; } function mu(t, e, i) { const n = t.scale; const o = Zl(t); const a = []; return d(n.getTicks(), (t) => { const r = n.getLabel(t); e(t, r) && a.push(i ? t : { formattedLabel: o(t), rawLabel: r, tickValue: t }); }), a; } function vu(t, e) { const i = (t[1] - t[0]) / e / 2; t[0] += i, t[1] -= i; } function yu(t, e, i, n, o) { function a(t, e) { return h ? t > e : t < e; } const r = e.length; if (t.onBand && !n && r) { let s; const l = t.getExtent(); if (r === 1)e[0].coord = l[0], s = e[1] = { coord: l[0] }; else { const u = e[1].coord - e[0].coord; d(e, (t) => { t.coord -= u / 2; var e = e || 0; e % 2 > 0 && (t.coord -= u / (2 * (e + 1))); }), s = { coord: e[r - 1].coord + u }, e.push(s); } var h = l[0] > l[1]; a(e[0].coord, l[0]) && (o ? e[0].coord = l[0] : e.shift()), o && a(l[0], e[0].coord) && e.unshift({ coord: l[0] }), a(l[1], s.coord) && (o ? s.coord = l[1] : e.pop()), o && a(s.coord, l[1]) && e.push({ coord: l[1] }); } } function xu(t, e) { const i = t.mapDimension("defaultedLabel", !0); const n = i.length; if (n === 1) return dr(t, e, i[0]); if (n) { for (var o = [], a = 0; a < i.length; a++) { const r = dr(t, e, i[a]); o.push(r); } return o.join(" "); } } function _u(t, e, i) { tb.call(this), this.updateData(t, e, i); } function wu(t) { return [t[0] / 2, t[1] / 2]; } function bu(t, e) { this.parent.drift(t, e); } function Su() { !ro(this) && Iu.call(this); } function Mu() { !ro(this) && Tu.call(this); } function Iu() { if (!this.incremental && !this.useHoverLayer) { const t = this.__symbolOriginalScale; const e = t[1] / t[0]; this.animateTo({ scale: [Math.max(1.1 * t[0], t[0] + 3), Math.max(1.1 * t[1], t[1] + 3 * e)] }, 400, "elasticOut"); } } function Tu() { this.incremental || this.useHoverLayer || this.animateTo({ scale: this.__symbolOriginalScale }, 400, "elasticOut"); } function Au(t) { this.group = new tb(), this._symbolCtor = t || _u; } function Du(t, e, i, n) { return e && !isNaN(e[0]) && !isNaN(e[1]) && !(n.isIgnore && n.isIgnore(i)) && !(n.clipShape && !n.clipShape.contain(e[0], e[1])) && t.getItemVisual(i, "symbol") !== "none"; } function Cu(t) { return t == null || w(t) || (t = { isIgnore: t }), t || {}; } function Lu(t) {
    const e = t.hostModel; return {
      itemStyle: e.getModel("itemStyle").getItemStyle(["color"]), hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(), symbolRotate: e.get("symbolRotate"), symbolOffset: e.get("symbolOffset"), hoverAnimation: e.get("hoverAnimation"), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label"), cursorStyle: e.get("cursor"),
    };
  } function ku(t, e, i) {
    let n; const o = t.getBaseAxis(); const a = t.getOtherAxis(o); const r = Pu(a, i); const s = o.dim; const l = a.dim; const u = e.mapDimension(l); const h = e.mapDimension(s); const c = l === "x" || l === "radius" ? 1 : 0; const d = f(t.dimensions, t => e.mapDimension(t)); const p = e.getCalculationInfo("stackResultDimension"); return (n |= fl(e, d[0])) && (d[0] = p), (n |= fl(e, d[1])) && (d[1] = p), {
      dataDimsForPoint: d, valueStart: r, valueAxisDim: l, baseAxisDim: s, stacked: !!n, valueDim: u, baseDim: h, baseDataOffset: c, stackedOverDimension: e.getCalculationInfo("stackedOverDimension"),
    };
  } function Pu(t, e) { let i = 0; const n = t.scale.getExtent(); return e === "start" ? i = n[0] : e === "end" ? i = n[1] : n[0] > 0 ? i = n[0] : n[1] < 0 && (i = n[1]), i; } function Nu(t, e, i, n) { let o = NaN; t.stacked && (o = i.get(i.getCalculationInfo("stackedOverDimension"), n)), isNaN(o) && (o = t.valueStart); const a = t.baseDataOffset; const r = []; return r[a] = i.get(t.baseDim, n), r[1 - a] = o, e.dataToPoint(r); } function Ou(t, e) {
    const i = []; return e.diff(t).add((t) => { i.push({ cmd: "+", idx: t }); }).update((t, e) => { i.push({ cmd: "=", idx: e, idx1: t }); }).remove((t) => { i.push({ cmd: "-", idx: t }); })
      .execute(), i;
  } function Eu(t) { return isNaN(t[0]) || isNaN(t[1]); } function Ru(t, e, i, n, o, a, r, s, l, u, h) { return u !== "none" && u ? zu.apply(this, arguments) : Bu.apply(this, arguments); } function zu(t, e, i, n, o, a, r, s, l, u, h) { for (var c = 0, d = i, f = 0; f < n; f++) { const p = e[d]; if (d >= o || d < 0) break; if (Eu(p)) { if (h) { d += a; continue; } break; } if (d === i)t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]); else if (l > 0) { const g = e[c]; const m = u === "y" ? 1 : 0; const v = (p[m] - g[m]) * l; wD(SD, g), SD[m] = g[m] + v, wD(MD, p), MD[m] = p[m] - v, t.bezierCurveTo(SD[0], SD[1], MD[0], MD[1], p[0], p[1]); } else t.lineTo(p[0], p[1]); c = d, d += a; } return f; } function Bu(t, e, i, n, o, a, r, s, l, u, h) { for (var c = 0, d = i, f = 0; f < n; f++) { const p = e[d]; if (d >= o || d < 0) break; if (Eu(p)) { if (h) { d += a; continue; } break; } if (d === i)t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]), wD(SD, p); else if (l > 0) { let g = d + a; let m = e[g]; if (h) for (;m && Eu(e[g]);)m = e[g += a]; let v = 0.5; const y = e[c]; if (!(m = e[g]) || Eu(m))wD(MD, p); else { Eu(m) && !h && (m = p), U(bD, m, y); var x; var _; if (u === "x" || u === "y") { const w = u === "x" ? 0 : 1; x = Math.abs(p[w] - y[w]), _ = Math.abs(p[w] - m[w]); } else x = uw(p, y), _ = uw(p, m); _D(MD, p, bD, -l * (1 - (v = _ / (_ + x)))); }yD(SD, SD, s), xD(SD, SD, r), yD(MD, MD, s), xD(MD, MD, r), t.bezierCurveTo(SD[0], SD[1], MD[0], MD[1], p[0], p[1]), _D(SD, p, bD, l * v); } else t.lineTo(p[0], p[1]); c = d, d += a; } return f; } function Vu(t, e) { const i = [1 / 0, 1 / 0]; const n = [-1 / 0, -1 / 0]; if (e) for (let o = 0; o < t.length; o++) { const a = t[o]; a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1]); } return { min: e ? i : n, max: e ? n : i }; } function Gu(t, e) { if (t.length === e.length) { for (let i = 0; i < t.length; i++) { const n = t[i]; const o = e[i]; if (n[0] !== o[0] || n[1] !== o[1]) return; } return !0; } } function Fu(t) { return typeof t === "number" ? t : t ? 0.5 : 0; } function Wu(t) { const e = t.getGlobalExtent(); if (t.onBand) { const i = t.getBandWidth() / 2 - 1; const n = e[1] > e[0] ? 1 : -1; e[0] += n * i, e[1] -= n * i; } return e; } function Hu(t, e, i) { if (!i.valueDim) return []; for (var n = [], o = 0, a = e.count(); o < a; o++)n.push(Nu(i, t, e, o)); return n; } function Zu(t, e, i, n) {
    const o = Wu(t.getAxis("x")); const a = Wu(t.getAxis("y")); const r = t.getBaseAxis().isHorizontal(); let s = Math.min(o[0], o[1]); let l = Math.min(a[0], a[1]); let u = Math.max(o[0], o[1]) - s; let h = Math.max(a[0], a[1]) - l; if (i)s -= 0.5, u += 0.5, l -= 0.5, h += 0.5; else { const c = n.get("lineStyle.width") || 2; const d = n.get("clipOverflow") ? c / 2 : Math.max(u, h); r ? (l -= d, h += 2 * d) : (s -= d, u += 2 * d); } const f = new yM({
      shape: {
        x: s, y: l, width: u, height: h,
      },
    }); return e && (f.shape[r ? "width" : "height"] = 0, Io(f, { shape: { width: u, height: h } }, n)), f;
  } function Uu(t, e, i, n) {
    const o = t.getAngleAxis(); const a = t.getRadiusAxis().getExtent().slice(); a[0] > a[1] && a.reverse(); const r = o.getExtent(); const s = Math.PI / 180; i && (a[0] -= 0.5, a[1] += 0.5); const l = new hM({
      shape: {
        cx: Vo(t.cx, 1), cy: Vo(t.cy, 1), r0: Vo(a[0], 1), r: Vo(a[1], 1), startAngle: -r[0] * s, endAngle: -r[1] * s, clockwise: o.inverse,
      },
    }); return e && (l.shape.endAngle = -r[0] * s, Io(l, { shape: { endAngle: -r[1] * s } }, n)), l;
  } function Xu(t, e, i, n) { return t.type === "polar" ? Uu(t, e, i, n) : Zu(t, e, i, n); } function ju(t, e, i) { for (var n = e.getBaseAxis(), o = n.dim === "x" || n.dim === "radius" ? 0 : 1, a = [], r = 0; r < t.length - 1; r++) { const s = t[r + 1]; const l = t[r]; a.push(l); const u = []; switch (i) { case "end": u[o] = s[o], u[1 - o] = l[1 - o], a.push(u); break; case "middle": var h = (l[o] + s[o]) / 2; var c = []; u[o] = c[o] = h, u[1 - o] = l[1 - o], c[1 - o] = s[1 - o], a.push(u), a.push(c); break; default: u[o] = l[o], u[1 - o] = s[1 - o], a.push(u); } } return t[r] && a.push(t[r]), a; } function Yu(t, e) { const i = t.getVisual("visualMeta"); if (i && i.length && t.count() && e.type === "cartesian2d") { for (var n, o, a = i.length - 1; a >= 0; a--) { const r = i[a].dimension; const s = t.dimensions[r]; const l = t.getDimensionInfo(s); if ((n = l && l.coordDim) === "x" || n === "y") { o = i[a]; break; } } if (o) { const u = e.getAxis(n); const h = f(o.stops, t => ({ coord: u.toGlobalCoord(u.dataToCoord(t.value)), color: t.color })); const c = h.length; const p = o.outerColors.slice(); c && h[0].coord > h[c - 1].coord && (h.reverse(), p.reverse()); const g = h[0].coord - 10; const m = h[c - 1].coord + 10; const v = m - g; if (v < 0.001) return "transparent"; d(h, (t) => { t.offset = (t.coord - g) / v; }), h.push({ offset: c ? h[c - 1].offset : 0.5, color: p[1] || "transparent" }), h.unshift({ offset: c ? h[0].offset : 0.5, color: p[0] || "transparent" }); const y = new TM(0, 0, 0, 0, h, !0); return y[n] = g, y[`${n}2`] = m, y; } } } function qu(t, e, i) { const n = t.get("showAllSymbol"); const o = n === "auto"; if (!n || o) { const a = i.getAxesByScale("ordinal")[0]; if (a && (!o || !Ku(a, e))) { const r = e.mapDimension(a.dim); const s = {}; return d(a.getViewLabels(), (t) => { s[t.tickValue] = 1; }), function (t) { return !s.hasOwnProperty(e.get(r, t)); }; } } } function Ku(t, e) { const i = t.getExtent(); let n = Math.abs(i[1] - i[0]) / t.scale.count(); isNaN(n) && (n = 0); for (let o = e.count(), a = Math.max(1, Math.round(o / 5)), r = 0; r < o; r += a) if (1.5 * _u.getSymbolSize(e, r)[t.isHorizontal() ? 1 : 0] > n) return !1; return !0; } function $u(t) { return this._axes[t]; } function Ju(t) { kD.call(this, t); } function Qu(t, e) { return e.type || (e.data ? "category" : "value"); } function th(t, e, i) { return t.getCoordSysModel() === e; } function eh(t, e, i) { this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this.model = t; } function ih(t, e, i, n) { function o(t) { return `${t.dim}_${t.index}`; }i.getAxesOnZeroOf = function () { return a ? [a] : []; }; let a; const r = t[e]; const s = i.model; const l = s.get("axisLine.onZero"); const u = s.get("axisLine.onZeroAxisIndex"); if (l) { if (u != null)nh(r[u]) && (a = r[u]); else for (const h in r) if (r.hasOwnProperty(h) && nh(r[h]) && !n[o(r[h])]) { a = r[h]; break; }a && (n[o(a)] = !0); } } function nh(t) { return t && t.type !== "category" && t.type !== "time" && Hl(t); } function oh(t, e) { const i = t.getExtent(); const n = i[0] + i[1]; t.toGlobalCoord = t.dim === "x" ? function (t) { return t + e; } : function (t) { return n - t + e; }, t.toLocalCoord = t.dim === "x" ? function (t) { return t - e; } : function (t) { return n - t + e; }; } function ah(t, e) { return f(GD, e => t.getReferringComponents(e)[0]); } function rh(t) { return t.get("coordinateSystem") === "cartesian2d"; } function sh(t) { const e = { componentType: t.mainType, componentIndex: t.componentIndex }; return e[`${t.mainType}Index`] = t.componentIndex, e; } function lh(t, e, i, n) { let o; let a; const r = Uo(i - t.rotation); const s = n[0] > n[1]; const l = e === "start" && !s || e !== "start" && s; return Xo(r - FD / 2) ? (a = l ? "bottom" : "top", o = "center") : Xo(r - 1.5 * FD) ? (a = l ? "top" : "bottom", o = "center") : (a = "middle", o = r < 1.5 * FD && r > FD / 2 ? l ? "left" : "right" : l ? "right" : "left"), { rotation: r, textAlign: o, textVerticalAlign: a }; } function uh(t) { const e = t.get("tooltip"); return t.get("silent") || !(t.get("triggerEvent") || e && e.show); } function hh(t, e, i) { if (!ql(t.axis)) { const n = t.get("axisLabel.showMinLabel"); const o = t.get("axisLabel.showMaxLabel"); e = e || [], i = i || []; const a = e[0]; const r = e[1]; const s = e[e.length - 1]; const l = e[e.length - 2]; const u = i[0]; const h = i[1]; const c = i[i.length - 1]; const d = i[i.length - 2]; !1 === n ? (ch(a), ch(u)) : dh(a, r) && (n ? (ch(r), ch(h)) : (ch(a), ch(u))), !1 === o ? (ch(s), ch(c)) : dh(l, s) && (o ? (ch(l), ch(d)) : (ch(s), ch(c))); } } function ch(t) { t && (t.ignore = !0); } function dh(t, e, i) { const n = t && t.getBoundingRect().clone(); const o = e && e.getBoundingRect().clone(); if (n && o) { const a = _t([]); return Mt(a, a, -t.rotation), n.applyTransform(bt([], a, t.getLocalTransform())), o.applyTransform(bt([], a, e.getLocalTransform())), n.intersect(o); } } function fh(t) { return t === "middle" || t === "center"; } function ph(t, e, i) {
    const n = e.axis; if (e.get("axisTick.show") && !n.scale.isBlank()) {
      for (var o = e.getModel("axisTick"), a = o.getModel("lineStyle"), s = o.get("length"), l = n.getTicksCoords(), u = [], h = [], c = t._transform, d = [], f = 0; f < l.length; f++) {
        const p = l[f].coord; u[0] = p, u[1] = 0, h[0] = p, h[1] = i.tickDirection * s, c && (Q(u, u, c), Q(h, h, c)); const g = new _M(qn({
          anid: `tick_${l[f].tickValue}`,
          shape: {
            x1: u[0], y1: u[1], x2: h[0], y2: h[1],
          },
          style: r(a.getLineStyle(), { stroke: e.get("axisLine.lineStyle.color") }),
          z2: 2,
          silent: !0,
        })); t.group.add(g), d.push(g);
      } return d;
    }
  } function gh(t, e, i) {
    const n = e.axis; if (T(i.axisLabelShow, e.get("axisLabel.show")) && !n.scale.isBlank()) {
      const o = e.getModel("axisLabel"); const a = o.get("margin"); const r = n.getViewLabels(); const s = (T(i.labelRotate, o.get("rotate")) || 0) * FD / 180; const l = ZD(i.rotation, s, i.labelDirection); const u = e.getCategories(!0); const h = []; const c = uh(e); const f = e.get("triggerEvent"); return d(r, (r, s) => {
        const d = r.tickValue; const p = r.formattedLabel; const g = r.rawLabel; let m = o; u && u[d] && u[d].textStyle && (m = new Po(u[d].textStyle, o, e.ecModel)); const v = m.getTextColor() || e.get("axisLine.lineStyle.color"); const y = [n.dataToCoord(d), i.labelOffset + i.labelDirection * a]; const x = new rM({
          anid: `label_${d}`, position: y, rotation: l.rotation, silent: c, z2: 10,
        }); go(x.style, m, {
          text: p, textAlign: m.getShallow("align", !0) || l.textAlign, textVerticalAlign: m.getShallow("verticalAlign", !0) || m.getShallow("baseline", !0) || l.textVerticalAlign, textFill: typeof v === "function" ? v(n.type === "category" ? g : n.type === "value" ? `${d}` : d, s) : v,
        }), f && (x.eventData = sh(e), x.eventData.targetType = "axisLabel", x.eventData.value = g), t._dumbGroup.add(x), x.updateTransform(), h.push(x), t.group.add(x), x.decomposeTransform();
      }), h;
    }
  } function mh(t, e) {
    const i = {
      axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {},
    }; return vh(i, t, e), i.seriesInvolved && xh(i, t), i;
  } function vh(t, e, i) {
    const n = e.getComponent("tooltip"); const o = e.getComponent("axisPointer"); const a = o.get("link", !0) || []; const r = []; UD(i.getCoordinateSystems(), (i) => {
      function s(n, s, l) {
        let c = l.model.getModel("axisPointer", o); const d = c.get("show"); if (d && (d !== "auto" || n || Ih(c))) {
          s == null && (s = c.get("triggerTooltip")); const f = (c = n ? yh(l, h, o, e, n, s) : c).get("snap"); const p = Th(l.model); const g = s || f || l.type === "category"; const m = t.axesInfo[p] = {
            key: p, axis: l, coordSys: i, axisPointerModel: c, triggerTooltip: s, involveSeries: g, snap: f, useHandle: Ih(c), seriesModels: [],
          }; u[p] = m, t.seriesInvolved |= g; const v = _h(a, l); if (v != null) { const y = r[v] || (r[v] = { axesInfo: {} }); y.axesInfo[p] = m, y.mapper = a[v].mapper, m.linkGroup = y; }
        }
      } if (i.axisPointerEnabled) { const l = Th(i.model); var u = t.coordSysAxesInfo[l] = {}; t.coordSysMap[l] = i; var h = i.model.getModel("tooltip", n); if (UD(i.getAxes(), XD(s, !1, null)), i.getTooltipAxes && n && h.get("show")) { const c = h.get("trigger") === "axis"; const d = h.get("axisPointer.type") === "cross"; const f = i.getTooltipAxes(h.get("axisPointer.axis")); (c || d) && UD(f.baseAxes, XD(s, !d || "cross", c)), d && UD(f.otherAxes, XD(s, "cross", !1)); } }
    });
  } function yh(t, e, n, o, a, s) { const l = e.getModel("axisPointer"); const u = {}; UD(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], (t) => { u[t] = i(l.get(t)); }), u.snap = t.type !== "category" && !!s, l.get("type") === "cross" && (u.type = "line"); const h = u.label || (u.label = {}); if (h.show == null && (h.show = !1), a === "cross") { const c = l.get("label.show"); if (h.show = c == null || c, !s) { const d = u.lineStyle = l.get("crossStyle"); d && r(h, d.textStyle); } } return t.model.getModel("axisPointer", new Po(u, n, o)); } function xh(t, e) { e.eachSeries((e) => { const i = e.coordinateSystem; const n = e.get("tooltip.trigger", !0); const o = e.get("tooltip.show", !0); i && n !== "none" && !1 !== n && n !== "item" && !1 !== o && !1 !== e.get("axisPointer.show", !0) && UD(t.coordSysAxesInfo[Th(i.model)], (t) => { const n = t.axis; i.getAxis(n.dim) === n && (t.seriesModels.push(e), t.seriesDataCount == null && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count()); }); }, this); } function _h(t, e) { for (let i = e.model, n = e.dim, o = 0; o < t.length; o++) { const a = t[o] || {}; if (wh(a[`${n}AxisId`], i.id) || wh(a[`${n}AxisIndex`], i.componentIndex) || wh(a[`${n}AxisName`], i.name)) return o; } } function wh(t, e) { return t === "all" || y(t) && l(t, e) >= 0 || t === e; } function bh(t) { const e = Sh(t); if (e) { const i = e.axisPointerModel; const n = e.axis.scale; const o = i.option; const a = i.get("status"); let r = i.get("value"); r != null && (r = n.parse(r)); const s = Ih(i); a == null && (o.status = s ? "show" : "hide"); const l = n.getExtent().slice(); l[0] > l[1] && l.reverse(), (r == null || r > l[1]) && (r = l[1]), r < l[0] && (r = l[0]), o.value = r, s && (o.status = e.axis.scale.isBlank() ? "hide" : "show"); } } function Sh(t) { const e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo; return e && e.axesInfo[Th(t)]; } function Mh(t) { const e = Sh(t); return e && e.axisPointerModel; } function Ih(t) { return !!t.get("handle.show"); } function Th(t) { return `${t.type}||${t.id}`; } function Ah(t, e, i, n, o, a) { const r = jD.getAxisPointerClass(t.axisPointerClass); if (r) { const s = Mh(e); s ? (t._axisPointer || (t._axisPointer = new r())).render(e, s, n, a) : Dh(t, n); } } function Dh(t, e, i) { const n = t._axisPointer; n && n.dispose(e, i), t._axisPointer = null; } function Ch(t, e, i) {
    i = i || {}; const n = t.coordinateSystem; const o = e.axis; const a = {}; const r = o.getAxesOnZeroOf()[0]; const s = o.position; const l = r ? "onZero" : s; const u = o.dim; const h = n.getRect(); const c = [h.x, h.x + h.width, h.y, h.y + h.height]; const d = {
      left: 0, right: 1, top: 0, bottom: 1, onZero: 2,
    }; const f = e.get("offset") || 0; const p = u === "x" ? [c[2] - f, c[3] + f] : [c[0] - f, c[1] + f]; if (r) { const g = r.toGlobalCoord(r.dataToCoord(0)); p[d.onZero] = Math.max(Math.min(g, p[1]), p[0]); }a.position = [u === "y" ? p[d[l]] : c[0], u === "x" ? p[d[l]] : c[3]], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1); const m = {
      top: -1, bottom: 1, left: -1, right: 1,
    }; a.labelDirection = a.tickDirection = a.nameDirection = m[s], a.labelOffset = r ? p[d[s]] - p[d.onZero] : 0, e.get("axisTick.inside") && (a.tickDirection = -a.tickDirection), T(i.labelInside, e.get("axisLabel.inside")) && (a.labelDirection = -a.labelDirection); const v = e.get("axisLabel.rotate"); return a.labelRotate = l === "top" ? -v : v, a.z2 = 1, a;
  } function Lh(t, e, i, n, o, a, r) {
    po(t, e, i.getModel("label"), i.getModel("emphasis.label"), {
      labelFetcher: o, labelDataIndex: a, defaultText: xu(o.getData(), a), isRectText: !0, autoColor: n,
    }), kh(t), kh(e);
  } function kh(t, e) { t.textPosition === "outside" && (t.textPosition = e); } function Ph(t, e, i) { i.style.text = null, Mo(i, { shape: { width: 0 } }, e, t, () => { i.parent && i.parent.remove(i); }); } function Nh(t, e, i) { i.style.text = null, Mo(i, { shape: { r: i.shape.r0 } }, e, t, () => { i.parent && i.parent.remove(i); }); } function Oh(t, e, i, n, o, a, s, l) { const u = e.getItemVisual(i, "color"); const h = e.getItemVisual(i, "opacity"); const c = n.getModel("itemStyle"); const d = n.getModel("emphasis.itemStyle").getBarItemStyle(); l || t.setShape("r", c.get("barBorderRadius") || 0), t.useStyle(r({ fill: u, opacity: h }, c.getBarItemStyle())); const f = n.getShallow("cursor"); f && t.attr("cursor", f); const p = s ? o.height > 0 ? "bottom" : "top" : o.width > 0 ? "left" : "right"; l || Lh(t.style, d, n, u, a, i, p), co(t, d); } function Eh(t, e) { const i = t.get(eC) || 0; return Math.min(i, Math.abs(e.width), Math.abs(e.height)); } function Rh(t, e, i) {
    const n = t.getData(); const o = []; const a = n.getLayout("valueAxisHorizontal") ? 1 : 0; o[1 - a] = n.getLayout("valueAxisStart"); const r = new oC({
      shape: { points: n.getLayout("largePoints") }, incremental: !!i, __startPoint: o, __valueIdx: a,
    }); e.add(r), zh(r, t, n);
  } function zh(t, e, i) { const n = i.getVisual("borderColor") || i.getVisual("color"); const o = e.getModel("itemStyle").getItemStyle(["color", "borderColor"]); t.useStyle(o), t.style.fill = null, t.style.stroke = n, t.style.lineWidth = i.getLayout("barWidth"); } function Bh(t, e, i, n) {
    const o = e.getData(); const a = this.dataIndex; const r = o.getName(a); const s = e.get("selectedOffset"); n.dispatchAction({
      type: "pieToggleSelect", from: t, name: r, seriesId: e.id,
    }), o.each((t) => { Vh(o.getItemGraphicEl(t), o.getItemLayout(t), e.isSelected(o.getName(t)), s, i); });
  } function Vh(t, e, i, n, o) { const a = (e.startAngle + e.endAngle) / 2; const r = Math.cos(a); const s = Math.sin(a); const l = i ? n : 0; const u = [r * l, s * l]; o ? t.animate().when(200, { position: u }).start("bounceOut") : t.attr("position", u); } function Gh(t, e) { function i() { a.ignore = a.hoverIgnore, r.ignore = r.hoverIgnore; } function n() { a.ignore = a.normalIgnore, r.ignore = r.normalIgnore; }tb.call(this); const o = new hM({ z2: 2 }); var a = new gM(); var r = new rM(); this.add(o), this.add(a), this.add(r), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n); } function Fh(t, e, i, n, o, a, r) { function s(e, i) { for (let n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1].height)); n--); } function l(t, e, i, n, o, a) { for (let r = e ? Number.MAX_VALUE : 0, s = 0, l = t.length; s < l; s++) { const u = Math.abs(t[s].y - n); const h = t[s].len; const c = t[s].len2; let d = u < o + h ? Math.sqrt((o + h + c) * (o + h + c) - u * u) : Math.abs(t[s].x - i); e && d >= r && (d = r - 10), !e && d <= r && (d = r + 10), t[s].x = i + d * a, r = d; } }t.sort((t, e) => t.y - e.y); for (var u, h = 0, c = t.length, d = [], f = [], p = 0; p < c; p++)(u = t[p].y - h) < 0 && (function (e, i, n, o) { for (let a = e; a < i; a++) if (t[a].y += n, a > e && a + 1 < i && t[a + 1].y > t[a].y + t[a].height) return void s(a, n / 2); s(i - 1, n / 2); }(p, c, -u)), h = t[p].y + t[p].height; r - h < 0 && s(c - 1, h - r); for (p = 0; p < c; p++)t[p].y >= i ? f.push(t[p]) : d.push(t[p]); l(d, !1, e, i, n, o), l(f, !0, e, i, n, o); } function Wh(t, e, i, n, o, a) { for (var r = [], s = [], l = 0; l < t.length; l++)Hh(t[l]) || (t[l].x < e ? r.push(t[l]) : s.push(t[l])); Fh(s, e, i, n, 1, o, a), Fh(r, e, i, n, -1, o, a); for (l = 0; l < t.length; l++) if (!Hh(t[l])) { const u = t[l].linePoints; if (u) { const h = u[1][0] - u[2][0]; t[l].x < e ? u[2][0] = t[l].x + 3 : u[2][0] = t[l].x - 3, u[1][1] = u[2][1] = t[l].y, u[1][0] = u[2][0] + h; } } } function Hh(t) { return t.position === "center"; } function Zh() { this.group = new tb(); } function Uh(t, e, i) { rD.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model; } function Xh(t, e, i) { this._model = t, this.dimensions = [], this._indicatorAxes = f(t.getIndicatorModels(), function (t, e) { const i = `indicator_${e}`; const n = new Uh(i, new AA()); return n.name = t.get("name"), n.model = t, t.axis = n, this.dimensions.push(i), n; }, this), this.resize(t, i), this.cx, this.cy, this.r, this.r0, this.startAngle; } function jh(t, e) { return r({ show: e }, t); } function Yh(t) { return y(t) || (t = [+t, +t]), t; } function qh(t) { for (var e, i = 0; i < t.length; i++) { const n = t[i].getBoundingRect(); (e = e || n.clone()).union(n); } return e; } function Kh(t, e) { let i; let n; const o = t.svgXML; try { k((n = (i = o && as(o, { ignoreViewBox: !0, ignoreRootClip: !0 }) || {}).root) != null); } catch (t) { throw new Error(`Invalid svg format\n${t.message}`); } const a = i.width; const r = i.height; const s = i.viewBoxRect; if (e || (e = a == null || r == null ? n.getBoundingRect() : new de(0, 0, 0, 0), a != null && (e.width = a), r != null && (e.height = r)), s) { const l = os(s, e.width, e.height); const u = n; (n = new tb()).add(u), u.scale = l.scale, u.position = l.position; } return n.setClipPath(new yM({ shape: e.plain() })), { root: n, boundingRect: e }; } function $h(t) { return function (e, i) { const n = []; return d(Jh(e), (o) => { const a = OC[o.type][t]; a && n.push(a(e, o, i)); }), n; }; } function Jh(t) { return CT.retrieveMap(t) || []; } function Qh(t, e, i) { ic(t)[e] = i; } function tc(t, e, i) { const n = ic(t); n[e] === i && (n[e] = null); } function ec(t, e) { return !!ic(t)[e]; } function ic(t) { return t[RC] || (t[RC] = {}); } function nc(t) {
    this.pointerChecker, this._zr = t, this._opt = {}; const e = m; const n = e(oc, this); const o = e(ac, this); const a = e(rc, this); const s = e(sc, this); const l = e(lc, this); fw.call(this), this.setPointerChecker = function (t) { this.pointerChecker = t; }, this.enable = function (e, u) {
      this.disable(), this._opt = r(i(u) || {}, {
        zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0,
      }), e == null && (e = !0), !0 !== e && e !== "move" && e !== "pan" || (t.on("mousedown", n), t.on("mousemove", o), t.on("mouseup", a)), !0 !== e && e !== "scale" && e !== "zoom" || (t.on("mousewheel", s), t.on("pinch", l));
    }, this.disable = function () { t.off("mousedown", n), t.off("mousemove", o), t.off("mouseup", a), t.off("mousewheel", s), t.off("pinch", l); }, this.dispose = this.disable, this.isDragging = function () { return this._dragging; }, this.isPinching = function () { return this._pinching; };
  } function oc(t) { if (!(dt(t) || t.target && t.target.draggable)) { const e = t.offsetX; const i = t.offsetY; this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e, this._y = i, this._dragging = !0); } } function ac(t) {
    if (this._dragging && cc("moveOnMouseMove", t, this._opt) && t.gestureEvent !== "pinch" && !ec(this._zr, "globalPan")) {
      const e = t.offsetX; const i = t.offsetY; const n = this._x; const o = this._y; const a = e - n; const r = i - o; this._x = e, this._y = i, this._opt.preventDefaultMouseMove && mw(t.event), hc(this, "pan", "moveOnMouseMove", t, {
        dx: a, dy: r, oldX: n, oldY: o, newX: e, newY: i,
      });
    }
  } function rc(t) { dt(t) || (this._dragging = !1); } function sc(t) { const e = cc("zoomOnMouseWheel", t, this._opt); const i = cc("moveOnMouseWheel", t, this._opt); const n = t.wheelDelta; const o = Math.abs(n); const a = t.offsetX; const r = t.offsetY; if (n !== 0 && (e || i)) { if (e) { const s = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1; uc(this, "zoom", "zoomOnMouseWheel", t, { scale: n > 0 ? s : 1 / s, originX: a, originY: r }); } if (i) { const l = Math.abs(n); uc(this, "scrollMove", "moveOnMouseWheel", t, { scrollDelta: (n > 0 ? 1 : -1) * (l > 3 ? 0.4 : l > 1 ? 0.15 : 0.05), originX: a, originY: r }); } } } function lc(t) { ec(this._zr, "globalPan") || uc(this, "zoom", null, t, { scale: t.pinchScale > 1 ? 1.1 : 1 / 1.1, originX: t.pinchX, originY: t.pinchY }); } function uc(t, e, i, n, o) { t.pointerChecker && t.pointerChecker(n, o.originX, o.originY) && (mw(n.event), hc(t, e, i, n, o)); } function hc(t, e, i, n, o) { o.isAvailableBehavior = m(cc, null, i, n), t.trigger(e, o); } function cc(t, e, i) { const n = i[t]; return !t || n && (!_(n) || e.event[`${n}Key`]); } function dc(t, e, i) { const n = t.target; const o = n.position; o[0] += e, o[1] += i, n.dirty(); } function fc(t, e, i, n) { const o = t.target; const a = t.zoomLimit; const r = o.position; const s = o.scale; let l = t.zoom = t.zoom || 1; if (l *= e, a) { const u = a.min || 0; const h = a.max || 1 / 0; l = Math.max(Math.min(h, l), u); } const c = l / t.zoom; t.zoom = l, r[0] -= (i - r[0]) * (c - 1), r[1] -= (n - r[1]) * (c - 1), s[0] *= c, s[1] *= c, o.dirty(); } function pc(t, e, i) { const n = e.getComponentByElement(t.topTarget); const o = n && n.coordinateSystem; return n && n !== i && !zC[n.mainType] && o && o.model !== i; } function gc(t, e) { const i = t.getItemStyle(); const n = t.get("areaColor"); return n != null && (i.fill = n), i; } function mc(t, e, i, n, o) { i.off("click"), i.off("mousedown"), e.get("selectedMode") && (i.on("mousedown", () => { t._mouseDownFlag = !0; }), i.on("click", (a) => { if (t._mouseDownFlag) { t._mouseDownFlag = !1; for (var r = a.target; !r.__regions;)r = r.parent; if (r) { const s = { type: `${e.mainType === "geo" ? "geo" : "map"}ToggleSelect`, batch: f(r.__regions, t => ({ name: t.name, from: o.uid })) }; s[`${e.mainType}Id`] = e.id, n.dispatchAction(s), vc(e, i); } } })); } function vc(t, e) { e.eachChild((e) => { d(e.__regions, (i) => { e.trigger(t.isSelected(i.name) ? "emphasis" : "normal"); }); }); } function yc(t, e) { const i = new tb(); this.uid = Eo("ec_map_draw"), this._controller = new nc(t.getZr()), this._controllerHost = { target: e ? i : null }, this.group = i, this._updateGroup = e, this._mouseDownFlag, this._mapName, this._initialized, i.add(this._regionsGroup = new tb()), i.add(this._backgroundGroup = new tb()); } function xc(t) { const e = this[BC]; e && e.recordVersion === this[VC] && _c(e, t); } function _c(t, e) { const i = t.circle; const n = t.labelModel; const o = t.hoverLabelModel; const a = t.emphasisText; const r = t.normalText; e ? (i.style.extendFrom(go({}, o, { text: o.get("show") ? a : null }, { isRectText: !0, useInsideStyle: !1 }, !0)), i.__mapOriginalZ2 = i.z2, i.z2 += NM) : (go(i.style, n, { text: n.get("show") ? r : null, textPosition: n.getShallow("position") || "bottom" }, { isRectText: !0, useInsideStyle: !1 }), i.dirty(!1), i.__mapOriginalZ2 != null && (i.z2 = i.__mapOriginalZ2, i.__mapOriginalZ2 = null)); } function wc(t, e, i) { const n = t.getZoom(); let o = t.getCenter(); let a = e.zoom; const r = t.dataToPoint(o); if (e.dx != null && e.dy != null) { r[0] -= e.dx, r[1] -= e.dy; o = t.pointToData(r); t.setCenter(o); } if (a != null) { if (i) { const s = i.min || 0; const l = i.max || 1 / 0; a = Math.max(Math.min(n * a, l), s) / n; }t.scale[0] *= a, t.scale[1] *= a; const u = t.position; const h = (e.originX - u[0]) * (a - 1); const c = (e.originY - u[1]) * (a - 1); u[0] -= h, u[1] -= c, t.updateTransform(); o = t.pointToData(r); t.setCenter(o), t.setZoom(a * n); } return { center: t.getCenter(), zoom: t.getZoom() }; } function bc() { Tw.call(this); } function Sc(t) { this.name = t, this.zoomLimit, Tw.call(this), this._roamTransformable = new bc(), this._rawTransformable = new bc(), this._center, this._zoom; } function Mc(t, e, i, n) { const o = i.seriesModel; const a = o ? o.coordinateSystem : null; return a === this ? a[t](n) : null; } function Ic(t, e, i, n) { Sc.call(this, t), this.map = e; const o = EC.load(e, i); this._nameCoordMap = o.nameCoordMap, this._regionsMap = o.regionsMap, this._invertLongitute = n == null || n, this.regions = o.regions, this._rect = o.boundingRect; } function Tc(t, e, i, n) { const o = i.geoModel; const a = i.seriesModel; const r = o ? o.coordinateSystem : a ? a.coordinateSystem || (a.getReferringComponents("geo")[0] || {}).coordinateSystem : null; return r === this ? r[t](n) : null; } function Ac(t, e) { const i = t.get("boundingCoords"); if (i != null) { const n = i[0]; const o = i[1]; isNaN(n[0]) || isNaN(n[1]) || isNaN(o[0]) || isNaN(o[1]) || this.setBoundingRect(n[0], n[1], o[0] - n[0], o[1] - n[1]); } let a; const r = this.getBoundingRect(); let s = t.get("layoutCenter"); let l = t.get("layoutSize"); const u = e.getWidth(); const h = e.getHeight(); const c = r.width / r.height * this.aspectScale; let d = !1; s && l && (s = [Bo(s[0], u), Bo(s[1], h)], l = Bo(l, Math.min(u, h)), isNaN(s[0]) || isNaN(s[1]) || isNaN(l) || (d = !0)); if (d) { var f = {}; c > 1 ? (f.width = l, f.height = l / c) : (f.height = l, f.width = l * c), f.y = s[1] - f.height / 2, f.x = s[0] - f.width / 2; } else (a = t.getBoxLayoutParams()).aspect = c, f = ha(a, { width: u, height: h }); this.setViewRect(f.x, f.y, f.width, f.height), this.setCenter(t.get("center")), this.setZoom(t.get("zoom")); } function Dc(t, e) { d(e.get("geoCoord"), (e, i) => { t.addGeoCoord(i, e); }); } function Cc(t, e) { const i = {}; return d(t, (t) => { t.each(t.mapDimension("value"), (e, n) => { const o = `ec-${t.getName(n)}`; i[o] = i[o] || [], isNaN(e) || i[o].push(e); }); }), t[0].map(t[0].mapDimension("value"), (n, o) => { for (var a = `ec-${t[0].getName(o)}`, r = 0, s = 1 / 0, l = -1 / 0, u = i[a].length, h = 0; h < u; h++)s = Math.min(s, i[a][h]), l = Math.max(l, i[a][h]), r += i[a][h]; let c; return c = e === "min" ? s : e === "max" ? l : e === "average" ? r / u : r, u === 0 ? NaN : c; }); } function Lc(t) { const e = t.mainData; let i = t.datas; i || (i = { main: e }, t.datasAttr = { main: "data" }), t.datas = t.mainData = null, Rc(e, i, t), WC(i, (i) => { WC(e.TRANSFERABLE_METHODS, (e) => { i.wrapMethod(e, v(kc, t)); }); }), e.wrapMethod("cloneShallow", v(Nc, t)), WC(e.CHANGABLE_METHODS, (i) => { e.wrapMethod(i, v(Pc, t)); }), k(i[e.dataType] === e); } function kc(t, e) { if (Ec(this)) { const i = a({}, this[HC]); i[this.dataType] = e, Rc(e, i, t); } else zc(e, this.dataType, this[ZC], t); return e; } function Pc(t, e) { return t.struct && t.struct.update(this), e; } function Nc(t, e) { return WC(e[HC], (i, n) => { i !== e && zc(i.cloneShallow(), n, e, t); }), e; } function Oc(t) { const e = this[ZC]; return t == null || e == null ? e : e[HC][t]; } function Ec(t) { return t[ZC] === t; } function Rc(t, e, i) { t[HC] = {}, WC(e, (e, n) => { zc(e, n, t, i); }); } function zc(t, e, i, n) { i[HC][e] = t, t[ZC] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = Oc; } function Bc(t, e, i) { this.root, this.data, this._nodes = [], this.hostModel = t, this.levelModels = f(e || [], e => new Po(e, t, t.ecModel)), this.leavesModel = new Po(i || {}, t, t.ecModel); } function Vc(t, e) { const i = e.children; t.parentNode !== e && (i.push(t), t.parentNode = e); } function Gc(t) {
    t.hierNode = {
      defaultAncestor: null, ancestor: t, prelim: 0, modifier: 0, change: 0, shift: 0, i: 0, thread: null,
    }; for (var e, i, n = [t]; e = n.pop();) {
      if (i = e.children, e.isExpand && i.length) {
        for (let o = i.length - 1; o >= 0; o--) {
          const a = i[o]; a.hierNode = {
            defaultAncestor: null, ancestor: a, prelim: 0, modifier: 0, change: 0, shift: 0, i: o, thread: null,
          }, n.push(a);
        }
      }
    }
  } function Fc(t, e) { const i = t.isExpand ? t.children : []; const n = t.parentNode.children; const o = t.hierNode.i ? n[t.hierNode.i - 1] : null; if (i.length) { Xc(t); const a = (i[0].hierNode.prelim + i[i.length - 1].hierNode.prelim) / 2; o ? (t.hierNode.prelim = o.hierNode.prelim + e(t, o), t.hierNode.modifier = t.hierNode.prelim - a) : t.hierNode.prelim = a; } else o && (t.hierNode.prelim = o.hierNode.prelim + e(t, o)); t.parentNode.hierNode.defaultAncestor = jc(t, o, t.parentNode.hierNode.defaultAncestor || n[0], e); } function Wc(t) { const e = t.hierNode.prelim + t.parentNode.hierNode.modifier; t.setLayout({ x: e }, !0), t.hierNode.modifier += t.parentNode.hierNode.modifier; } function Hc(t) { return arguments.length ? t : Jc; } function Zc(t, e) { const i = {}; return t -= Math.PI / 2, i.x = e * Math.cos(t), i.y = e * Math.sin(t), i; } function Uc(t, e) { return ha(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }); } function Xc(t) { for (let e = t.children, i = e.length, n = 0, o = 0; --i >= 0;) { const a = e[i]; a.hierNode.prelim += n, a.hierNode.modifier += n, o += a.hierNode.change, n += a.hierNode.shift + o; } } function jc(t, e, i, n) { if (e) { for (var o = t, a = t, r = a.parentNode.children[0], s = e, l = o.hierNode.modifier, u = a.hierNode.modifier, h = r.hierNode.modifier, c = s.hierNode.modifier; s = Yc(s), a = qc(a), s && a;) { o = Yc(o), r = qc(r), o.hierNode.ancestor = t; const d = s.hierNode.prelim + c - a.hierNode.prelim - u + n(s, a); d > 0 && ($c(Kc(s, t, i), t, d), u += d, l += d), c += s.hierNode.modifier, u += a.hierNode.modifier, l += o.hierNode.modifier, h += r.hierNode.modifier; }s && !Yc(o) && (o.hierNode.thread = s, o.hierNode.modifier += c - l), a && !qc(r) && (r.hierNode.thread = a, r.hierNode.modifier += u - h, i = t); } return i; } function Yc(t) { const e = t.children; return e.length && t.isExpand ? e[e.length - 1] : t.hierNode.thread; } function qc(t) { const e = t.children; return e.length && t.isExpand ? e[0] : t.hierNode.thread; } function Kc(t, e, i) { return t.hierNode.ancestor.parentNode === e.parentNode ? t.hierNode.ancestor : i; } function $c(t, e, i) { const n = i / (e.hierNode.i - t.hierNode.i); e.hierNode.change -= n, e.hierNode.shift += i, e.hierNode.modifier += i, e.hierNode.prelim += i, t.hierNode.change += n; } function Jc(t, e) { return t.parentNode === e.parentNode ? 1 : 2; } function Qc(t, e) { const i = t.getItemLayout(e); return i && !isNaN(i.x) && !isNaN(i.y) && t.getItemVisual(e, "symbol") !== "none"; } function td(t, e, i) { return i.itemModel = e, i.itemStyle = e.getModel("itemStyle").getItemStyle(), i.hoverItemStyle = e.getModel("emphasis.itemStyle").getItemStyle(), i.lineStyle = e.getModel("lineStyle").getLineStyle(), i.labelModel = e.getModel("label"), i.hoverLabelModel = e.getModel("emphasis.label"), !1 === t.isExpand && t.children.length !== 0 ? i.symbolInnerColor = i.itemStyle.fill : i.symbolInnerColor = "#fff", i; } function ed(t, e, i, n, o, a) {
    const s = !i; const l = t.tree.getNodeByDataIndex(e); var a = td(l, l.getModel(), a); const u = t.tree.root; const h = l.parentNode === u ? l : l.parentNode || l; const c = t.getItemGraphicEl(h.dataIndex); const d = h.getLayout(); const f = c ? {
      x: c.position[0], y: c.position[1], rawX: c.__radialOldRawX, rawY: c.__radialOldRawY,
    } : d; const p = l.getLayout(); s ? (i = new _u(t, e, a)).attr("position", [f.x, f.y]) : i.updateData(t, e, a), i.__radialOldRawX = i.__radialRawX, i.__radialOldRawY = i.__radialRawY, i.__radialRawX = p.rawX, i.__radialRawY = p.rawY, n.add(i), t.setItemGraphicEl(e, i), Mo(i, { position: [p.x, p.y] }, o); const g = i.getSymbolPath(); if (a.layout === "radial") {
      let m; let v; const y = u.children[0]; const x = y.getLayout(); const _ = y.children.length; if (p.x === x.x && !0 === l.isExpand) { const w = {}; w.x = (y.children[0].getLayout().x + y.children[_ - 1].getLayout().x) / 2, w.y = (y.children[0].getLayout().y + y.children[_ - 1].getLayout().y) / 2, (m = Math.atan2(w.y - x.y, w.x - x.x)) < 0 && (m = 2 * Math.PI + m), (v = w.x < x.x) && (m -= Math.PI); } else (m = Math.atan2(p.y - x.y, p.x - x.x)) < 0 && (m = 2 * Math.PI + m), l.children.length === 0 || l.children.length !== 0 && !1 === l.isExpand ? (v = p.x < x.x) && (m -= Math.PI) : (v = p.x > x.x) || (m -= Math.PI); const b = v ? "left" : "right"; g.setStyle({
        textPosition: b, textRotation: -m, textOrigin: "center", verticalAlign: "middle",
      });
    } if (l.parentNode && l.parentNode !== u) { let S = i.__edge; S || (S = i.__edge = new bM({ shape: nd(a, f, f), style: r({ opacity: 0, strokeNoScale: !0 }, a.lineStyle) })), Mo(S, { shape: nd(a, d, p), style: { opacity: 1 } }, o), n.add(S); }
  } function id(t, e, i, n, o, a) { for (var r, s = t.tree.getNodeByDataIndex(e), l = t.tree.root, a = td(s, s.getModel(), a), u = s.parentNode === l ? s : s.parentNode || s; (r = u.getLayout()) == null;)u = u.parentNode === l ? u : u.parentNode || u; Mo(i, { position: [r.x + 1, r.y + 1] }, o, () => { n.remove(i), t.setItemGraphicEl(e, null); }), i.fadeOut(null, { keepLabel: !0 }); const h = i.__edge; h && Mo(h, { shape: nd(a, r, r), style: { opacity: 0 } }, o, () => { n.remove(h); }); } function nd(t, e, i) {
    let n; let o; let a; let r; let s; let l; let u; let h; const c = t.orient; if (t.layout === "radial") {
      s = e.rawX, u = e.rawY, l = i.rawX, h = i.rawY; const d = Zc(s, u); const f = Zc(s, u + (h - u) * t.curvature); const p = Zc(l, h + (u - h) * t.curvature); const g = Zc(l, h); return {
        x1: d.x, y1: d.y, x2: g.x, y2: g.y, cpx1: f.x, cpy1: f.y, cpx2: p.x, cpy2: p.y,
      };
    } return s = e.x, u = e.y, l = i.x, h = i.y, c !== "LR" && c !== "RL" || (n = s + (l - s) * t.curvature, o = u, a = l + (s - l) * t.curvature, r = h), c !== "TB" && c !== "BT" || (n = s, o = u + (h - u) * t.curvature, a = l, r = h + (u - h) * t.curvature), {
      x1: s, y1: u, x2: l, y2: h, cpx1: n, cpy1: o, cpx2: a, cpy2: r,
    };
  } function od(t, e, i) { for (var n, o = [t], a = []; n = o.pop();) if (a.push(n), n.isExpand) { const r = n.children; if (r.length) for (let s = 0; s < r.length; s++)o.push(r[s]); } for (;n = a.pop();)e(n, i); } function ad(t, e) { for (var i, n = [t]; i = n.pop();) if (e(i), i.isExpand) { const o = i.children; if (o.length) for (let a = o.length - 1; a >= 0; a--)n.push(o[a]); } } function rd(t, e) {
    const i = Uc(t, e); t.layoutInfo = i; const n = t.get("layout"); let o = 0; let a = 0; let r = null; n === "radial" ? (o = 2 * Math.PI, a = Math.min(i.height, i.width) / 2, r = Hc((t, e) => (t.parentNode === e.parentNode ? 1 : 2) / t.depth)) : (o = i.width, a = i.height, r = Hc()); const s = t.getData().tree.root; const l = s.children[0]; if (l) {
      Gc(s), od(l, Fc, r), s.hierNode.modifier = -l.hierNode.prelim, ad(l, Wc); let u = l; let h = l; let c = l; ad(l, (t) => { const e = t.getLayout().x; e < u.getLayout().x && (u = t), e > h.getLayout().x && (h = t), t.depth > c.depth && (c = t); }); const d = u === h ? 1 : r(u, h) / 2; const f = d - u.getLayout().x; let p = 0; let g = 0; let m = 0; let v = 0; if (n === "radial") {
        p = o / (h.getLayout().x + d + f), g = a / (c.depth - 1 || 1), ad(l, (t) => {
          m = (t.getLayout().x + f) * p, v = (t.depth - 1) * g; const e = Zc(m, v); t.setLayout({
            x: e.x, y: e.y, rawX: m, rawY: v,
          }, !0);
        });
      } else { const y = t.getOrient(); y === "RL" || y === "LR" ? (g = a / (h.getLayout().x + d + f), p = o / (c.depth - 1 || 1), ad(l, (t) => { v = (t.getLayout().x + f) * g, m = y === "LR" ? (t.depth - 1) * p : o - (t.depth - 1) * p, t.setLayout({ x: m, y: v }, !0); })) : y !== "TB" && y !== "BT" || (p = o / (h.getLayout().x + d + f), g = a / (c.depth - 1 || 1), ad(l, (t) => { m = (t.getLayout().x + f) * p, v = y === "TB" ? (t.depth - 1) * g : a - (t.depth - 1) * g, t.setLayout({ x: m, y: v }, !0); })); }
    }
  } function sd(t, e, i) { if (t && l(e, t.type) >= 0) { const n = i.getData().tree.root; let o = t.targetNode; if (typeof o === "string" && (o = n.getNodeById(o)), o && n.contains(o)) return { node: o }; const a = t.targetNodeId; if (a != null && (o = n.getNodeById(a))) return { node: o }; } } function ld(t) { for (var e = []; t;)(t = t.parentNode) && e.push(t); return e.reverse(); } function ud(t, e) { return l(ld(t), e) >= 0; } function hd(t, e) { for (var i = []; t;) { const n = t.dataIndex; i.push({ name: t.name, dataIndex: n, value: e.getRawValue(n) }), t = t.parentNode; } return i.reverse(), i; } function cd(t) { let e = 0; d(t.children, (t) => { cd(t); let i = t.value; y(i) && (i = i[0]), e += i; }); let i = t.value; y(i) && (i = i[0]), (i == null || isNaN(i)) && (i = e), i < 0 && (i = 0), y(t.value) ? t.value[0] = i : t.value = i; } function dd(t, e) { const i = e.get("color"); if (i) { let n; return d(t = t || [], (t) => { const e = new Po(t); const i = e.get("color"); (e.get("itemStyle.color") || i && i !== "none") && (n = !0); }), n || ((t[0] || (t[0] = {})).color = i.slice()), t; } } function fd(t) { this.group = new tb(), t.add(this.group); } function pd(t, e, i, n, o, a) { const r = [[o ? t : t - XC, e], [t + i, e], [t + i, e + n], [o ? t : t - XC, e + n]]; return !a && r.splice(2, 0, [t + i + XC, e + n / 2]), !o && r.push([t, e + n / 2]), r; } function gd(t, e, i) {
    t.eventData = {
      componentType: "series", componentSubType: "treemap", componentIndex: e.componentIndex, seriesIndex: e.componentIndex, seriesName: e.name, seriesType: "treemap", selfType: "breadcrumb", nodeData: { dataIndex: i && i.dataIndex, name: i && i.name }, treePathInfo: i && hd(i, e),
    };
  } function md() {
    let t; const e = []; let i = {}; return {
      add(t, n, o, a, r) {
        return _(a) && (r = a, a = 0), !i[t.id] && (i[t.id] = 1, e.push({
          el: t, target: n, time: o, delay: a, easing: r,
        }), !0);
      },
      done(e) { return t = e, this; },
      start() { for (var n = e.length, o = 0, a = e.length; o < a; o++) { const r = e[o]; r.el.animateTo(r.target, r.time, r.delay, r.easing, () => { --n || (e.length = 0, i = {}, t && t()); }); } return this; },
    };
  } function vd(t, e, n, o, r, s, l, u, h, c) {
    function d(t, e) { w ? !t.invisible && s.push(t) : (e(), t.__tmWillVisible || (t.invisible = !1)); } function f(e, n, o, a, r, s) { const u = l.getModel(); let h = T(t.getFormattedLabel(l.dataIndex, "normal", null, null, s ? "upperLabel" : "label"), u.get("name")); if (!s && v.isLeafRoot) { const c = t.get("drillDownIcon", !0); h = c ? `${c} ${h}` : h; } const d = u.getModel(s ? QC : $C); const f = u.getModel(s ? tL : JC); const p = d.getShallow("show"); po(e, n, d, f, { defaultText: p ? h : null, autoColor: o, isRectText: !0 }), s && (e.textRect = i(s)), e.truncate = p && d.get("ellipsis") ? { outerWidth: a, outerHeight: r, minChar: 2 } : null; } function p(t, i, o, a) { let s = S != null && n[t][S]; const l = r[t]; return s ? (n[t][S] = null, g(l, s, t)) : w || ((s = new i({ z: yd(o, a) })).__tmDepth = o, s.__tmStorageName = t, m(l, s, t)), e[t][b] = s; } function g(t, e, i) { (t[b] = {}).old = i === "nodeGroup" ? e.position.slice() : a({}, e.shape); } function m(t, e, i) {
      const n = t[b] = {}; const a = l.parentNode; if (a && (!o || o.direction === "drillDown")) {
        let s = 0; let u = 0; const h = r.background[a.getRawIndex()]; !o && h && h.old && (s = h.old.width, u = h.old.height), n.old = i === "nodeGroup" ? [0, u] : {
          x: s, y: u, width: 0, height: 0,
        };
      }n.fadein = i !== "nodeGroup";
    } if (l) {
      var v = l.getLayout(); if (v && v.isInView) {
        const y = v.width; const x = v.height; const _ = v.borderWidth; var w = v.invisible; var b = l.getRawIndex(); var S = u && u.getRawIndex(); const M = l.viewChildren; const I = v.upperHeight; const A = M && M.length; const D = l.getModel("itemStyle"); const C = l.getModel("emphasis.itemStyle"); const L = p("nodeGroup", YC); if (L) {
          if (h.add(L), L.attr("position", [v.x || 0, v.y || 0]), L.__tmNodeWidth = y, L.__tmNodeHeight = x, v.isAboveViewRoot) return L; const k = p("background", qC, c, iL); if (k && (function (e, i, n) {
            i.dataIndex = l.dataIndex, i.seriesIndex = t.seriesIndex, i.setShape({
              x: 0, y: 0, width: y, height: x,
            }); const o = l.getVisual("borderColor", !0); const a = C.get("borderColor"); d(i, () => {
              const t = aL(D); t.fill = o; const e = oL(C); if (e.fill = a, n) {
                const r = y - 2 * _; f(t, e, o, r, I, {
                  x: _, y: 0, width: r, height: I,
                });
              } else t.text = e.text = null; i.setStyle(t), co(i, e);
            }), e.add(i);
          }(L, k, A && v.upperHeight)), !A) {
            const P = p("content", qC, c, nL); P && (function (e, i) {
              i.dataIndex = l.dataIndex, i.seriesIndex = t.seriesIndex; const n = Math.max(y - 2 * _, 0); const o = Math.max(x - 2 * _, 0); i.culling = !0, i.setShape({
                x: _, y: _, width: n, height: o,
              }); const a = l.getVisual("color", !0); d(i, () => { const t = aL(D); t.fill = a; const e = oL(C); f(t, e, a, n, o), i.setStyle(t), co(i, e); }), e.add(i);
            }(L, P));
          } return L;
        }
      }
    }
  } function yd(t, e) { const i = t * eL + e; return (i - 1) / i; } function xd(t) { const e = t.pieceList; t.hasSpecialVisual = !1, d(e, (e, i) => { e.originIndex = i, e.visual != null && (t.hasSpecialVisual = !0); }); } function _d(t) { const e = t.categories; let i = t.visual; const n = t.categoryMap = {}; if (lL(e, (t, e) => { n[t] = e; }), !y(i)) { const o = []; w(i) ? lL(i, (t, e) => { const i = n[e]; o[i != null ? i : hL] = t; }) : o[hL] = i, i = Cd(t, o); } for (let a = e.length - 1; a >= 0; a--)i[a] == null && (delete n[e[a]], e.pop()); } function wd(t, e) { const i = t.visual; const n = []; w(i) ? lL(i, (t) => { n.push(t); }) : i != null && n.push(i); const o = { color: 1, symbol: 1 }; e || n.length !== 1 || o.hasOwnProperty(t.type) || (n[1] = n[0]), Cd(t, n); } function bd(t) { return { applyVisual(e, i, n) { e = this.mapValueToVisual(e), n("color", t(i("color"), e)); }, _doMap: Ad([0, 1]) }; } function Sd(t) { const e = this.option.visual; return e[Math.round(zo(t, [0, 1], [0, e.length - 1], !0))] || {}; } function Md(t) { return function (e, i, n) { n(t, this.mapValueToVisual(e)); }; } function Id(t) { const e = this.option.visual; return e[this.option.loop && t !== hL ? t % e.length : t]; } function Td() { return this.option.visual[0]; } function Ad(t) {
    return {
      linear(e) { return zo(e, t, this.option.visual, !0); }, category: Id, piecewise(e, i) { let n = Dd.call(this, i); return n == null && (n = zo(e, t, this.option.visual, !0)), n; }, fixed: Td,
    };
  } function Dd(t) { const e = this.option; const i = e.pieceList; if (e.hasSpecialVisual) { const n = i[cL.findPieceIndex(t, i)]; if (n && n.visual) return n.visual[this.type]; } } function Cd(t, e) { return t.visual = e, t.type === "color" && (t.parsedVisual = f(e, t => Gt(t))), e; } function Ld(t, e, i) { return t ? e <= i : e < i; } function kd(t, e, i, n, o, a) { const r = t.getModel(); const s = t.getLayout(); if (s && !s.invisible && s.isInView) { let l; const u = t.getModel(gL); const h = Pd(u, e, i[t.depth], n); let c = u.get("borderColor"); const f = u.get("borderColorSaturation"); f != null && (c = Od(f, l = Nd(h))), t.setVisual("borderColor", c); const p = t.viewChildren; if (p && p.length) { const g = Rd(t, r, s, u, h, p); d(p, (t, e) => { (t.depth >= o.length || t === o[t.depth]) && kd(t, Bd(r, h, t, e, g, a), i, n, o, a); }); } else l = Nd(h), t.setVisual("color", l); } } function Pd(t, e, i, n) { const o = a({}, e); return d(["color", "colorAlpha", "colorSaturation"], (a) => { let r = t.get(a, !0); r == null && i && (r = i[a]), r == null && (r = e[a]), r == null && (r = n.get(a)), r != null && (o[a] = r); }), o; } function Nd(t) { let e = Ed(t, "color"); if (e) { const i = Ed(t, "colorAlpha"); const n = Ed(t, "colorSaturation"); return n && (e = jt(e, null, null, n)), i && (e = Yt(e, i)), e; } } function Od(t, e) { return e != null ? jt(e, null, null, t) : null; } function Ed(t, e) { const i = t[e]; if (i != null && i !== "none") return i; } function Rd(t, e, i, n, o, a) { if (a && a.length) { const r = zd(e, "color") || o.color != null && o.color !== "none" && (zd(e, "colorAlpha") || zd(e, "colorSaturation")); if (r) { const s = e.get("visualMin"); const l = e.get("visualMax"); const u = i.dataExtent.slice(); s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l); const h = e.get("colorMappingBy"); const c = { type: r.name, dataExtent: u, visual: r.range }; c.type !== "color" || h !== "index" && h !== "id" ? c.mappingMethod = "linear" : (c.mappingMethod = "category", c.loop = !0); const d = new cL(c); return d.__drColorMappingBy = h, d; } } } function zd(t, e) { const i = t.get(e); return pL(i) && i.length ? { name: e, range: i } : null; } function Bd(t, e, i, n, o, r) { const s = a({}, e); if (o) { const l = o.type; const u = l === "color" && o.__drColorMappingBy; const h = u === "index" ? n : u === "id" ? r.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension")); s[l] = o.mapValueToVisual(h); } return s; } function Vd(t, e, i, n) {
    let o; let a; if (!t.isRemoved()) {
      const r = t.getLayout(); o = r.width, a = r.height; const s = (f = t.getModel()).get(wL); const l = f.get(bL) / 2; const u = qd(f); const h = Math.max(s, u); const c = s - l; const d = h - l; var f = t.getModel(); t.setLayout({ borderWidth: s, upperHeight: h, upperLabelHeight: u }, !0); const p = (o = vL(o - 2 * c, 0)) * (a = vL(a - c - d, 0)); const g = Gd(t, f, p, e, i, n); if (g.length) {
        const m = {
          x: c, y: d, width: o, height: a,
        }; let v = yL(o, a); let y = 1 / 0; const x = []; x.area = 0; for (var _ = 0, w = g.length; _ < w;) { const b = g[_]; x.push(b), x.area += b.getLayout().area; const S = Zd(x, v, e.squareRatio); S <= y ? (_++, y = S) : (x.area -= x.pop().getLayout().area, Ud(x, v, m, l, !1), v = yL(m.width, m.height), x.length = x.area = 0, y = 1 / 0); } if (x.length && Ud(x, v, m, l, !0), !i) { const M = f.get("childrenVisibleMin"); M != null && p < M && (i = !0); } for (var _ = 0, w = g.length; _ < w; _++)Vd(g[_], e, i, n + 1);
      }
    }
  } function Gd(t, e, i, n, o, a) { let r = t.children || []; let s = n.sort; s !== "asc" && s !== "desc" && (s = null); const l = n.leafDepth != null && n.leafDepth <= a; if (o && !l) return t.viewChildren = []; Wd(r = g(r, t => !t.isRemoved()), s); const u = Hd(e, r, s); if (u.sum === 0) return t.viewChildren = []; if (u.sum = Fd(e, i, u.sum, s, r), u.sum === 0) return t.viewChildren = []; for (let h = 0, c = r.length; h < c; h++) { const d = r[h].getValue() / u.sum * i; r[h].setLayout({ area: d }); } return l && (r.length && t.setLayout({ isLeafRoot: !0 }, !0), r.length = 0), t.viewChildren = r, t.setLayout({ dataExtent: u.dataExtent }, !0), r; } function Fd(t, e, i, n, o) { if (!n) return i; for (var a = t.get("visibleMin"), r = o.length, s = r, l = r - 1; l >= 0; l--) { const u = o[n === "asc" ? r - l - 1 : l].getValue(); u / i * e < a && (s = l, i -= u); } return n === "asc" ? o.splice(0, r - s) : o.splice(s, r - s), i; } function Wd(t, e) { return e && t.sort((t, i) => { const n = e === "asc" ? t.getValue() - i.getValue() : i.getValue() - t.getValue(); return n === 0 ? e === "asc" ? t.dataIndex - i.dataIndex : i.dataIndex - t.dataIndex : n; }), t; } function Hd(t, e, i) { for (var n = 0, o = 0, a = e.length; o < a; o++)n += e[o].getValue(); const r = t.get("visualDimension"); if (e && e.length) if (r === "value" && i)s = [e[e.length - 1].getValue(), e[0].getValue()], i === "asc" && s.reverse(); else { var s = [1 / 0, -1 / 0]; _L(e, (t) => { const e = t.getValue(r); e < s[0] && (s[0] = e), e > s[1] && (s[1] = e); }); } else s = [NaN, NaN]; return { sum: n, dataExtent: s }; } function Zd(t, e, i) { for (var n, o = 0, a = 1 / 0, r = 0, s = t.length; r < s; r++)(n = t[r].getLayout().area) && (n < a && (a = n), n > o && (o = n)); const l = t.area * t.area; const u = e * e * i; return l ? vL(u * o / l, l / (u * a)) : 1 / 0; } function Ud(t, e, i, n, o) { const a = e === i.width ? 0 : 1; const r = 1 - a; const s = ["x", "y"]; const l = ["width", "height"]; let u = i[s[a]]; let h = e ? t.area / e : 0; (o || h > i[l[r]]) && (h = i[l[r]]); for (let c = 0, d = t.length; c < d; c++) { const f = t[c]; const p = {}; const g = h ? f.getLayout().area / h : 0; const m = p[l[r]] = vL(h - 2 * n, 0); const v = i[s[a]] + i[l[a]] - u; const y = c === d - 1 || v < g ? v : g; const x = p[l[a]] = vL(y - 2 * n, 0); p[s[r]] = i[s[r]] + yL(n, m / 2), p[s[a]] = u + yL(n, x / 2), u += y, f.setLayout(p, !0); }i[s[r]] += h, i[l[r]] -= h; } function Xd(t, e, i, n, o) { let a = (e || {}).node; const r = [n, o]; if (!a || a === i) return r; for (var s, l = n * o, u = l * t.option.zoomToNodeRatio; s = a.parentNode;) { for (var h = 0, c = s.children, d = 0, f = c.length; d < f; d++)h += c[d].getValue(); const p = a.getValue(); if (p === 0) return r; u *= h / p; const g = s.getModel(); const m = g.get(wL); (u += 4 * m * m + (3 * m + Math.max(m, qd(g))) * Math.pow(u, 0.5)) > XM && (u = XM), a = s; }u < l && (u = l); const v = Math.pow(u / l, 0.5); return [n * v, o * v]; } function jd(t, e, i) { if (e) return { x: e.x, y: e.y }; const n = { x: 0, y: 0 }; if (!i) return n; const o = i.node; const a = o.getLayout(); if (!a) return n; for (var r = [a.width / 2, a.height / 2], s = o; s;) { const l = s.getLayout(); r[0] += l.x, r[1] += l.y, s = s.parentNode; } return { x: t.width / 2 - r[0], y: t.height / 2 - r[1] }; } function Yd(t, e, i, n, o) { const a = t.getLayout(); const r = i[o]; const s = r && r === t; if (!(r && !s || o === i.length && t !== n)) { t.setLayout({ isInView: !0, invisible: !s && !e.intersect(a), isAboveViewRoot: s }, !0); const l = new de(e.x - a.x, e.y - a.y, e.width, e.height); _L(t.viewChildren || [], (t) => { Yd(t, l, i, n, o + 1); }); } } function qd(t) { return t.get(SL) ? t.get(ML) : 0; } function Kd(t) { return `_EC_${t}`; } function $d(t, e) { this.id = t == null ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = e == null ? -1 : e; } function Jd(t, e, i) { this.node1 = t, this.node2 = e, this.dataIndex = i == null ? -1 : i; } function Qd(t) { return isNaN(+t.cpx1) || isNaN(+t.cpy1); } function tf(t) { return `_${t}Type`; } function ef(t, e, i) { const n = e.getItemVisual(i, "color"); const o = e.getItemVisual(i, t); let a = e.getItemVisual(i, `${t}Size`); if (o && o !== "none") { y(a) || (a = [a, a]); const r = $l(o, -a[0] / 2, -a[1] / 2, a[0], a[1], n); return r.name = t, r; } } function nf(t) { const e = new NL({ name: "line" }); return of(e.shape, t), e; } function of(t, e) { const i = e[0]; const n = e[1]; const o = e[2]; t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, o ? (t.cpx1 = o[0], t.cpy1 = o[1]) : (t.cpx1 = NaN, t.cpy1 = NaN); } function af(t, e, i) { tb.call(this), this._createLine(t, e, i); } function rf(t) { this._ctor = t || af, this.group = new tb(); } function sf(t, e, i, n) { if (cf(e.getItemLayout(i))) { const o = new t._ctor(e, i, n); e.setItemGraphicEl(i, o), t.group.add(o); } } function lf(t, e, i, n, o, a) { let r = e.getItemGraphicEl(n); cf(i.getItemLayout(o)) ? (r ? r.updateData(i, o, a) : r = new t._ctor(i, o, a), i.setItemGraphicEl(o, r), t.group.add(r)) : t.group.remove(r); } function uf(t) {
    const e = t.hostModel; return {
      lineStyle: e.getModel("lineStyle").getLineStyle(), hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label"),
    };
  } function hf(t) { return isNaN(t[0]) || isNaN(t[1]); } function cf(t) { return !hf(t[0]) && !hf(t[1]); } function df(t, e, i) { for (var n, o = t[0], a = t[1], r = t[2], s = 1 / 0, l = i * i, u = 0.1, h = 0.1; h <= 0.9; h += 0.1)zL[0] = GL(o[0], a[0], r[0], h), zL[1] = GL(o[1], a[1], r[1], h), (f = WL(FL(zL, e) - l)) < s && (s = f, n = h); for (let c = 0; c < 32; c++) { const d = n + u; BL[0] = GL(o[0], a[0], r[0], n), BL[1] = GL(o[1], a[1], r[1], n), VL[0] = GL(o[0], a[0], r[0], d), VL[1] = GL(o[1], a[1], r[1], d); var f = FL(BL, e) - l; if (WL(f) < 0.01) break; const p = FL(VL, e) - l; u /= 2, f < 0 ? p >= 0 ? n += u : n -= u : p >= 0 ? n -= u : n += u; } return n; } function ff(t, e) { return t.getVisual("opacity") || t.getModel().get(e); } function pf(t, e, i) { const n = t.getGraphicEl(); let o = ff(t, e); i != null && (o == null && (o = 1), o *= i), n.downplay && n.downplay(), n.traverse((t) => { if (t.type !== "group") { let e = t.lineLabelOriginalOpacity; e != null && i == null || (e = o), t.setStyle("opacity", e); } }); } function gf(t, e) { const i = ff(t, e); const n = t.getGraphicEl(); n.highlight && n.highlight(), n.traverse((t) => { t.type !== "group" && t.setStyle("opacity", i); }); } function mf(t) { return t instanceof Array || (t = [t, t]), t; } function vf(t) { const e = t.coordinateSystem; if (!e || e.type === "view") { const i = t.getGraph(); i.eachNode((t) => { const e = t.getModel(); t.setLayout([+e.get("x"), +e.get("y")]); }), yf(i); } } function yf(t) { t.eachEdge((t) => { const e = t.getModel().get("lineStyle.curveness") || 0; const i = F(t.node1.getLayout()); const n = F(t.node2.getLayout()); const o = [i, n]; +e && o.push([(i[0] + n[0]) / 2 - (i[1] - n[1]) * e, (i[1] + n[1]) / 2 - (n[0] - i[0]) * e]), t.setLayout(o); }); } function xf(t) { const e = t.coordinateSystem; if (!e || e.type === "view") { const i = e.getBoundingRect(); const n = t.getData(); const o = n.graph; let a = 0; const r = n.getSum("value"); const s = 2 * Math.PI / (r || n.count()); const l = i.width / 2 + i.x; const u = i.height / 2 + i.y; const h = Math.min(i.width, i.height) / 2; o.eachNode((t) => { const e = t.getValue("value"); a += s * (r ? e : 1) / 2, t.setLayout([h * Math.cos(a) + l, h * Math.sin(a) + u]), a += s * (r ? e : 1) / 2; }), n.setLayout({ cx: l, cy: u }), o.eachEdge((t) => { let e; let i = t.getModel().get("lineStyle.curveness") || 0; const n = F(t.node1.getLayout()); const o = F(t.node2.getLayout()); const a = (n[0] + o[0]) / 2; const r = (n[1] + o[1]) / 2; +i && (e = [l * (i *= 3) + a * (1 - i), u * i + r * (1 - i)]), t.setLayout([n, o, e]); }); } } function _f(t, e, i) {
    for (var n = i.rect, o = n.width, a = n.height, r = [n.x + o / 2, n.y + a / 2], s = i.gravity == null ? 0.1 : i.gravity, l = 0; l < t.length; l++) { const u = t[l]; u.p || (u.p = V(o * (Math.random() - 0.5) + r[0], a * (Math.random() - 0.5) + r[1])), u.pp = F(u.p), u.edges = null; } let h = 0.6; return {
      warmUp() { h = 0.5; }, setFixed(e) { t[e].fixed = !0; }, setUnfixed(e) { t[e].fixed = !1; }, step(i) { for (var n = [], o = t.length, a = 0; a < e.length; a++) { const l = e[a]; var u = l.n1; U(n, (p = l.n2).p, u.p); var c = X(n) - l.d; let d = p.w / (u.w + p.w); isNaN(d) && (d = 0), q(n, n), !u.fixed && jL(u.p, u.p, n, d * c * h), !p.fixed && jL(p.p, p.p, n, -(1 - d) * c * h); } for (a = 0; a < o; a++)(v = t[a]).fixed || (U(n, r, v.p), jL(v.p, v.p, n, s * h)); for (a = 0; a < o; a++) for (var u = t[a], f = a + 1; f < o; f++) { var p = t[f]; U(n, p.p, u.p), (c = X(n)) === 0 && (W(n, Math.random() - 0.5, Math.random() - 0.5), c = 1); const g = (u.rep + p.rep) / c / c; !u.fixed && jL(u.pp, u.pp, n, g), !p.fixed && jL(p.pp, p.pp, n, -g); } for (var m = [], a = 0; a < o; a++) { var v = t[a]; v.fixed || (U(m, v.p, v.pp), jL(v.p, v.p, m, h), G(v.pp, v.p)); }h *= 0.992, i && i(t, e, h < 0.01); },
    };
  } function wf(t, e, i) { const n = t.getBoxLayoutParams(); return n.aspect = i, ha(n, { width: e.getWidth(), height: e.getHeight() }); } function bf(t, e) { const i = t.get("center"); const n = e.getWidth(); const o = e.getHeight(); const a = Math.min(n, o); return { cx: Bo(i[0], e.getWidth()), cy: Bo(i[1], e.getHeight()), r: Bo(t.get("radius"), a / 2) }; } function Sf(t, e) { return e && (typeof e === "string" ? t = e.replace("{value}", t != null ? t : "") : typeof e === "function" && (t = e(t))), t; } function Mf(t, e) {
    function i() { a.ignore = a.hoverIgnore, r.ignore = r.hoverIgnore; } function n() { a.ignore = a.normalIgnore, r.ignore = r.normalIgnore; }tb.call(this); const o = new pM(); var a = new gM(); var
      r = new rM(); this.add(o), this.add(a), this.add(r), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n);
  } function If(t, e) { return ha(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }); } function Tf(t, e) { for (var i = t.mapDimension("value"), n = t.mapArray(i, t => t), o = [], a = e === "ascending", r = 0, s = t.count(); r < s; r++)o[r] = r; return typeof e === "function" ? o.sort(e) : e !== "none" && o.sort((t, e) => (a ? n[t] - n[e] : n[e] - n[t])), o; } function Af(t) {
    t.each((e) => {
      let i; let n; let o; let a; const r = t.getItemModel(e); const s = r.getModel("label").get("position"); const l = r.getModel("labelLine"); const u = t.getItemLayout(e); const h = u.points; const c = s === "inner" || s === "inside" || s === "center"; if (c)i = "center", a = [[n = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4, o = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4], [n, o]]; else { let d; let f; let p; const g = l.get("length"); s === "left" ? (d = (h[3][0] + h[0][0]) / 2, f = (h[3][1] + h[0][1]) / 2, n = (p = d - g) - 5, i = "right") : (d = (h[1][0] + h[2][0]) / 2, f = (h[1][1] + h[2][1]) / 2, n = (p = d + g) + 5, i = "left"); const m = f; a = [[d, f], [p, m]], o = m; }u.label = {
        linePoints: a, x: n, y: o, verticalAlign: "middle", textAlign: i, inside: c,
      };
    });
  } function Df(t) { if (!t.parallel) { let e = !1; d(t.series, (t) => { t && t.type === "parallel" && (e = !0); }), e && (t.parallel = [{}]); } } function Cf(t) { d(Di(t.parallelAxis), (e) => { if (w(e)) { const i = e.parallelIndex || 0; const o = Di(t.parallel)[i]; o && o.parallelAxisDefault && n(e, o.parallelAxisDefault, !1); } }); } function Lf(t, e) { const i = t[e] - t[1 - e]; return { span: Math.abs(i), sign: i > 0 ? -1 : i < 0 ? 1 : e ? -1 : 1 }; } function kf(t, e) { return Math.min(e[1], Math.max(e[0], t)); } function Pf(t, e, i) { this._axesMap = R(), this._axesLayout = {}, this.dimensions = t.dimensions, this._rect, this._model = t, this._init(t, e, i); } function Nf(t, e) { return ik(nk(t, e[0]), e[1]); } function Of(t, e) { const i = e.layoutLength / (e.axisCount - 1); return { position: i * t, axisNameAvailableWidth: i, axisLabelShow: !0 }; } function Ef(t, e) {
    let i; let n; const o = e.layoutLength; const a = e.axisExpandWidth; const r = e.axisCount; const s = e.axisCollapseWidth; const l = e.winInnerIndices; let u = s; let h = !1; return t < l[0] ? (i = t * s, n = s) : t <= l[1] ? (i = e.axisExpandWindow0Pos + t * a - e.axisExpandWindow[0], u = a, h = !0) : (i = o - (r - 1 - t) * s, n = s), {
      position: i, axisNameAvailableWidth: u, axisLabelShow: h, nameTruncateMaxWidth: n,
    };
  } function Rf(t) { fw.call(this), this._zr = t, this.group = new tb(), this._brushType, this._brushOption, this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, this._creatingPanel, this._enableGlobalPan, this._uid = `brushController_${Sk++}`, this._handlers = {}, ck(Mk, function (t, e) { this._handlers[e] = m(t, this); }, this); } function zf(t, e) { const o = t._zr; t._enableGlobalPan || Qh(o, xk, t._uid), ck(t._handlers, (t, e) => { o.on(e, t); }), t._brushType = e.brushType, t._brushOption = n(i(bk), e, !0); } function Bf(t) { const e = t._zr; tc(e, xk, t._uid), ck(t._handlers, (t, i) => { e.off(i, t); }), t._brushType = t._brushOption = null; } function Vf(t, e) { const i = Ik[e.brushType].createCover(t, e); return i.__brushOption = e, Wf(i, e), t.group.add(i), i; } function Gf(t, e) { const i = Zf(e); return i.endCreating && (i.endCreating(t, e), Wf(e, e.__brushOption)), e; } function Ff(t, e) { const i = e.__brushOption; Zf(e).updateCoverShape(t, e, i.range, i); } function Wf(t, e) { let i = e.z; i == null && (i = mk), t.traverse((t) => { t.z = i, t.z2 = i; }); } function Hf(t, e) { Zf(e).updateCommon(t, e), Ff(t, e); } function Zf(t) { return Ik[t.__brushOption.brushType]; } function Uf(t, e, i) { const n = t._panels; if (!n) return !0; let o; const a = t._transform; return ck(n, (t) => { t.isTargetByCursor(e, i, a) && (o = t); }), o; } function Xf(t, e) { const i = t._panels; if (!i) return !0; const n = e.__brushOption.panelId; return n == null || i[n]; } function jf(t) { const e = t._covers; const i = e.length; return ck(e, (e) => { t.group.remove(e); }, t), e.length = 0, !!i; } function Yf(t, e) { const n = dk(t._covers, (t) => { const e = t.__brushOption; const n = i(e.range); return { brushType: e.brushType, panelId: e.panelId, range: n }; }); t.trigger("brush", n, { isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick }); } function qf(t) { const e = t._track; if (!e.length) return !1; const i = e[e.length - 1]; const n = e[0]; const o = i[0] - n[0]; const a = i[1] - n[1]; return gk(o * o + a * a, 0.5) > vk; } function Kf(t) { let e = t.length - 1; return e < 0 && (e = 0), [t[0], t[e]]; } function $f(t, e, i, n) {
    const o = new tb(); return o.add(new yM({
      name: "main", style: ep(i), silent: !0, draggable: !0, cursor: "move", drift: hk(t, e, o, "nswe"), ondragend: hk(Yf, e, { isEnd: !0 }),
    })), ck(n, (i) => {
      o.add(new yM({
        name: i, style: { opacity: 0 }, draggable: !0, silent: !0, invisible: !0, drift: hk(t, e, o, i), ondragend: hk(Yf, e, { isEnd: !0 }),
      }));
    }), o;
  } function Jf(t, e, i, n) { const o = n.brushStyle.lineWidth || 0; const a = pk(o, yk); const r = i[0][0]; const s = i[1][0]; const l = r - o / 2; const u = s - o / 2; const h = i[0][1]; const c = i[1][1]; const d = h - a + o / 2; const f = c - a + o / 2; const p = h - r; const g = c - s; const m = p + o; const v = g + o; tp(t, e, "main", r, s, p, g), n.transformable && (tp(t, e, "w", l, u, a, v), tp(t, e, "e", d, u, a, v), tp(t, e, "n", l, u, m, a), tp(t, e, "s", l, f, m, a), tp(t, e, "nw", l, u, a, a), tp(t, e, "ne", d, u, a, a), tp(t, e, "sw", l, f, a, a), tp(t, e, "se", d, f, a, a)); } function Qf(t, e) { const i = e.__brushOption; const n = i.transformable; const o = e.childAt(0); o.useStyle(ep(i)), o.attr({ silent: !n, cursor: n ? "move" : "default" }), ck(["w", "e", "n", "s", "se", "sw", "ne", "nw"], (i) => { const o = e.childOfName(i); const a = op(t, i); o && o.attr({ silent: !n, invisible: !n, cursor: n ? `${wk[a]}-resize` : null }); }); } function tp(t, e, i, n, o, a, r) { const s = e.childOfName(i); s && s.setShape(up(lp(t, e, [[n, o], [n + a, o + r]]))); } function ep(t) { return r({ strokeNoScale: !0 }, t.brushStyle); } function ip(t, e, i, n) { const o = [fk(t, i), fk(e, n)]; const a = [pk(t, i), pk(e, n)]; return [[o[0], a[0]], [o[1], a[1]]]; } function np(t) { return To(t.group); } function op(t, e) {
    if (e.length > 1) return ((n = [op(t, (e = e.split(""))[0]), op(t, e[1])])[0] === "e" || n[0] === "w") && n.reverse(), n.join(""); const i = {
      left: "w", right: "e", top: "n", bottom: "s",
    }; var n = Do({
      w: "left", e: "right", n: "top", s: "bottom",
    }[e], np(t)); return i[n];
  } function ap(t, e, i, n, o, a, r, s) { const l = n.__brushOption; const u = t(l.range); const h = sp(i, a, r); ck(o.split(""), (t) => { const e = _k[t]; u[e[0]][e[1]] += h[e[0]]; }), l.range = e(ip(u[0][0], u[1][0], u[0][1], u[1][1])), Hf(i, n), Yf(i, { isEnd: !1 }); } function rp(t, e, i, n, o) { const a = e.__brushOption.range; const r = sp(t, i, n); ck(a, (t) => { t[0] += r[0], t[1] += r[1]; }), Hf(t, e), Yf(t, { isEnd: !1 }); } function sp(t, e, i) { const n = t.group; const o = n.transformCoordToLocal(e, i); const a = n.transformCoordToLocal(0, 0); return [o[0] - a[0], o[1] - a[1]]; } function lp(t, e, n) { const o = Xf(t, e); return o && !0 !== o ? o.clipPath(n, t._transform) : i(n); } function up(t) {
    const e = fk(t[0][0], t[1][0]); const i = fk(t[0][1], t[1][1]); return {
      x: e, y: i, width: pk(t[0][0], t[1][0]) - e, height: pk(t[0][1], t[1][1]) - i,
    };
  } function hp(t, e, i) { if (t._brushType) { const n = t._zr; const o = t._covers; const a = Uf(t, e, i); if (!t._dragging) for (let r = 0; r < o.length; r++) { const s = o[r].__brushOption; if (a && (!0 === a || s.panelId === a.panelId) && Ik[s.brushType].contain(o[r], i[0], i[1])) return; }a && n.setCursorStyle("crosshair"); } } function cp(t) { const e = t.event; e.preventDefault && e.preventDefault(); } function dp(t, e, i) { return t.childOfName("main").contain(e, i); } function fp(t, e, n, o) { let a; let r = t._creatingCover; const s = t._creatingPanel; const l = t._brushOption; if (t._track.push(n.slice()), qf(t) || r) { if (s && !r) { l.brushMode === "single" && jf(t); const u = i(l); u.brushType = pp(u.brushType, s), u.panelId = !0 === s ? null : s.panelId, r = t._creatingCover = Vf(t, u), t._covers.push(r); } if (r) { const h = Ik[pp(t._brushType, s)]; r.__brushOption.range = h.getCreatingRange(lp(t, r, t._track)), o && (Gf(t, r), h.updateCommon(t, r)), Ff(t, r), a = { isEnd: o }; } } else o && l.brushMode === "single" && l.removeOnClick && Uf(t, e, n) && jf(t) && (a = { isEnd: o, removeOnClick: !0 }); return a; } function pp(t, e) { return t === "auto" ? e.defaultBrushType : t; } function gp(t) { if (this._dragging) { cp(t); const e = fp(this, t, this.group.transformCoordToLocal(t.offsetX, t.offsetY), !0); this._dragging = !1, this._track = [], this._creatingCover = null, e && Yf(this, e); } } function mp(t) {
    return {
      createCover(e, i) { return $f(hk(ap, (e) => { const i = [e, [0, 100]]; return t && i.reverse(), i; }, e => e[t]), e, i, [["w", "e"], ["n", "s"]][t]); }, getCreatingRange(e) { const i = Kf(e); return [fk(i[0][t], i[1][t]), pk(i[0][t], i[1][t])]; }, updateCoverShape(e, i, n, o) { let a; const r = Xf(e, i); if (!0 !== r && r.getLinearBrushOtherExtent)a = r.getLinearBrushOtherExtent(t, e._transform); else { const s = e._zr; a = [0, [s.getWidth(), s.getHeight()][1 - t]]; } const l = [n, a]; t && l.reverse(), Jf(e, i, l, o); }, updateCommon: Qf, contain: dp,
    };
  } function vp(t) { return t = _p(t), function (e, i) { return Lo(e, t); }; } function yp(t, e) { return t = _p(t), function (i) { const n = e != null ? e : i; const o = n ? t.width : t.height; const a = n ? t.x : t.y; return [a, a + (o || 0)]; }; } function xp(t, e, i) { return t = _p(t), function (n, o, a) { return t.contain(o[0], o[1]) && !pc(n, e, i); }; } function _p(t) { return de.create(t); } function wp(t, e, i) { return i && i.type === "axisAreaSelect" && e.findComponents({ mainType: "parallelAxis", query: i })[0] === t; } function bp(t) { const e = t.axis; return f(t.activeIntervals, t => ({ brushType: "lineX", panelId: "pl", range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)] })); } function Sp(t, e) { return e.getComponent("parallel", t.get("parallelIndex")); } function Mp(t, e) { const i = t._model; return i.get("axisExpandable") && i.get("axisExpandTriggerOn") === e; } function Ip(t, e) { if (!t.encodeDefine) { const i = e.ecModel.getComponent("parallel", e.get("parallelIndex")); if (i) { const n = t.encodeDefine = R(); d(i.dimensions, (t) => { const e = Tp(t); n.set(t, e); }); } } } function Tp(t) { return +t.replace("dim", ""); } function Ap(t, e, i) {
    const n = t.model; const o = t.getRect(); const a = new yM({
      shape: {
        x: o.x, y: o.y, width: o.width, height: o.height,
      },
    }); const r = n.get("layout") === "horizontal" ? "width" : "height"; return a.setShape(r, 0), Io(a, { shape: { width: o.width, height: o.height } }, e, i), a;
  } function Dp(t, e, i, n) { for (var o = [], a = 0; a < i.length; a++) { const r = i[a]; const s = t.get(t.mapDimension(r), e); Pp(s, n.getAxis(r).type) || o.push(n.dataToPoint(s, r)); } return o; } function Cp(t, e, i, n, o) { const a = Dp(t, i, n, o); const r = new gM({ shape: { points: a }, silent: !0, z2: 10 }); return e.add(r), t.setItemGraphicEl(i, r), r; } function Lp(t) { let e = t.get("smooth", !0); return !0 === e && (e = Ck), { lineStyle: t.getModel("lineStyle").getLineStyle(), smooth: e != null ? e : Ck }; } function kp(t, e, i, n) { let o = n.lineStyle; e.hasItemOption && (o = e.getItemModel(i).getModel("lineStyle").getLineStyle()), t.useStyle(o); const a = t.style; a.fill = null, a.stroke = e.getItemVisual(i, "color"), a.opacity = e.getItemVisual(i, "opacity"), n.smooth && (t.shape.smooth = n.smooth); } function Pp(t, e) { return e === "category" ? t == null : t == null || isNaN(t); } function Np(t, e) { return t.getVisual("opacity") || t.getModel().get(e); } function Op(t, e, i) { const n = t.getGraphicEl(); let o = Np(t, e); i != null && (o == null && (o = 1), o *= i), n.downplay && n.downplay(), n.traverse((t) => { t.type !== "group" && t.setStyle("opacity", o); }); } function Ep(t, e) { const i = Np(t, e); const n = t.getGraphicEl(); n.highlight && n.highlight(), n.traverse((t) => { t.type !== "group" && t.setStyle("opacity", i); }); } function Rp(t, e, i) {
    const n = new yM({
      shape: {
        x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20,
      },
    }); return Io(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n;
  } function zp() { function t(e, n) { if (n >= i.length) return e; for (var o = -1, a = e.length, r = i[n++], s = {}, l = {}; ++o < a;) { const u = r(e[o]); const h = l[u]; h ? h.push(e[o]) : l[u] = [e[o]]; } return d(l, (e, i) => { s[i] = t(e, n); }), s; } function e(t, o) { if (o >= i.length) return t; const a = []; const r = n[o++]; return d(t, (t, i) => { a.push({ key: i, values: e(t, o) }); }), r ? a.sort((t, e) => r(t.key, e.key)) : a; } var i = []; var n = []; return { key(t) { return i.push(t), this; }, sortKeys(t) { return n[i.length - 1] = t, this; }, entries(i) { return e(t(i, 0), 0); } }; } function Bp(t, e) { return ha(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }); } function Vp(t, e, i, n, o, a, r, s) { Fp(t, e, i, o, a, s), Zp(t, e, a, o, n, r, s), eg(t, s); } function Gp(t) { d(t, (t) => { const e = Qp(t.outEdges, Jp); const i = Qp(t.inEdges, Jp); const n = Math.max(e, i); t.setLayout({ value: n }, !0); }); } function Fp(t, e, i, n, o, a) { for (var r = [], s = [], l = [], u = [], h = 0, c = 0; c < e.length; c++)r[c] = 1; for (c = 0; c < t.length; c++)s[c] = t[c].inEdges.length, s[c] === 0 && l.push(t[c]); for (;l.length;) { for (let d = 0; d < l.length; d++) { const f = l[d]; a === "vertical" ? (f.setLayout({ y: h }, !0), f.setLayout({ dy: i }, !0)) : (f.setLayout({ x: h }, !0), f.setLayout({ dx: i }, !0)); for (let p = 0; p < f.outEdges.length; p++) { const g = f.outEdges[p]; r[e.indexOf(g)] = 0; const m = g.node2; --s[t.indexOf(m)] == 0 && u.push(m); } }++h, l = u, u = []; } for (c = 0; c < r.length; c++);Wp(t, h, a), Hp(t, a === "vertical" ? (o - i) / (h - 1) : (n - i) / (h - 1), a); } function Wp(t, e, i) { d(t, (t) => { t.outEdges.length || (i === "vertical" ? t.setLayout({ y: e - 1 }, !0) : t.setLayout({ x: e - 1 }, !0)); }); } function Hp(t, e, i) { d(t, (t) => { if (i === "vertical") { const n = t.getLayout().y * e; t.setLayout({ y: n }, !0); } else { const o = t.getLayout().x * e; t.setLayout({ x: o }, !0); } }); } function Zp(t, e, i, n, o, a, r) {
    const s = zp().key(Up(r)).sortKeys((t, e) => t - e).entries(t)
      .map(t => t.values); Xp(t, s, e, i, n, o, r), jp(s, o, i, n, r); for (let l = 1; a > 0; a--)Yp(s, l *= 0.99, r), jp(s, o, i, n, r), tg(s, l, r), jp(s, o, i, n, r);
  } function Up(t) { return t === "vertical" ? function (t) { return t.getLayout().y; } : function (t) { return t.getLayout().x; }; } function Xp(t, e, i, n, o, a, r) { const s = []; d(e, (t) => { const e = t.length; let i = 0; let l = 0; d(t, (t) => { i += t.getLayout().value; }), l = r === "vertical" ? (o - (e - 1) * a) / i : (n - (e - 1) * a) / i, s.push(l); }), s.sort((t, e) => t - e); const l = s[0]; d(e, (t) => { d(t, (t, e) => { const i = t.getLayout().value * l; r === "vertical" ? (t.setLayout({ x: e }, !0), t.setLayout({ dx: i }, !0)) : (t.setLayout({ y: e }, !0), t.setLayout({ dy: i }, !0)); }); }), d(i, (t) => { const e = +t.getValue() * l; t.setLayout({ dy: e }, !0); }); } function jp(t, e, i, n, o) { d(t, (t) => { let a; let r; let s; let l = 0; const u = t.length; if (o === "vertical") { let h; for (t.sort((t, e) => t.getLayout().x - e.getLayout().x), s = 0; s < u; s++)(r = l - (a = t[s]).getLayout().x) > 0 && (h = a.getLayout().x + r, a.setLayout({ x: h }, !0)), l = a.getLayout().x + a.getLayout().dx + e; if ((r = l - e - n) > 0) for (h = a.getLayout().x - r, a.setLayout({ x: h }, !0), l = h, s = u - 2; s >= 0; --s)(r = (a = t[s]).getLayout().x + a.getLayout().dx + e - l) > 0 && (h = a.getLayout().x - r, a.setLayout({ x: h }, !0)), l = a.getLayout().x; } else { let c; for (t.sort((t, e) => t.getLayout().y - e.getLayout().y), s = 0; s < u; s++)(r = l - (a = t[s]).getLayout().y) > 0 && (c = a.getLayout().y + r, a.setLayout({ y: c }, !0)), l = a.getLayout().y + a.getLayout().dy + e; if ((r = l - e - i) > 0) for (c = a.getLayout().y - r, a.setLayout({ y: c }, !0), l = c, s = u - 2; s >= 0; --s)(r = (a = t[s]).getLayout().y + a.getLayout().dy + e - l) > 0 && (c = a.getLayout().y - r, a.setLayout({ y: c }, !0)), l = a.getLayout().y; } }); } function Yp(t, e, i) { d(t.slice().reverse(), (t) => { d(t, (t) => { if (t.outEdges.length) { const n = Qp(t.outEdges, qp, i) / Qp(t.outEdges, Jp, i); if (i === "vertical") { const o = t.getLayout().x + (n - $p(t, i)) * e; t.setLayout({ x: o }, !0); } else { const a = t.getLayout().y + (n - $p(t, i)) * e; t.setLayout({ y: a }, !0); } } }); }); } function qp(t, e) { return $p(t.node2, e) * t.getValue(); } function Kp(t, e) { return $p(t.node1, e) * t.getValue(); } function $p(t, e) { return e === "vertical" ? t.getLayout().x + t.getLayout().dx / 2 : t.getLayout().y + t.getLayout().dy / 2; } function Jp(t) { return t.getValue(); } function Qp(t, e, i) { for (var n = 0, o = t.length, a = -1; ++a < o;) { const r = +e.call(t, t[a], i); isNaN(r) || (n += r); } return n; } function tg(t, e, i) { d(t, (t) => { d(t, (t) => { if (t.inEdges.length) { const n = Qp(t.inEdges, Kp, i) / Qp(t.inEdges, Jp, i); if (i === "vertical") { const o = t.getLayout().x + (n - $p(t, i)) * e; t.setLayout({ x: o }, !0); } else { const a = t.getLayout().y + (n - $p(t, i)) * e; t.setLayout({ y: a }, !0); } } }); }); } function eg(t, e) { d(t, (t) => { e === "vertical" ? (t.outEdges.sort((t, e) => t.node2.getLayout().x - e.node2.getLayout().x), t.inEdges.sort((t, e) => t.node1.getLayout().x - e.node1.getLayout().x)) : (t.outEdges.sort((t, e) => t.node2.getLayout().y - e.node2.getLayout().y), t.inEdges.sort((t, e) => t.node1.getLayout().y - e.node1.getLayout().y)); }), d(t, (t) => { let e = 0; let i = 0; d(t.outEdges, (t) => { t.setLayout({ sy: e }, !0), e += t.getLayout().dy; }), d(t.inEdges, (t) => { t.setLayout({ ty: i }, !0), i += t.getLayout().dy; }); }); } function ig(t, e, i, n, o) { const a = t.ends; const r = new Bk({ shape: { points: o ? og(a, n, t) : a } }); return ng(t, r, e, i, o), r; } function ng(t, e, i, n, o) { const a = i.hostModel; (0, zM[o ? "initProps" : "updateProps"])(e, { shape: { points: t.ends } }, a, n); const r = i.getItemModel(n); const s = r.getModel(Rk); const l = i.getItemVisual(n, "color"); const u = s.getItemStyle(["borderColor"]); u.stroke = l, u.strokeNoScale = !0, e.useStyle(u), e.z2 = 100, co(e, r.getModel(zk).getItemStyle()); } function og(t, e, i) { return f(t, t => t = t.slice(), t[e] = i.initBaseline, t); } function ag(t) { const e = []; const i = []; return t.eachSeriesByType("boxplot", (t) => { const n = t.getBaseAxis(); let o = l(i, n); o < 0 && (o = i.length, i[o] = n, e[o] = { axis: n, seriesModels: [] }), e[o].seriesModels.push(t); }), e; } function rg(t) { let e; let i; const n = t.axis; const o = t.seriesModels; const a = o.length; const r = t.boxWidthList = []; const s = t.boxOffsetList = []; const l = []; if (n.type === "category")i = n.getBandWidth(); else { let u = 0; Gk(o, (t) => { u = Math.max(u, t.getData().count()); }), e = n.getExtent(), Math.abs(e[1] - e[0]); }Gk(o, (t) => { let e = t.get("boxWidth"); y(e) || (e = [e, e]), l.push([Bo(e[0], i) || 0, Bo(e[1], i) || 0]); }); const h = 0.8 * i - 2; const c = h / a * 0.3; const d = (h - c * (a - 1)) / a; let f = d / 2 - h / 2; Gk(o, (t, e) => { s.push(f), f += c + d, r.push(Math.min(Math.max(d, l[e][0]), l[e][1])); }); } function sg(t, e, i) { function n(t, i, n) { const o = s.get(i, n); const a = []; a[u] = t, a[h] = o; let l; return isNaN(t) || isNaN(o) ? l = [NaN, NaN] : (l = r.dataToPoint(a))[u] += e, l; } function o(t, e, i) { const n = e.slice(); const o = e.slice(); n[u] += l, o[u] -= l, i ? t.push(n, o) : t.push(o, n); } function a(t, e) { const i = e.slice(); const n = e.slice(); i[u] -= l, n[u] += l, t.push(i, n); } var r = t.coordinateSystem; var s = t.getData(); var l = i / 2; var u = t.get("layout") === "horizontal" ? 0 : 1; var h = 1 - u; const c = ["x", "y"]; const d = s.mapDimension(c[u]); const f = s.mapDimension(c[h], !0); if (!(d == null || f.length < 5)) for (let p = 0; p < s.count(); p++) { const g = s.get(d, p); const m = n(g, f[2], p); const v = n(g, f[0], p); const y = n(g, f[1], p); const x = n(g, f[3], p); const _ = n(g, f[4], p); const w = []; o(w, y, 0), o(w, x, 1), w.push(v, y, _, x), a(w, v), a(w, _), a(w, m), s.setItemLayout(p, { initBaseline: m[h], ends: w }); } } function lg(t, e, i) { const n = t.ends; return new Zk({ shape: { points: i ? hg(n, t) : n }, z2: 100 }); } function ug(t, e, i, n) { const o = e.getItemModel(i); const a = o.getModel(Fk); const r = e.getItemVisual(i, "color"); const s = e.getItemVisual(i, "borderColor") || r; const l = a.getItemStyle(Hk); t.useStyle(l), t.style.strokeNoScale = !0, t.style.fill = r, t.style.stroke = s, t.__simpleBox = n, co(t, o.getModel(Wk).getItemStyle()); } function hg(t, e) { return f(t, t => t = t.slice(), t[1] = e.initBaseline, t); } function cg(t, e, i) { const n = t.getData(); const o = n.getLayout("largePoints"); const a = new Uk({ shape: { points: o }, __sign: 1 }); e.add(a); const r = new Uk({ shape: { points: o }, __sign: -1 }); e.add(r), dg(1, a, t, n), dg(-1, r, t, n), i && (a.incremental = !0, r.incremental = !0); } function dg(t, e, i, n) { const o = t > 0 ? "P" : "N"; const a = n.getVisual(`borderColor${o}`) || n.getVisual(`color${o}`); const r = i.getModel(Fk).getItemStyle(Hk); e.useStyle(r), e.style.fill = null, e.style.stroke = a; } function fg(t, e, i, n, o) { return i > n ? -1 : i < n ? 1 : e > 0 ? t.get(o, e - 1) <= n ? 1 : -1 : 1; } function pg(t, e) { let i; const n = t.getBaseAxis(); const o = n.type === "category" ? n.getBandWidth() : (i = n.getExtent(), Math.abs(i[1] - i[0]) / e.count()); const a = Bo(A(t.get("barMaxWidth"), o), o); const r = Bo(A(t.get("barMinWidth"), 1), o); const s = t.get("barWidth"); return s != null ? Bo(s, o) : Math.max(Math.min(o / 2, a), r); } function gg(t) { return y(t) || (t = [+t, +t]), t; } function mg(t, e) { t.eachChild((t) => { t.attr({ z: e.z, zlevel: e.zlevel, style: { stroke: e.brushType === "stroke" ? e.color : null, fill: e.brushType === "fill" ? e.color : null } }); }); } function vg(t, e) { tb.call(this); const i = new _u(t, e); const n = new tb(); this.add(i), this.add(n), n.beforeUpdate = function () { this.attr(i.getScale()); }, this.updateData(t, e); } function yg(t) { const e = t.data; e && e[0] && e[0][0] && e[0][0].coord && (t.data = f(e, (t) => { const e = { coords: [t[0].coord, t[1].coord] }; return t[0].name && (e.fromName = t[0].name), t[1].name && (e.toName = t[1].name), o([e, t[0], t[1]]); })); } function xg(t, e, i) { tb.call(this), this.add(this.createLine(t, e, i)), this._updateEffectSymbol(t, e); } function _g(t, e, i) { tb.call(this), this._createPolyline(t, e, i); } function wg(t, e, i) { xg.call(this, t, e, i), this._lastFrame = 0, this._lastFramePercent = 0; } function bg() { this.group = new tb(); } function Sg(t) { return t instanceof Array || (t = [t, t]), t; } function Mg() { const t = iw(); this.canvas = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {}; } function Ig(t, e, i) { const n = t[1] - t[0]; const o = (e = f(e, e => ({ interval: [(e.interval[0] - t[0]) / n, (e.interval[1] - t[0]) / n] }))).length; let a = 0; return function (t) { for (n = a; n < o; n++) if ((r = e[n].interval)[0] <= t && t <= r[1]) { a = n; break; } if (n === o) for (var n = a - 1; n >= 0; n--) { var r = e[n].interval; if (r[0] <= t && t <= r[1]) { a = n; break; } } return n >= 0 && n < o && i[n]; }; } function Tg(t, e) { const i = t[1] - t[0]; return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i], function (t) { return t >= e[0] && t <= e[1]; }; } function Ag(t) { const e = t.dimensions; return e[0] === "lng" && e[1] === "lat"; } function Dg(t, e, i, n) {
    const o = t.getItemLayout(e); const a = i.get("symbolRepeat"); const r = i.get("symbolClip"); const s = i.get("symbolPosition") || "start"; const l = (i.get("symbolRotate") || 0) * Math.PI / 180 || 0; const u = i.get("symbolPatternSize") || 2; const h = i.isAnimationEnabled(); const c = {
      dataIndex: e, layout: o, itemModel: i, symbolType: t.getItemVisual(e, "symbol") || "circle", color: t.getItemVisual(e, "color"), symbolClip: r, symbolRepeat: a, symbolRepeatDirection: i.get("symbolRepeatDirection"), symbolPatternSize: u, rotation: l, animationModel: h ? i : null, hoverAnimation: h && i.get("hoverAnimation"), z2: i.getShallow("z", !0) || 0,
    }; Cg(i, a, o, n, c), kg(t, e, o, a, r, c.boundingLength, c.pxSign, u, n, c), Pg(i, c.symbolScale, l, n, c); const d = c.symbolSize; let f = i.get("symbolOffset"); return y(f) && (f = [Bo(f[0], d[0]), Bo(f[1], d[1])]), Ng(i, d, o, a, r, f, s, c.valueLineWidth, c.boundingLength, c.repeatCutLength, n, c), c;
  } function Cg(t, e, i, n, o) { let a; const r = n.valueDim; const s = t.get("symbolBoundingData"); const l = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()); const u = l.toGlobalCoord(l.dataToCoord(0)); const h = 1 - +(i[r.wh] <= 0); if (y(s)) { const c = [Lg(l, s[0]) - u, Lg(l, s[1]) - u]; c[1] < c[0] && c.reverse(), a = c[h]; } else a = s != null ? Lg(l, s) - u : e ? n.coordSysExtent[r.index][h] - u : i[r.wh]; o.boundingLength = a, e && (o.repeatCutLength = i[r.wh]), o.pxSign = a > 0 ? 1 : a < 0 ? -1 : 0; } function Lg(t, e) { return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e))); } function kg(t, e, i, n, o, a, r, s, l, u) { const h = l.valueDim; const c = l.categoryDim; const d = Math.abs(i[c.wh]); let f = t.getItemVisual(e, "symbolSize"); y(f) ? f = f.slice() : (f == null && (f = "100%"), f = [f, f]), f[c.index] = Bo(f[c.index], d), f[h.index] = Bo(f[h.index], n ? d : Math.abs(a)), u.symbolSize = f, (u.symbolScale = [f[0] / s, f[1] / s])[h.index] *= (l.isHorizontal ? -1 : 1) * r; } function Pg(t, e, i, n, o) { let a = t.get(dP) || 0; a && (pP.attr({ scale: e.slice(), rotation: i }), pP.updateTransform(), a /= pP.getLineScale(), a *= e[n.valueDim.index]), o.valueLineWidth = a; } function Ng(t, e, i, n, o, r, s, l, u, h, c, d) { const f = c.categoryDim; const p = c.valueDim; const g = d.pxSign; const m = Math.max(e[p.index] + l, 0); let v = m; if (n) { const y = Math.abs(u); let x = `${T(t.get("symbolMargin"), "15%")}`; let _ = !1; x.lastIndexOf("!") === x.length - 1 && (_ = !0, x = x.slice(0, x.length - 1)), x = Bo(x, e[p.index]); let w = Math.max(m + 2 * x, 0); let b = _ ? 0 : 2 * x; const S = Jo(n); let M = S ? n : Kg((y + b) / w); w = m + 2 * (x = (y - M * m) / 2 / (_ ? M : M - 1)), b = _ ? 0 : 2 * x, S || n === "fixed" || (M = h ? Kg((Math.abs(h) + b) / w) : 0), v = M * w - b, d.repeatTimes = M, d.symbolMargin = x; } const I = g * (v / 2); const A = d.pathPosition = []; A[f.index] = i[f.wh] / 2, A[p.index] = s === "start" ? I : s === "end" ? u - I : u / 2, r && (A[0] += r[0], A[1] += r[1]); const D = d.bundlePosition = []; D[f.index] = i[f.xy], D[p.index] = i[p.xy]; const C = d.barRectShape = a({}, i); C[p.wh] = g * Math.max(Math.abs(i[p.wh]), Math.abs(A[p.index] + I)), C[f.wh] = i[f.wh]; const L = d.clipShape = {}; L[f.xy] = -i[f.xy], L[f.wh] = c.ecSize[f.wh], L[p.xy] = 0, L[p.wh] = i[p.wh]; } function Og(t) { const e = t.symbolPatternSize; const i = $l(t.symbolType, -e / 2, -e / 2, e, e, t.color); return i.attr({ culling: !0 }), i.type !== "image" && i.setStyle({ strokeNoScale: !0 }), i; } function Eg(t, e, i, n) { function o(t) { const e = l.slice(); const n = i.pxSign; let o = t; return (i.symbolRepeatDirection === "start" ? n > 0 : n < 0) && (o = h - 1 - t), e[u.index] = d * (o - h / 2 + 0.5) + l[u.index], { position: e, scale: i.symbolScale.slice(), rotation: i.rotation }; } const a = t.__pictorialBundle; const r = i.symbolSize; const s = i.valueLineWidth; var l = i.pathPosition; var u = e.valueDim; var h = i.repeatTimes || 0; let c = 0; var d = r[e.valueDim.index] + s + 2 * i.symbolMargin; for (jg(t, (t) => { t.__pictorialAnimationIndex = c, t.__pictorialRepeatTimes = h, c < h ? Yg(t, null, o(c), i, n) : Yg(t, null, { scale: [0, 0] }, i, n, () => { a.remove(t); }), Wg(t, i), c++; }); c < h; c++) { const f = Og(i); f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = h, a.add(f); const p = o(c); Yg(f, { position: p.position, scale: [0, 0] }, { scale: p.scale, rotation: p.rotation }, i, n), f.on("mouseover", () => { jg(t, (t) => { t.trigger("emphasis"); }); }).on("mouseout", () => { jg(t, (t) => { t.trigger("normal"); }); }), Wg(f, i); } } function Rg(t, e, i, n) { const o = t.__pictorialBundle; let a = t.__pictorialMainPath; a ? Yg(a, null, { position: i.pathPosition.slice(), scale: i.symbolScale.slice(), rotation: i.rotation }, i, n) : (a = t.__pictorialMainPath = Og(i), o.add(a), Yg(a, { position: i.pathPosition.slice(), scale: [0, 0], rotation: i.rotation }, { scale: i.symbolScale.slice() }, i, n), a.on("mouseover", function () { this.trigger("emphasis"); }).on("mouseout", function () { this.trigger("normal"); })), Wg(a, i); } function zg(t, e, i) {
    const n = a({}, e.barRectShape); let o = t.__pictorialBarRect; o ? Yg(o, null, { shape: n }, e, i) : (o = t.__pictorialBarRect = new yM({
      z2: 2, shape: n, silent: !0, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 },
    }), t.add(o));
  } function Bg(t, e, i, n) { if (i.symbolClip) { let o = t.__pictorialClipPath; const r = a({}, i.clipShape); const s = e.valueDim; const l = i.animationModel; const u = i.dataIndex; if (o)Mo(o, { shape: r }, l, u); else { r[s.wh] = 0, o = new yM({ shape: r }), t.__pictorialBundle.setClipPath(o), t.__pictorialClipPath = o; const h = {}; h[s.wh] = i.clipShape[s.wh], zM[n ? "updateProps" : "initProps"](o, { shape: h }, l, u); } } } function Vg(t, e) { const i = t.getItemModel(e); return i.getAnimationDelayParams = Gg, i.isAnimationEnabled = Fg, i; } function Gg(t) { return { index: t.__pictorialAnimationIndex, count: t.__pictorialRepeatTimes }; } function Fg() { return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation"); } function Wg(t, e) { t.off("emphasis").off("normal"); const i = e.symbolScale.slice(); e.hoverAnimation && t.on("emphasis", function () { this.animateTo({ scale: [1.1 * i[0], 1.1 * i[1]] }, 400, "elasticOut"); }).on("normal", function () { this.animateTo({ scale: i.slice() }, 400, "elasticOut"); }); } function Hg(t, e, i, n) {
    const o = new tb(); const
      a = new tb(); return o.add(a), o.__pictorialBundle = a, a.attr("position", i.bundlePosition.slice()), i.symbolRepeat ? Eg(o, e, i) : Rg(o, e, i), zg(o, i, n), Bg(o, e, i, n), o.__pictorialShapeStr = Xg(t, i), o.__pictorialSymbolMeta = i, o;
  } function Zg(t, e, i) { const n = i.animationModel; const o = i.dataIndex; Mo(t.__pictorialBundle, { position: i.bundlePosition.slice() }, n, o), i.symbolRepeat ? Eg(t, e, i, !0) : Rg(t, e, i, !0), zg(t, i, !0), Bg(t, e, i, !0); } function Ug(t, e, i, n) { const o = n.__pictorialBarRect; o && (o.style.text = null); const a = []; jg(n, (t) => { a.push(t); }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (i = null), d(a, (t) => { Mo(t, { scale: [0, 0] }, i, e, () => { n.parent && n.parent.remove(n); }); }), t.setItemGraphicEl(e, null); } function Xg(t, e) { return [t.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":"); } function jg(t, e, i) { d(t.__pictorialBundle.children(), (n) => { n !== t.__pictorialBarRect && e.call(i, n); }); } function Yg(t, e, i, n, o, a) { e && t.attr(e), n.symbolClip && !o ? i && t.attr(i) : i && zM[o ? "updateProps" : "initProps"](t, i, n.animationModel, n.dataIndex, a); } function qg(t, e, i) { const n = i.color; const o = i.dataIndex; const a = i.itemModel; const s = a.getModel("itemStyle").getItemStyle(["color"]); const l = a.getModel("emphasis.itemStyle").getItemStyle(); const u = a.getShallow("cursor"); jg(t, (t) => { t.setColor(n), t.setStyle(r({ fill: n, opacity: i.opacity }, s)), co(t, l), u && (t.cursor = u), t.z2 = i.z2; }); const h = {}; const c = e.valueDim.posDesc[+(i.boundingLength > 0)]; const d = t.__pictorialBarRect; Lh(d.style, h, a, n, e.seriesModel, o, c), co(d, h); } function Kg(t) { const e = Math.round(t); return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t); } function $g(t, e, i) { this.dimension = "single", this.dimensions = ["single"], this._axis = null, this._rect, this._init(t, e, i), this.model = t; } function Jg(t, e) {
    e = e || {}; const i = t.coordinateSystem; const n = t.axis; const o = {}; const a = n.position; const r = n.orient; const s = i.getRect(); const l = [s.x, s.x + s.width, s.y, s.y + s.height]; const u = { horizontal: { top: l[2], bottom: l[3] }, vertical: { left: l[0], right: l[1] } }; o.position = [r === "vertical" ? u.vertical[a] : l[0], r === "horizontal" ? u.horizontal[a] : l[3]]; const h = { horizontal: 0, vertical: 1 }; o.rotation = Math.PI / 2 * h[r]; const c = {
      top: -1, bottom: 1, right: 1, left: -1,
    }; o.labelDirection = o.tickDirection = o.nameDirection = c[a], t.get("axisTick.inside") && (o.tickDirection = -o.tickDirection), T(e.labelInside, t.get("axisLabel.inside")) && (o.labelDirection = -o.labelDirection); let d = e.rotate; return d == null && (d = t.get("axisLabel.rotate")), o.labelRotation = a === "top" ? -d : d, o.z2 = 1, o;
  } function Qg(t, e, i, n, o) { const r = t.axis; if (!r.scale.isBlank() && r.containData(e)) if (t.involveSeries) { const s = tm(e, t); const l = s.payloadBatch; const u = s.snapToValue; l[0] && o.seriesIndex == null && a(o, l[0]), !n && t.snap && r.containData(u) && u != null && (e = u), i.showPointer(t, e, l, o), i.showTooltip(t, s, u); } else i.showPointer(t, e); } function tm(t, e) { const i = e.axis; const n = i.dim; let o = t; const a = []; let r = Number.MAX_VALUE; let s = -1; return wP(e.seriesModels, (e, l) => { let u; let h; const c = e.getData().mapDimension(n, !0); if (e.getAxisTooltipData) { const d = e.getAxisTooltipData(c, t, i); h = d.dataIndices, u = d.nestestValue; } else { if (!(h = e.getData().indicesOfNearest(c[0], t, i.type === "category" ? 0.5 : null)).length) return; u = e.getData().get(c[0], h[0]); } if (u != null && isFinite(u)) { const f = t - u; const p = Math.abs(f); p <= r && ((p < r || f >= 0 && s < 0) && (r = p, s = f, o = u, a.length = 0), wP(h, (t) => { a.push({ seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t) }); })); } }), { payloadBatch: a, snapToValue: o }; } function em(t, e, i, n) { t[e.key] = { value: i, payloadBatch: n }; } function im(t, e, i, n) {
    const o = i.payloadBatch; const a = e.axis; const r = a.model; const s = e.axisPointerModel; if (e.triggerTooltip && o.length) {
      const l = e.coordSys.model; const u = Th(l); let h = t.map[u]; h || (h = t.map[u] = {
        coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [],
      }, t.list.push(h)), h.dataByAxis.push({
        axisDim: a.dim, axisIndex: r.componentIndex, axisType: r.type, axisId: r.id, value: n, valueLabelOpt: { precision: s.get("label.precision"), formatter: s.get("label.formatter") }, seriesDataIndices: o.slice(),
      });
    }
  } function nm(t, e, i) { const n = i.axesInfo = []; wP(e, (e, i) => { const o = e.axisPointerModel.option; const a = t[i]; a ? (!e.useHandle && (o.status = "show"), o.value = a.value, o.seriesDataIndices = (a.payloadBatch || []).slice()) : !e.useHandle && (o.status = "hide"), o.status === "show" && n.push({ axisDim: e.axis.dim, axisIndex: e.axis.model.componentIndex, value: o.value }); }); } function om(t, e, i, n) {
    if (!lm(e) && t.list.length) {
      const o = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}; n({
        type: "showTip", escapeConnect: !0, x: e[0], y: e[1], tooltipOption: i.tooltipOption, position: i.position, dataIndexInside: o.dataIndexInside, dataIndex: o.dataIndex, seriesIndex: o.seriesIndex, dataByCoordSys: t.list,
      });
    } else n({ type: "hideTip" });
  } function am(t, e, i) { const n = i.getZr(); const o = SP(n).axisPointerLastHighlights || {}; const a = SP(n).axisPointerLastHighlights = {}; wP(t, (t, e) => { const i = t.axisPointerModel.option; i.status === "show" && wP(i.seriesDataIndices, (t) => { const e = `${t.seriesIndex} | ${t.dataIndex}`; a[e] = t; }); }); const r = []; const s = []; d(o, (t, e) => { !a[e] && s.push(t); }), d(a, (t, e) => { !o[e] && r.push(t); }), s.length && i.dispatchAction({ type: "downplay", escapeConnect: !0, batch: s }), r.length && i.dispatchAction({ type: "highlight", escapeConnect: !0, batch: r }); } function rm(t, e) { for (let i = 0; i < (t || []).length; i++) { const n = t[i]; if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n; } } function sm(t) { const e = t.axis.model; const i = {}; const n = i.axisDim = t.axis.dim; return i.axisIndex = i[`${n}AxisIndex`] = e.componentIndex, i.axisName = i[`${n}AxisName`] = e.name, i.axisId = i[`${n}AxisId`] = e.id, i; } function lm(t) { return !t || t[0] == null || isNaN(t[0]) || t[1] == null || isNaN(t[1]); } function um(t, e, i) { if (!U_.node) { const n = e.getZr(); MP(n).records || (MP(n).records = {}), hm(n, e), (MP(n).records[t] || (MP(n).records[t] = {})).handler = i; } } function hm(t, e) { function i(i, n) { t.on(i, (i) => { const o = pm(e); IP(MP(t).records, (t) => { t && n(t, i, o.dispatchAction); }), cm(o.pendings, e); }); }MP(t).initialized || (MP(t).initialized = !0, i("click", v(fm, "click")), i("mousemove", v(fm, "mousemove")), i("globalout", dm)); } function cm(t, e) { let i; const n = t.showTip.length; const o = t.hideTip.length; n ? i = t.showTip[n - 1] : o && (i = t.hideTip[o - 1]), i && (i.dispatchAction = null, e.dispatchAction(i)); } function dm(t, e, i) { t.handler("leave", null, i); } function fm(t, e, i, n) { e.handler(t, i, n); } function pm(t) { const e = { showTip: [], hideTip: [] }; var i = function (n) { const o = e[n.type]; o ? o.push(n) : (n.dispatchAction = i, t.dispatchAction(n)); }; return { dispatchAction: i, pendings: e }; } function gm(t, e) { if (!U_.node) { const i = e.getZr(); (MP(i).records || {})[t] && (MP(i).records[t] = null); } } function mm() {} function vm(t, e, i, n) { ym(AP(i).lastProp, n) || (AP(i).lastProp = n, e ? Mo(i, n, t) : (i.stopAnimation(), i.attr(n))); } function ym(t, e) { if (w(t) && w(e)) { let i = !0; return d(e, (e, n) => { i = i && ym(t[n], e); }), !!i; } return t === e; } function xm(t, e) { t[e.get("label.show") ? "show" : "hide"](); } function _m(t) { return { position: t.position.slice(), rotation: t.rotation || 0 }; } function wm(t, e, i) { const n = e.get("z"); const o = e.get("zlevel"); t && t.traverse((t) => { t.type !== "group" && (n != null && (t.z = n), o != null && (t.zlevel = o), t.silent = i); }); } function bm(t) { let e; const i = t.get("type"); const n = t.getModel(`${i}Style`); return i === "line" ? (e = n.getLineStyle()).fill = null : i === "shadow" && ((e = n.getAreaStyle()).stroke = null), e; } function Sm(t, e, i, n, o) {
    const a = Im(i.get("value"), e.axis, e.ecModel, i.get("seriesDataIndices"), { precision: i.get("label.precision"), formatter: i.get("label.formatter") }); const r = i.getModel("label"); const s = qM(r.get("padding") || 0); const l = r.getFont(); const u = ke(a, l); const h = o.position; const c = u.width + s[1] + s[3]; const d = u.height + s[0] + s[2]; const f = o.align; f === "right" && (h[0] -= c), f === "center" && (h[0] -= c / 2); const p = o.verticalAlign; p === "bottom" && (h[1] -= d), p === "middle" && (h[1] -= d / 2), Mm(h, c, d, n); let g = r.get("backgroundColor"); g && g !== "auto" || (g = e.get("axisLine.lineStyle.color")), t.label = {
      shape: {
        x: 0, y: 0, width: c, height: d, r: r.get("borderRadius"),
      },
      position: h.slice(),
      style: {
        text: a, textFont: l, textFill: r.getTextColor(), textPosition: "inside", fill: g, stroke: r.get("borderColor") || "transparent", lineWidth: r.get("borderWidth") || 0, shadowBlur: r.get("shadowBlur"), shadowColor: r.get("shadowColor"), shadowOffsetX: r.get("shadowOffsetX"), shadowOffsetY: r.get("shadowOffsetY"),
      },
      z2: 10,
    };
  } function Mm(t, e, i, n) { const o = n.getWidth(); const a = n.getHeight(); t[0] = Math.min(t[0] + e, o) - e, t[1] = Math.min(t[1] + i, a) - i, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0); } function Im(t, e, i, n, o) { t = e.scale.parse(t); let a = e.scale.getLabel(t, { precision: o.precision }); const r = o.formatter; if (r) { const s = { value: Ul(e, t), seriesData: [] }; d(n, (t) => { const e = i.getSeriesByIndex(t.seriesIndex); const n = t.dataIndexInside; const o = e && e.getDataParams(n); o && s.seriesData.push(o); }), _(r) ? a = r.replace("{value}", a) : x(r) && (a = r(s)); } return a; } function Tm(t, e, i) { const n = xt(); return Mt(n, n, i.rotation), St(n, n, i.position), Ao([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n); } function Am(t, e, i, n, o, a) { const r = WD.innerTextLayout(i.rotation, 0, i.labelDirection); i.labelMargin = o.get("label.margin"), Sm(e, n, o, a, { position: Tm(n.axis, t, i), align: r.textAlign, verticalAlign: r.textVerticalAlign }); } function Dm(t, e, i) {
    return i = i || 0, {
      x1: t[i], y1: t[1 - i], x2: e[i], y2: e[1 - i],
    };
  } function Cm(t, e, i) {
    return i = i || 0, {
      x: t[i], y: t[1 - i], width: e[i], height: e[1 - i],
    };
  } function Lm(t, e, i, n, o, a) {
    return {
      cx: t, cy: e, r0: i, r: n, startAngle: o, endAngle: a, clockwise: !0,
    };
  } function km(t, e) { const i = {}; return i[`${e.dim}AxisIndex`] = e.index, t.getCartesian(i); } function Pm(t) { return t.dim === "x" ? 0 : 1; } function Nm(t) { return t.isHorizontal() ? 0 : 1; } function Om(t, e) { const i = t.getRect(); return [i[PP[e]], i[PP[e]] + i[NP[e]]]; } function Em(t, e, i) {
    const n = new yM({
      shape: {
        x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20,
      },
    }); return Io(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n;
  } function Rm(t, e, i) {
    if (t.count()) {
      for (var n, o = e.coordinateSystem, a = e.getLayerSeries(), r = t.mapDimension("single"), s = t.mapDimension("value"), l = f(a, e => f(e.indices, (e) => { const i = o.dataToPoint(t.get(r, e)); return i[1] = t.get(s, e), i; })), u = zm(l), h = u.y0, c = i / u.max, d = a.length, p = a[0].indices.length, g = 0; g < p; ++g) {
        n = h[g] * c, t.setItemLayout(a[0].indices[g], {
          layerIndex: 0, x: l[0][g][0], y0: n, y: l[0][g][1] * c,
        }); for (let m = 1; m < d; ++m) {
          n += l[m - 1][g][1] * c, t.setItemLayout(a[m].indices[g], {
            layerIndex: m, x: l[m][g][0], y0: n, y: l[m][g][1] * c,
          });
        }
      }
    }
  } function zm(t) { for (var e = t.length, i = t[0].length, n = [], o = [], a = 0, r = {}, s = 0; s < i; ++s) { for (var l = 0, u = 0; l < e; ++l)u += t[l][s][1]; u > a && (a = u), n.push(u); } for (let h = 0; h < i; ++h)o[h] = (a - n[h]) / 2; a = 0; for (let c = 0; c < i; ++c) { const d = n[c] + o[c]; d > a && (a = d); } return r.y0 = o, r.max = a, r; } function Bm(t) { let e = 0; d(t.children, (t) => { Bm(t); let i = t.value; y(i) && (i = i[0]), e += i; }); let i = t.value; y(i) && (i = i[0]), (i == null || isNaN(i)) && (i = e), i < 0 && (i = 0), y(t.value) ? t.value[0] = i : t.value = i; } function Vm(t, e, i) { function n() { r.ignore = r.hoverIgnore; } function o() { r.ignore = r.normalIgnore; }tb.call(this); const a = new hM({ z2: BP }); a.seriesIndex = e.seriesIndex; var r = new rM({ z2: VP, silent: t.getModel("label").get("silent") }); this.add(a), this.add(r), this.updateData(!0, t, "normal", e, i), this.on("emphasis", n).on("normal", o).on("mouseover", n).on("mouseout", o); } function Gm(t, e, i) { let n = t.getVisual("color"); const o = t.getVisual("visualMeta"); o && o.length !== 0 || (n = null); let a = t.getModel("itemStyle").get("color"); if (a) return a; if (n) return n; if (t.depth === 0) return i.option.color[0]; const r = i.option.color.length; return a = i.option.color[Fm(t) % r]; } function Fm(t) { for (var e = t; e.depth > 1;)e = e.parentNode; return l(t.getAncestors()[0].children, e); } function Wm(t, e, i) { return i !== zP.NONE && (i === zP.SELF ? t === e : i === zP.ANCESTOR ? t === e || t.isAncestorOf(e) : t === e || t.isDescendantOf(e)); } function Hm(t, e, i) { e.getData().setItemVisual(t.dataIndex, "color", i); } function Zm(t, e) { const i = t.children || []; t.children = Um(i, e), i.length && d(t.children, (t) => { Zm(t, e); }); } function Um(t, e) { if (typeof e === "function") return t.sort(e); const i = e === "asc"; return t.sort((t, e) => { const n = (t.getValue() - e.getValue()) * (i ? 1 : -1); return n === 0 ? (t.dataIndex - e.dataIndex) * (i ? -1 : 1) : n; }); } function Xm(t, e) { return e = e || [0, 0], f(["x", "y"], function (i, n) { const o = this.getAxis(i); const a = e[n]; const r = t[n] / 2; return o.type === "category" ? o.getBandWidth() : Math.abs(o.dataToCoord(a - r) - o.dataToCoord(a + r)); }, this); } function jm(t, e) { return e = e || [0, 0], f([0, 1], function (i) { const n = e[i]; const o = t[i] / 2; const a = []; const r = []; return a[i] = n - o, r[i] = n + o, a[1 - i] = r[1 - i] = e[1 - i], Math.abs(this.dataToPoint(a)[i] - this.dataToPoint(r)[i]); }, this); } function Ym(t, e) { const i = this.getAxis(); const n = e instanceof Array ? e[0] : e; const o = (t instanceof Array ? t[0] : t) / 2; return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(n - o) - i.dataToCoord(n + o)); } function qm(t, e) { return f(["Radius", "Angle"], function (i, n) { const o = this[`get${i}Axis`](); const a = e[n]; const r = t[n] / 2; const s = `dataTo${i}`; let l = o.type === "category" ? o.getBandWidth() : Math.abs(o[s](a - r) - o[s](a + r)); return i === "Angle" && (l = l * Math.PI / 180), l; }, this); } function Km(t) {
    let e; const i = t.type; if (i === "path") {
      const n = t.shape; const o = n.width != null && n.height != null ? {
        x: n.x || 0, y: n.y || 0, width: n.width, height: n.height,
      } : null; const a = lv(n); (e = Un(a, null, o, n.layout || "center")).__customPathData = a;
    } else i === "image" ? (e = new fi({})).__customImagePath = t.style.image : i === "text" ? (e = new rM({})).__customText = t.style.text : e = new (0, zM[i.charAt(0).toUpperCase() + i.slice(1)])(); return e.__customGraphicType = i, e.name = t.name, e;
  } function $m(t, e, n, o, a, r, s) { const l = {}; const u = n.style || {}; if (n.shape && (l.shape = i(n.shape)), n.position && (l.position = n.position.slice()), n.scale && (l.scale = n.scale.slice()), n.origin && (l.origin = n.origin.slice()), n.rotation && (l.rotation = n.rotation), t.type === "image" && n.style) { h = l.style = {}; d(["x", "y", "width", "height"], (e) => { Jm(e, h, u, t.style, r); }); } if (t.type === "text" && n.style) { var h = l.style = {}; d(["x", "y"], (e) => { Jm(e, h, u, t.style, r); }), !u.hasOwnProperty("textFill") && u.fill && (u.textFill = u.fill), !u.hasOwnProperty("textStroke") && u.stroke && (u.textStroke = u.stroke); } if (t.type !== "group" && (t.useStyle(u), r)) { t.style.opacity = 0; let c = u.opacity; c == null && (c = 1), Io(t, { style: { opacity: c } }, o, e); }r ? t.attr(l) : Mo(t, l, o, e), n.hasOwnProperty("z2") && t.attr("z2", n.z2 || 0), n.hasOwnProperty("silent") && t.attr("silent", n.silent), n.hasOwnProperty("invisible") && t.attr("invisible", n.invisible), n.hasOwnProperty("ignore") && t.attr("ignore", n.ignore), n.hasOwnProperty("info") && t.attr("info", n.info); const f = n.styleEmphasis; const p = !1 === f; t.__cusHasEmphStl && f == null || !t.__cusHasEmphStl && p || (ao(t, f), t.__cusHasEmphStl = !p), s && fo(t, !p); } function Jm(t, e, i, n, o) { i[t] == null || o || (e[t] = i[t], i[t] = n[t]); } function Qm(t, e, i, n) {
    function o(t) { t == null && (t = h), v && (c = e.getItemModel(t), d = c.getModel(XP), f = c.getModel(jP), p = e.getItemVisual(t, "color"), v = !1); } const s = t.get("renderItem"); const l = t.coordinateSystem; let u = {}; l && (u = l.prepareCustoms ? l.prepareCustoms() : qP[l.type](l)); let h; let c; let d; let f; let p; const g = r({
      getWidth: n.getWidth, getHeight: n.getHeight, getZr: n.getZr, getDevicePixelRatio: n.getDevicePixelRatio, value(t, i) { return i == null && (i = h), e.get(e.getDimension(t || 0), i); }, style(i, n) { n == null && (n = h), o(n); const r = c.getModel(ZP).getItemStyle(); p != null && (r.fill = p); const s = e.getItemVisual(n, "opacity"); return s != null && (r.opacity = s), go(r, d, null, { autoColor: p, isRectText: !0 }), r.text = d.getShallow("show") ? A(t.getFormattedLabel(n, "normal"), xu(e, n)) : null, i && a(r, i), r; }, styleEmphasis(i, n) { n == null && (n = h), o(n); const r = c.getModel(UP).getItemStyle(); return go(r, f, null, { isRectText: !0 }, !0), r.text = f.getShallow("show") ? D(t.getFormattedLabel(n, "emphasis"), t.getFormattedLabel(n, "normal"), xu(e, n)) : null, i && a(r, i), r; }, visual(t, i) { return i == null && (i = h), e.getItemVisual(i, t); }, barLayout(t) { if (l.getBaseAxis) return Cl(r({ axis: l.getBaseAxis() }, t), n); }, currentSeriesIndices() { return i.getCurrentSeriesIndices(); }, font(t) { return bo(t, i); },
    }, u.api || {}); const m = {
      context: {}, seriesId: t.id, seriesName: t.name, seriesIndex: t.seriesIndex, coordSys: u.coordSys, dataInsideLength: e.count(), encode: tv(t.getData()),
    }; var v = !0; return function (t, i) { return h = t, v = !0, s && s(r({ dataIndexInside: t, dataIndex: e.getRawIndex(t), actionType: i ? i.type : null }, m), g); };
  } function tv(t) { const e = {}; return d(t.dimensions, (i, n) => { const o = t.getDimensionInfo(i); if (!o.isExtraCoord) { const a = o.coordDim; (e[a] = e[a] || [])[o.coordDimIndex] = n; } }), e; } function ev(t, e, i, n, o, a) { return (t = iv(t, e, i, n, o, a, !0)) && a.setItemGraphicEl(e, t), t; } function iv(t, e, i, n, o, a, r) { const s = !i; const l = (i = i || {}).type; const u = i.shape; const h = i.style; if (t && (s || l != null && l !== t.__customGraphicType || l === "path" && uv(u) && lv(u) !== t.__customPathData || l === "image" && hv(h, "image") && h.image !== t.__customImagePath || l === "text" && hv(u, "text") && h.text !== t.__customText) && (o.remove(t), t = null), !s) { const c = !t; return !t && (t = Km(i)), $m(t, e, i, n, a, c, r), l === "group" && nv(t, e, i, n, a), o.add(t), t; } } function nv(t, e, i, n, o) {
    const a = i.children; const r = a ? a.length : 0; const s = i.$mergeChildren; const l = s === "byName" || i.diffChildrenByName; const u = !1 === s; if (r || l || u) {
      if (l) {
        ov({
          oldChildren: t.children() || [], newChildren: a || [], dataIndex: e, animatableModel: n, group: t, data: o,
        });
      } else { u && t.removeAll(); for (let h = 0; h < r; h++)a[h] && iv(t.childAt(h), e, a[h], n, t, o); }
    }
  } function ov(t) {
    new Us(t.oldChildren, t.newChildren, av, av, t).add(rv).update(rv).remove(sv)
      .execute();
  } function av(t, e) { const i = t && t.name; return i != null ? i : YP + e; } function rv(t, e) { const i = this.context; const n = t != null ? i.newChildren[t] : null; iv(e != null ? i.oldChildren[e] : null, i.dataIndex, n, i.animatableModel, i.group, i.data); } function sv(t) { const e = this.context; const i = e.oldChildren[t]; i && e.group.remove(i); } function lv(t) { return t && (t.pathData || t.d); } function uv(t) { return t && (t.hasOwnProperty("pathData") || t.hasOwnProperty("d")); } function hv(t, e) { return t && t.hasOwnProperty(e); } function cv(t, e, i, n) { const o = i.type; const a = new (0, zM[o.charAt(0).toUpperCase() + o.slice(1)])(i); e.add(a), n.set(t, a), a.__ecGraphicId = t; } function dv(t, e) { const i = t && t.parent; i && (t.type === "group" && t.traverse((t) => { dv(t, e); }), e.removeKey(t.__ecGraphicId), i.remove(t)); } function fv(t) { return t = a({}, t), d(["id", "parentId", "$action", "hv", "bounding"].concat(oI), (e) => { delete t[e]; }), t; } function pv(t, e) { let i; return d(e, (e) => { t[e] != null && t[e] !== "auto" && (i = !0); }), i; } function gv(t, e) { const i = t.exist; if (e.id = t.keyInfo.id, !e.type && i && (e.type = i.type), e.parentId == null) { const n = e.parentOption; n ? e.parentId = n.id : i && (e.parentId = i.parentId); }e.parentOption = null; } function mv(t, e, i) { const o = a({}, i); const r = t[e]; const s = i.$action || "merge"; s === "merge" ? r ? (n(r, o, !0), fa(r, o, { ignoreSize: !0 }), ga(i, r)) : t[e] = o : s === "replace" ? t[e] = o : s === "remove" && r && (t[e] = null); } function vv(t, e) { t && (t.hv = e.hv = [pv(e, ["left", "right"]), pv(e, ["top", "bottom"])], t.type === "group" && (t.width == null && (t.width = e.width = 0), t.height == null && (t.height = e.height = 0))); } function yv(t, e, i) { let n = t.eventData; t.silent || t.ignore || n || (n = t.eventData = { componentType: "graphic", componentIndex: e.componentIndex, name: t.name }), n && (n.info = t.info); } function xv(t, e, i) { let n; const o = {}; const a = t === "toggleSelected"; return i.eachComponent("legend", (i) => { a && n != null ? i[n ? "select" : "unSelect"](e.name) : (i[t](e.name), n = i.isSelected(e.name)), d(i.getData(), (t) => { const e = t.get("name"); if (e !== "\n" && e !== "") { const n = i.isSelected(e); o.hasOwnProperty(e) ? o[e] = o[e] && n : o[e] = n; } }); }), { name: e.name, selected: o }; } function _v(t, e, i) { const n = e.getBoxLayoutParams(); const o = e.get("padding"); const a = { width: i.getWidth(), height: i.getHeight() }; const r = ha(n, a, o); rI(e.get("orient"), t, e.get("itemGap"), r.width, r.height), ca(t, n, a, o); } function wv(t, e) {
    const i = qM(e.get("padding")); const n = e.getItemStyle(["color", "opacity"]); return n.fill = e.get("backgroundColor"), t = new yM({
      shape: {
        x: t.x - i[3], y: t.y - i[0], width: t.width + i[1] + i[3], height: t.height + i[0] + i[2], r: e.get("borderRadius"),
      },
      style: n,
      silent: !0,
      z2: -1,
    });
  } function bv(t, e) { e.dispatchAction({ type: "legendToggleSelect", name: t }); } function Sv(t, e, i, n) {
    const o = i.getZr().storage.getDisplayList()[0]; o && o.useHoverLayer || i.dispatchAction({
      type: "highlight", seriesName: t, name: e, excludeSeriesId: n,
    });
  } function Mv(t, e, i, n) {
    const o = i.getZr().storage.getDisplayList()[0]; o && o.useHoverLayer || i.dispatchAction({
      type: "downplay", seriesName: t, name: e, excludeSeriesId: n,
    });
  } function Iv(t, e, i) { const n = [1, 1]; n[t.getOrient().index] = 0, fa(e, i, { type: "box", ignoreSize: n }); } function Tv(t) { const e = `left ${t}s cubic-bezier(0.23, 1, 0.32, 1),top ${t}s cubic-bezier(0.23, 1, 0.32, 1)`; return f(uN, t => `${t}transition:${e}`).join(";"); } function Av(t) { const e = []; const i = t.get("fontSize"); const n = t.getTextColor(); return n && e.push(`color:${n}`), e.push(`font:${t.getFont()}`), i && e.push(`line-height:${Math.round(3 * i / 2)}px`), sN(["decoration", "align"], (i) => { const n = t.get(i); n && e.push(`text-${i}:${n}`); }), e.join(";"); } function Dv(t) { const e = []; const i = t.get("transitionDuration"); const n = t.get("backgroundColor"); const o = t.getModel("textStyle"); const a = t.get("padding"); return i && e.push(Tv(i)), n && (U_.canvasSupported ? e.push(`background-Color:${n}`) : (e.push(`background-Color:#${Zt(n)}`), e.push("filter:alpha(opacity=70)"))), sN(["width", "color", "radius"], (i) => { const n = `border-${i}`; const o = lN(n); const a = t.get(o); a != null && e.push(`${n}:${a}${i === "color" ? "" : "px"}`); }), e.push(Av(o)), a != null && e.push(`padding:${qM(a).join("px ")}px`), `${e.join(";")};`; } function Cv(t, e) { if (U_.wxa) return null; const i = document.createElement("div"); const n = this._zr = e.getZr(); this.el = i, this._x = e.getWidth() / 2, this._y = e.getHeight() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout; const o = this; i.onmouseenter = function () { o._enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0; }, i.onmousemove = function (e) { if (e = e || window.event, !o._enterable) { const i = n.handler; ut(t, e, !0), i.dispatch("mousemove", e); } }, i.onmouseleave = function () { o._enterable && o._show && o.hideLater(o._hideDelay), o._inContent = !1; }; } function Lv(t) { this._zr = t.getZr(), this._show = !1, this._hideTimeout; } function kv(t) { for (var e = t.pop(); t.length;) { let i = t.pop(); i && (Po.isInstance(i) && (i = i.get("tooltip", !0)), typeof i === "string" && (i = { formatter: i }), e = new Po(i, e, e.ecModel)); } return e; } function Pv(t, e) { return t.dispatchAction || m(e.dispatchAction, e); } function Nv(t, e, i, n, o, a, r) { const s = i.getOuterSize(); const l = s.width; const u = s.height; return a != null && (t + l + a > n ? t -= l + a : t += a), r != null && (e + u + r > o ? e -= u + r : e += r), [t, e]; } function Ov(t, e, i, n, o) { const a = i.getOuterSize(); const r = a.width; const s = a.height; return t = Math.min(t + r, n) - r, e = Math.min(e + s, o) - s, t = Math.max(t, 0), e = Math.max(e, 0), [t, e]; } function Ev(t, e, i) { const n = i[0]; const o = i[1]; let a = 0; let r = 0; const s = e.width; const l = e.height; switch (t) { case "inside": a = e.x + s / 2 - n / 2, r = e.y + l / 2 - o / 2; break; case "top": a = e.x + s / 2 - n / 2, r = e.y - o - 5; break; case "bottom": a = e.x + s / 2 - n / 2, r = e.y + l + 5; break; case "left": a = e.x - n - 5, r = e.y + l / 2 - o / 2; break; case "right": a = e.x + s + 5, r = e.y + l / 2 - o / 2; } return [a, r]; } function Rv(t) { return t === "center" || t === "middle"; } function zv(t) { return t.get("stack") || `__ec_stack_${t.seriesIndex}`; } function Bv(t) { return t.dim; } function Vv(t, e) {
    const i = {}; d(t, (t, e) => {
      const n = t.getData(); const o = t.coordinateSystem.getBaseAxis(); const a = o.getExtent(); const r = o.type === "category" ? o.getBandWidth() : Math.abs(a[1] - a[0]) / n.count(); const s = i[Bv(o)] || {
        bandWidth: r, remainedWidth: r, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {},
      }; const l = s.stacks; i[Bv(o)] = s; const u = zv(t); l[u] || s.autoWidthCount++, l[u] = l[u] || { width: 0, maxWidth: 0 }; let h = Bo(t.get("barWidth"), r); const c = Bo(t.get("barMaxWidth"), r); const d = t.get("barGap"); const f = t.get("barCategoryGap"); h && !l[u].width && (h = Math.min(s.remainedWidth, h), l[u].width = h, s.remainedWidth -= h), c && (l[u].maxWidth = c), d != null && (s.gap = d), f != null && (s.categoryGap = f);
    }); const n = {}; return d(i, (t, e) => { n[e] = {}; const i = t.stacks; const o = t.bandWidth; const a = Bo(t.categoryGap, o); const r = Bo(t.gap, 1); let s = t.remainedWidth; let l = t.autoWidthCount; let u = (s - a) / (l + (l - 1) * r); u = Math.max(u, 0), d(i, (t, e) => { let i = t.maxWidth; i && i < u && (i = Math.min(i, s), t.width && (i = Math.min(i, t.width)), s -= i, t.width = i, l--); }), u = (s - a) / (l + (l - 1) * r), u = Math.max(u, 0); let h; let c = 0; d(i, (t, e) => { t.width || (t.width = u), h = t, c += t.width * (1 + r); }), h && (c -= h.width * r); let f = -c / 2; d(i, (t, i) => { n[e][i] = n[e][i] || { offset: f, width: t.width }, f += t.width * (1 + r); }); }), n;
  } function Gv(t, e) { rD.call(this, "radius", t, e), this.type = "category"; } function Fv(t, e) { e = e || [0, 360], rD.call(this, "angle", t, e), this.type = "category"; } function Wv(t, e) { return e.type || (e.data ? "category" : "value"); } function Hv(t, e, i) { const n = e.get("center"); const o = i.getWidth(); const a = i.getHeight(); t.cx = Bo(n[0], o), t.cy = Bo(n[1], a); const r = t.getRadiusAxis(); const s = Math.min(o, a) / 2; const l = Bo(e.get("radius"), s); r.inverse ? r.setExtent(l, 0) : r.setExtent(0, l); } function Zv(t, e) { const i = this; const n = i.getAngleAxis(); const o = i.getRadiusAxis(); if (n.scale.setExtent(1 / 0, -1 / 0), o.scale.setExtent(1 / 0, -1 / 0), t.eachSeries((t) => { if (t.coordinateSystem === i) { const e = t.getData(); d(e.mapDimension("radius", !0), (t) => { o.scale.unionExtentFromData(e, pl(e, t)); }), d(e.mapDimension("angle", !0), (t) => { n.scale.unionExtentFromData(e, pl(e, t)); }); } }), Fl(n.scale, n.model), Fl(o.scale, o.model), n.type === "category" && !n.onBand) { const a = n.getExtent(); const r = 360 / n.scale.count(); n.inverse ? a[1] += r : a[1] -= r, n.setExtent(a[0], a[1]); } } function Uv(t, e) { if (t.type = e.get("type"), t.scale = Wl(e), t.onBand = e.get("boundaryGap") && t.type === "category", t.inverse = e.get("inverse"), e.mainType === "angleAxis") { t.inverse ^= e.get("clockwise"); const i = e.get("startAngle"); t.setExtent(i, i + (t.inverse ? -360 : 360)); }e.axis = t, t.model = e; } function Xv(t, e, i) {
    e[1] > e[0] && (e = e.slice().reverse()); const n = t.coordToPoint([e[0], i]); const o = t.coordToPoint([e[1], i]); return {
      x1: n[0], y1: n[1], x2: o[0], y2: o[1],
    };
  } function jv(t) { return t.getRadiusAxis().inverse ? 0 : 1; } function Yv(t) { const e = t[0]; const i = t[t.length - 1]; e && i && Math.abs(Math.abs(e.coord - i.coord) - 360) < 1e-4 && t.pop(); } function qv(t, e, i) {
    return {
      position: [t.cx, t.cy], rotation: i / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: e.getModel("axisLabel").get("rotate"), z2: 1,
    };
  } function Kv(t, e, i, n, o) { const a = e.axis; const r = a.dataToCoord(t); let s = n.getAngleAxis().getExtent()[0]; s = s / 180 * Math.PI; let l; let u; let h; const c = n.getRadiusAxis().getExtent(); if (a.dim === "radius") { const d = xt(); Mt(d, d, s), St(d, d, [n.cx, n.cy]), l = Ao([r, -o], d); const f = e.getModel("axisLabel").get("rotate") || 0; const p = WD.innerTextLayout(s, f * Math.PI / 180, -1); u = p.textAlign, h = p.textVerticalAlign; } else { const g = c[1]; l = n.coordToPoint([g + o, r]); const m = n.cx; const v = n.cy; u = Math.abs(l[0] - m) / g < 0.3 ? "center" : l[0] > m ? "left" : "right", h = Math.abs(l[1] - v) / g < 0.3 ? "middle" : l[1] > v ? "top" : "bottom"; } return { position: l, align: u, verticalAlign: h }; } function $v(t, e) { e.update = "updateView", Os(e, (e, i) => { const n = {}; return i.eachComponent({ mainType: "geo", query: e }, (i) => { i[t](e.name), d(i.coordinateSystem.regions, (t) => { n[t.name] = i.isSelected(t.name) || !1; }); }), { selected: n, name: e.name }; }); } function Jv(t) { const e = {}; d(t, (t) => { e[t] = 1; }), t.length = 0, d(e, (e, i) => { t.push(i); }); } function Qv(t) { if (t) for (const e in t) if (t.hasOwnProperty(e)) return !0; } function ty(t, e, n) { function o() { const t = function () {}; return t.prototype.__hidden = t.prototype, new t(); } const a = {}; return IN(e, (e) => { const r = a[e] = o(); IN(t[e], (t, o) => { if (cL.isValidType(o)) { let a = { type: o, visual: t }; n && n(a, e), r[o] = new cL(a), o === "opacity" && ((a = i(a)).type = "colorAlpha", r.__hidden.__alphaForOpacity = new cL(a)); } }); }), a; } function ey(t, e, n) { let o; d(n, (t) => { e.hasOwnProperty(t) && Qv(e[t]) && (o = !0); }), o && d(n, (n) => { e.hasOwnProperty(n) && Qv(e[n]) ? t[n] = i(e[n]) : delete t[n]; }); } function iy(t, e, i, n, o, a) { function r(t) { return i.getItemVisual(h, t); } function s(t, e) { i.setItemVisual(h, t, e); } function l(t, l) { h = a == null ? t : l; const c = i.getRawDataItem(h); if (!c || !1 !== c.visualMap) for (let d = n.call(o, t), f = e[d], p = u[d], g = 0, m = p.length; g < m; g++) { const v = p[g]; f[v] && f[v].applyVisual(t, r, s); } } var u = {}; d(t, (t) => { const i = cL.prepareVisualTypes(e[t]); u[t] = i; }); let h; a == null ? i.each(l) : i.each([a], l); } function ny(t, e, i, n) { const o = {}; return d(t, (t) => { const i = cL.prepareVisualTypes(e[t]); o[t] = i; }), { progress(t, a) { n != null && (n = a.getDimension(n)); for (var r; (r = t.next()) != null;) { const s = a.getRawDataItem(r); if (!s || !1 !== s.visualMap) for (let l = n != null ? a.get(n, r, !0) : r, u = i(l), h = e[u], c = o[u], d = 0, f = c.length; d < f; d++) { const p = c[d]; h[p] && h[p].applyVisual(l, t => a.getItemVisual(r, t), (t, e) => { a.setItemVisual(r, t, e); }); } } } }; } function oy(t) { const e = ["x", "y"]; const i = ["width", "height"]; return { point(e, i, n) { if (e) { const o = n.range; return ay(e[t], o); } }, rect(n, o, a) { if (n) { const r = a.range; const s = [n[e[t]], n[e[t]] + n[i[t]]]; return s[1] < s[0] && s.reverse(), ay(s[0], r) || ay(s[1], r) || ay(r[0], s) || ay(r[1], s); } } }; } function ay(t, e) { return e[0] <= t && t <= e[1]; } function ry(t, e, i, n, o) { for (let a = 0, r = o[o.length - 1]; a < o.length; a++) { const s = o[a]; if (sy(t, e, i, n, s[0], s[1], r[0], r[1])) return !0; r = s; } } function sy(t, e, i, n, o, a, r, s) { const l = uy(i - t, o - r, n - e, a - s); if (ly(l)) return !1; const u = uy(o - t, o - r, a - e, a - s) / l; if (u < 0 || u > 1) return !1; const h = uy(i - t, o - t, n - e, a - e) / l; return !(h < 0 || h > 1); } function ly(t) { return t <= 1e-6 && t >= -1e-6; } function uy(t, e, i, n) { return t * n - e * i; } function hy(t, e, i) { const n = this._targetInfoList = []; const o = {}; const a = dy(e, t); AN(NN, (t, e) => { (!i || !i.include || DN(i.include, e) >= 0) && t(a, n, o); }); } function cy(t) { return t[0] > t[1] && t.reverse(), t; } function dy(t, e) { return Vi(t, e, { includeMainTypes: kN }); } function fy(t, e, i, n) { const o = i.getAxis(["x", "y"][t]); const a = cy(f([0, 1], t => (e ? o.coordToData(o.toLocalCoord(n[t])) : o.toGlobalCoord(o.dataToCoord(n[t]))))); const r = []; return r[t] = a, r[1 - t] = [NaN, NaN], { values: a, xyMinMax: r }; } function py(t, e, i, n) { return [e[0] - n[t] * i[0], e[1] - n[t] * i[1]]; } function gy(t, e) { const i = my(t); const n = my(e); const o = [i[0] / n[0], i[1] / n[1]]; return isNaN(o[0]) && (o[0] = 1), isNaN(o[1]) && (o[1] = 1), o; } function my(t) { return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [NaN, NaN]; } function vy(t, e, i, n, o) { if (o) { const a = t.getZr(); a[GN] || (a[VN] || (a[VN] = yy), Pr(a, VN, i, e)(t, n)); } } function yy(t, e) { if (!t.isDisposed()) { const i = t.getZr(); i[GN] = !0, t.dispatchAction({ type: "brushSelect", batch: e }), i[GN] = !1; } } function xy(t, e, i, n) { for (let o = 0, a = e.length; o < a; o++) { const r = e[o]; if (t[r.brushType](n, i, r.selectors, r)) return !0; } } function _y(t) { const e = t.brushSelector; if (_(e)) { const i = []; return d(TN, (t, n) => { i[n] = function (i, n, o, a) { const r = n.getItemLayout(i); return t[e](r, o, a); }; }), i; } if (x(e)) { const n = {}; return d(TN, (t, i) => { n[i] = e; }), n; } return e; } function wy(t, e) { const i = t.option.seriesIndex; return i != null && i !== "all" && (y(i) ? l(i, e) < 0 : e !== i); } function by(t) { const e = t.selectors = {}; return d(TN[t.brushType], (i, n) => { e[n] = function (n) { return i(n, e, t); }; }), t; } function Sy(t) { return new de(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]); } function My(t, e) {
    return n({
      brushType: t.brushType, brushMode: t.brushMode, transformable: t.transformable, brushStyle: new Po(t.brushStyle).getItemStyle(), removeOnClick: t.removeOnClick, z: t.z,
    }, e, !0);
  } function Iy(t, e, i, n) { (!n || n.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice()); } function Ty(t, e) { ZN[t] = e; } function Ay(t) { return ZN[t]; } function Dy(t, e, i) { this.model = t, this.ecModel = e, this.api = i, this._brushType, this._brushMode; } function Cy(t, e, i) { this._model = t; } function Ly(t, e, i, n) { const o = i.calendarModel; const a = i.seriesModel; const r = o ? o.coordinateSystem : a ? a.coordinateSystem : null; return r === this ? r[t](n) : null; } function ky(t, e) { let i = t.cellSize; y(i) ? i.length === 1 && (i[1] = i[0]) : i = t.cellSize = [i, i]; const n = f([0, 1], t => da(e, t) && (i[t] = "auto"), i[t] != null && i[t] !== "auto"); fa(t, e, { type: "box", ignoreSize: n }); } function Py(t) { return l(KN, t) >= 0; } function Ny(t, e, i) { function n(t, e) { return l(e.nodes, t) >= 0; } function o(t, n) { let o = !1; return e((e) => { d(i(t, e) || [], (t) => { n.records[e.name][t] && (o = !0); }); }), o; } function a(t, n) { n.nodes.push(t), e((e) => { d(i(t, e) || [], (t) => { n.records[e.name][t] = !0; }); }); } return function (i) { const r = { nodes: [], records: {} }; if (e((t) => { r.records[t.name] = {}; }), !i) return r; a(i, r); let s; do { s = !1, t((t) => { !n(t, r) && o(t, r) && (a(t, r), s = !0); }); } while (s);return r; }; } function Oy(t, e, i) { let n = [1 / 0, -1 / 0]; return JN(i, (t) => { const i = t.getData(); i && JN(i.mapDimension(e, !0), (t) => { const e = i.getApproximateExtent(t); e[0] < n[0] && (n[0] = e[0]), e[1] > n[1] && (n[1] = e[1]); }); }), n[1] < n[0] && (n = [NaN, NaN]), Ey(t, n), n; } function Ey(t, e) { const i = t.getAxisModel(); const n = i.getMin(!0); const o = i.get("type") === "category"; const a = o && i.getCategories().length; n != null && n !== "dataMin" && typeof n !== "function" ? e[0] = n : o && (e[0] = a > 0 ? 0 : NaN); const r = i.getMax(!0); return r != null && r !== "dataMax" && typeof r !== "function" ? e[1] = r : o && (e[1] = a > 0 ? a - 1 : NaN), i.get("scale", !0) || (e[0] > 0 && (e[0] = 0), e[1] < 0 && (e[1] = 0)), e; } function Ry(t, e) { const i = t.getAxisModel(); const n = t._percentWindow; const o = t._valueWindow; if (n) { let a = Ho(o, [0, 500]); a = Math.min(a, 20); const r = e || n[0] === 0 && n[1] === 100; i.setRange(r ? null : +o[0].toFixed(a), r ? null : +o[1].toFixed(a)); } } function zy(t) { const e = t._minMaxSpan = {}; const i = t._dataZoomModel; JN(["min", "max"], (n) => { e[`${n}Span`] = i.get(`${n}Span`); let o = i.get(`${n}ValueSpan`); if (o != null && (e[`${n}ValueSpan`] = o, (o = t.getAxisModel().axis.scale.parse(o)) != null)) { const a = t._dataExtent; e[`${n}Span`] = zo(a[0] + o, a, [0, 100], !0); } }); } function By(t) { const e = {}; return eO(["start", "end", "startValue", "endValue", "throttle"], (i) => { t.hasOwnProperty(i) && (e[i] = t[i]); }), e; } function Vy(t, e) { const i = t._rangePropMode; const n = t.get("rangeMode"); eO([["start", "startValue"], ["end", "endValue"]], (t, o) => { const a = e[t[0]] != null; const r = e[t[1]] != null; a && !r ? i[o] = "percent" : !a && r ? i[o] = "value" : n ? i[o] = n[o] : a && (i[o] = "percent"); }); } function Gy(t) {
    return {
      x: "y", y: "x", radius: "angle", angle: "radius",
    }[t];
  } function Fy(t) { return t === "vertical" ? "ns-resize" : "ew-resize"; } function Wy(t, e) { const i = Uy(t); const n = e.dataZoomId; const o = e.coordId; d(i, (t, i) => { const a = t.dataZoomInfos; a[n] && l(e.allCoordIds, o) < 0 && (delete a[n], t.count--); }), jy(i); let a = i[o]; a || ((a = i[o] = { coordId: o, dataZoomInfos: {}, count: 0 }).controller = Xy(t, a), a.dispatchAction = v(Yy, t)), !a.dataZoomInfos[n] && a.count++, a.dataZoomInfos[n] = e; const r = qy(a.dataZoomInfos); a.controller.enable(r.controlType, r.opt), a.controller.setPointerChecker(e.containsPoint), Pr(a, "dispatchAction", e.dataZoomModel.get("throttle", !0), "fixRate"); } function Hy(t, e) { const i = Uy(t); d(i, (t) => { t.controller.dispose(); const i = t.dataZoomInfos; i[e] && (delete i[e], t.count--); }), jy(i); } function Zy(t) { return `${t.type}\0_${t.id}`; } function Uy(t) { const e = t.getZr(); return e[pO] || (e[pO] = {}); } function Xy(t, e) { const i = new nc(t.getZr()); return d(["pan", "zoom", "scrollMove"], (t) => { i.on(t, (i) => { const n = []; d(e.dataZoomInfos, (o) => { if (i.isAvailableBehavior(o.dataZoomModel.option)) { const a = (o.getRange || {})[t]; const r = a && a(e.controller, i); !o.dataZoomModel.get("disabled", !0) && r && n.push({ dataZoomId: o.dataZoomId, start: r[0], end: r[1] }); } }), n.length && e.dispatchAction(n); }); }), i; } function jy(t) { d(t, (e, i) => { e.count || (e.controller.dispose(), delete t[i]); }); } function Yy(t, e) { t.dispatchAction({ type: "dataZoom", batch: e }); } function qy(t) {
    let e; const i = {
      type_true: 2, type_move: 1, type_false: 0, type_undefined: -1,
    }; let n = !0; return d(t, (t) => { const o = t.dataZoomModel; const a = !o.get("disabled", !0) && (!o.get("zoomLock", !0) || "move"); i[`type_${a}`] > i[`type_${e}`] && (e = a), n &= o.get("preventDefaultMouseMove", !0); }), {
      controlType: e,
      opt: {
        zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !0, preventDefaultMouseMove: !!n,
      },
    };
  } function Ky(t) { return function (e, i, n, o) { const a = this._range; const r = a.slice(); const s = e.axisModels[0]; if (s) { const l = t(r, s, e, i, n, o); return tk(l, r, [0, 100], "all"), this._range = r, a[0] !== r[0] || a[1] !== r[1] ? r : void 0; } }; } function $y(t, e) { return t && t.hasOwnProperty && t.hasOwnProperty(e); } function Jy(t, e, i, n) { for (var o = e.targetVisuals[n], a = cL.prepareVisualTypes(o), r = { color: t.getData().getVisual("color") }, s = 0, l = a.length; s < l; s++) { const u = a[s]; const h = o[u === "opacity" ? "__alphaForOpacity" : u]; h && h.applyVisual(i, t => r[t], (t, e) => { r[t] = e; }); } return r.color; } function Qy(t, e, i) { if (i[0] === i[1]) return i.slice(); for (var n = (i[1] - i[0]) / 200, o = i[0], a = [], r = 0; r <= 200 && o < i[1]; r++)a.push(o), o += n; return a.push(i[1]), a; } function tx(t, e, i) { const n = t.option; const o = n.align; if (o != null && o !== "auto") return o; for (var a = { width: e.getWidth(), height: e.getHeight() }, r = n.orient === "horizontal" ? 1 : 0, s = [["left", "right", "width"], ["top", "bottom", "height"]], l = s[r], u = [0, null, 10], h = {}, c = 0; c < 3; c++)h[s[1 - r][c]] = u[c], h[l[c]] = c === 2 ? i[0] : n[l[c]]; const d = [["x", "width", 3], ["y", "height", 0]][r]; const f = ha(h, a, n.padding); return l[(f.margin[d[2]] || 0) + f[d[0]] + 0.5 * f[d[1]] < 0.5 * a[d[1]] ? 0 : 1]; } function ex(t) { return d(t || [], (e) => { t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null); }), t; } function ix(t, e, i, n) {
    return new pM({
      shape: { points: t }, draggable: !!i, cursor: e, drift: i, onmousemove(t) { mw(t.event); }, ondragend: n,
    });
  } function nx(t, e) { return t === 0 ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]]; } function ox(t, e, i, n) { return t ? [[0, -zO(e, BO(i, 0))], [GO, 0], [0, zO(e, BO(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]]; } function ax(t, e, i) { let n = VO / 2; const o = t.get("hoverLinkDataSize"); return o && (n = EO(o, e, i, !0) / 2), n; } function rx(t) { const e = t.get("hoverLinkOnHandle"); return !!(e == null ? t.get("realtime") : e); } function sx(t) { return t === "vertical" ? "ns-resize" : "ew-resize"; } function lx(t, e) { const i = t.inverse; (t.orient === "vertical" ? !i : i) && e.reverse(); } function ux(t) { Ci(t, "label", ["show"]); } function hx(t) { return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y))); } function cx(t) { return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y)); } function dx(t, e, i, n, o, a) { const r = []; const s = fl(e, n) ? e.getCalculationInfo("stackResultDimension") : n; const l = yx(e, s, t); const u = e.indicesOfNearest(s, l)[0]; r[o] = e.get(i, u), r[a] = e.get(n, u); let h = Fo(e.get(n, u)); return (h = Math.min(h, 20)) >= 0 && (r[a] = +r[a].toFixed(h)), r; } function fx(t, e) { const n = t.getData(); const o = t.coordinateSystem; if (e && !cx(e) && !y(e.coord) && o) { const a = o.dimensions; const r = px(e, n, o, t); if ((e = i(e)).type && qO[e.type] && r.baseAxis && r.valueAxis) { const s = jO(a, r.baseAxis.dim); const l = jO(a, r.valueAxis.dim); e.coord = qO[e.type](n, r.baseDataDim, r.valueDataDim, s, l), e.value = e.coord[l]; } else { for (var u = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis], h = 0; h < 2; h++)qO[u[h]] && (u[h] = yx(n, n.mapDimension(a[h]), u[h])); e.coord = u; } } return e; } function px(t, e, i, n) { const o = {}; return t.valueIndex != null || t.valueDim != null ? (o.valueDataDim = t.valueIndex != null ? e.getDimension(t.valueIndex) : t.valueDim, o.valueAxis = i.getAxis(gx(n, o.valueDataDim)), o.baseAxis = i.getOtherAxis(o.valueAxis), o.baseDataDim = e.mapDimension(o.baseAxis.dim)) : (o.baseAxis = n.getBaseAxis(), o.valueAxis = i.getOtherAxis(o.baseAxis), o.baseDataDim = e.mapDimension(o.baseAxis.dim), o.valueDataDim = e.mapDimension(o.valueAxis.dim)), o; } function gx(t, e) { const i = t.getData(); const n = i.dimensions; e = i.getDimension(e); for (let o = 0; o < n.length; o++) { const a = i.getDimensionInfo(n[o]); if (a.name === e) return a.coordDim; } } function mx(t, e) { return !(t && t.containData && e.coord && !hx(e)) || t.containData(e.coord); } function vx(t, e, i, n) { return n < 2 ? t.coord && t.coord[n] : t.value; } function yx(t, e, i) { if (i === "average") { let n = 0; let o = 0; return t.each(e, (t, e) => { isNaN(t) || (n += t, o++); }), n / o; } return i === "median" ? t.getMedian(e) : t.getDataExtent(e, !0)[i === "max" ? 1 : 0]; } function xx(t, e, i) { const n = e.coordinateSystem; t.each((o) => { let a; const r = t.getItemModel(o); const s = Bo(r.get("x"), i.getWidth()); const l = Bo(r.get("y"), i.getHeight()); if (isNaN(s) || isNaN(l)) { if (e.getMarkerPosition)a = e.getMarkerPosition(t.getValues(t.dimensions, o)); else if (n) { const u = t.get(n.dimensions[0], o); const h = t.get(n.dimensions[1], o); a = n.dataToPoint([u, h]); } } else a = [s, l]; isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), t.setItemLayout(o, a); }); } function _x(t, e, i) { let n; n = t ? f(t && t.dimensions, t => r({ name: t }, e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {})) : [{ name: "value", type: "float" }]; const o = new yA(n, i); let a = f(i.get("data"), v(fx, e)); return t && (a = g(a, v(mx, t))), o.initData(a, null, t ? vx : t => t.value), o; } function bx(t) { return !isNaN(t) && !isFinite(t); } function Sx(t, e, i, n) { const o = 1 - t; const a = n.dimensions[t]; return bx(e[o]) && bx(i[o]) && e[t] === i[t] && n.getAxis(a).containData(e[t]); } function Mx(t, e) { if (t.type === "cartesian2d") { const i = e[0].coord; const n = e[1].coord; if (i && n && (Sx(1, i, n, t) || Sx(0, i, n, t))) return !0; } return mx(t, e[0]) && mx(t, e[1]); } function Ix(t, e, i, n, o) { let a; const r = n.coordinateSystem; const s = t.getItemModel(e); const l = Bo(s.get("x"), o.getWidth()); const u = Bo(s.get("y"), o.getHeight()); if (isNaN(l) || isNaN(u)) { if (n.getMarkerPosition)a = n.getMarkerPosition(t.getValues(t.dimensions, e)); else { var h = r.dimensions; const c = t.get(h[0], e); const d = t.get(h[1], e); a = r.dataToPoint([c, d]); } if (r.type === "cartesian2d") { const f = r.getAxis("x"); const p = r.getAxis("y"); var h = r.dimensions; bx(t.get(h[0], e)) ? a[0] = f.toGlobalCoord(f.getExtent()[i ? 0 : 1]) : bx(t.get(h[1], e)) && (a[1] = p.toGlobalCoord(p.getExtent()[i ? 0 : 1])); }isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u); } else a = [l, u]; t.setItemLayout(e, a); } function Tx(t, e, i) { let n; n = t ? f(t && t.dimensions, t => r({ name: t }, e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {})) : [{ name: "value", type: "float" }]; const o = new yA(n, i); const a = new yA(n, i); const s = new yA([], i); let l = f(i.get("data"), v($O, e, t, i)); t && (l = g(l, v(Mx, t))); const u = t ? vx : function (t) { return t.value; }; return o.initData(f(l, t => t[0]), null, u), a.initData(f(l, t => t[1]), null, u), s.initData(f(l, t => t[2])), s.hasItemOption = !0, { from: o, to: a, line: s }; } function Ax(t) { return !isNaN(t) && !isFinite(t); } function Dx(t, e, i, n) { const o = 1 - t; return Ax(e[o]) && Ax(i[o]); } function Cx(t, e) { const i = e.coord[0]; const n = e.coord[1]; return !(t.type !== "cartesian2d" || !i || !n || !Dx(1, i, n, t) && !Dx(0, i, n, t)) || (mx(t, { coord: i, x: e.x0, y: e.y0 }) || mx(t, { coord: n, x: e.x1, y: e.y1 })); } function Lx(t, e, i, n, o) { let a; const r = n.coordinateSystem; const s = t.getItemModel(e); const l = Bo(s.get(i[0]), o.getWidth()); const u = Bo(s.get(i[1]), o.getHeight()); if (isNaN(l) || isNaN(u)) { if (n.getMarkerPosition)a = n.getMarkerPosition(t.getValues(i, e)); else { const h = [f = t.get(i[0], e), p = t.get(i[1], e)]; r.clampData && r.clampData(h, h), a = r.dataToPoint(h, !0); } if (r.type === "cartesian2d") { const c = r.getAxis("x"); const d = r.getAxis("y"); var f = t.get(i[0], e); var p = t.get(i[1], e); Ax(f) ? a[0] = c.toGlobalCoord(c.getExtent()[i[0] === "x0" ? 0 : 1]) : Ax(p) && (a[1] = d.toGlobalCoord(d.getExtent()[i[1] === "y0" ? 0 : 1])); }isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u); } else a = [l, u]; return a; } function kx(t, e, i) { let n; let o; const a = ["x0", "y0", "x1", "y1"]; t ? (n = f(t && t.dimensions, (t) => { const i = e.getData(); return r({ name: t }, i.getDimensionInfo(i.mapDimension(t)) || {}); }), o = new yA(f(a, (t, e) => ({ name: t, type: n[e % 2].type })), i)) : o = new yA(n = [{ name: "value", type: "float" }], i); let s = f(i.get("data"), v(JO, e, t, i)); t && (s = g(s, v(Cx, t))); const l = t ? function (t, e, i, n) { return t.coord[Math.floor(n / 2)][n % 2]; } : function (t) { return t.value; }; return o.initData(s, null, l), o.hasItemOption = !0, o; } function Px(t) { const e = t.type; const i = { number: "value", time: "time" }; if (i[e] && (t.axisType = i[e], delete t.type), Nx(t), Ox(t, "controlPosition")) { const n = t.controlStyle || (t.controlStyle = {}); Ox(n, "position") || (n.position = t.controlPosition), n.position !== "none" || Ox(n, "show") || (n.show = !1, delete n.position), delete t.controlPosition; }d(t.data || [], (t) => { w(t) && !y(t) && (!Ox(t, "value") && Ox(t, "name") && (t.value = t.name), Nx(t)); }); } function Nx(t) { const e = t.itemStyle || (t.itemStyle = {}); const i = e.emphasis || (e.emphasis = {}); const n = t.label || t.label || {}; const o = n.normal || (n.normal = {}); const a = { normal: 1, emphasis: 1 }; d(n, (t, e) => { a[e] || Ox(o, e) || (o[e] = t); }), i.label && !Ox(n, "emphasis") && (n.emphasis = i.label, delete i.label); } function Ox(t, e) { return t.hasOwnProperty(e); } function Ex(t, e) { return ha(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }, t.get("padding")); } function Rx(t, e, n, o) { return Un(t.get(e).replace(/^path:\/\//, ""), i(o || {}), new de(n[0], n[1], n[2], n[3]), "center"); } function zx(t, e, i, o, a, r) { const s = e.get("color"); a ? (a.setColor(s), i.add(a), r && r.onUpdate(a)) : ((a = $l(t.get("symbol"), -1, -1, 2, 2, s)).setStyle("strokeNoScale", !0), i.add(a), r && r.onCreate(a)); const l = e.getItemStyle(["color", "symbol", "symbolSize"]); a.setStyle(l), o = n({ rectHover: !0, z2: 100 }, o, !0); let u = t.get("symbolSize"); (u = u instanceof Array ? u.slice() : [+u, +u])[0] /= 2, u[1] /= 2, o.scale = u; const h = t.get("symbolOffset"); if (h) { const c = o.position = o.position || [0, 0]; c[0] += Bo(h[0], u[0]), c[1] += Bo(h[1], u[1]); } const d = t.get("symbolRotate"); return o.rotation = (d || 0) * Math.PI / 180 || 0, a.attr(o), a.updateTransform(), a; } function Bx(t, e, i, n, o) { if (!t.dragging) { const a = n.getModel("checkpointStyle"); const r = i.dataToCoord(n.getData().get(["value"], e)); o || !a.get("animation", !0) ? t.attr({ position: [r, 0] }) : (t.stopAnimation(!0), t.animateTo({ position: [r, 0] }, a.get("animationDuration", !0), a.get("animationEasing", !0))); } } function Vx(t) { return t.indexOf("my") === 0; } function Gx(t) { this.model = t; } function Fx(t) { this.model = t; } function Wx(t) { const e = {}; const i = []; const n = []; return t.eachRawSeries((t) => { const o = t.coordinateSystem; if (!o || o.type !== "cartesian2d" && o.type !== "polar")i.push(t); else { const a = o.getBaseAxis(); if (a.type === "category") { const r = `${a.dim}_${a.index}`; e[r] || (e[r] = { categoryAxis: a, valueAxis: o.getOtherAxis(a), series: [] }, n.push({ axisDim: a.dim, axisIndex: a.index })), e[r].series.push(t); } else i.push(t); } }), { seriesGroupByCategoryAxis: e, other: i, meta: n }; } function Hx(t) { const e = []; return d(t, (t, i) => { const n = t.categoryAxis; const o = t.valueAxis.dim; const a = [" "].concat(f(t.series, t => t.name)); const r = [n.model.getCategories()]; d(t.series, (t) => { r.push(t.getRawData().mapArray(o, t => t)); }); for (var s = [a.join(pE)], l = 0; l < r[0].length; l++) { for (var u = [], h = 0; h < r.length; h++)u.push(r[h][l]); s.push(u.join(pE)); }e.push(s.join("\n")); }), e.join(`\n\n${fE}\n\n`); } function Zx(t) { return f(t, (t) => { const e = t.getRawData(); const i = [t.name]; const n = []; return e.each(e.dimensions, function () { for (var t = arguments.length, o = arguments[t - 1], a = e.getName(o), r = 0; r < t - 1; r++)n[r] = arguments[r]; i.push((a ? a + pE : "") + n.join(pE)); }), i.join("\n"); }).join(`\n\n${fE}\n\n`); } function Ux(t) { const e = Wx(t); return { value: g([Hx(e.seriesGroupByCategoryAxis), Zx(e.other)], t => t.replace(/[\n\t\s]/g, "")).join(`\n\n${fE}\n\n`), meta: e.meta }; } function Xx(t) { return t.replace(/^\s\s*/, "").replace(/\s\s*$/, ""); } function jx(t) { if (t.slice(0, t.indexOf("\n")).indexOf(pE) >= 0) return !0; } function Yx(t) { for (var e = t.split(/\n+/g), i = [], n = f(Xx(e.shift()).split(gE), t => ({ name: t, data: [] })), o = 0; o < e.length; o++) { const a = Xx(e[o]).split(gE); i.push(a.shift()); for (let r = 0; r < a.length; r++)n[r] && (n[r].data[o] = a[r]); } return { series: n, categories: i }; } function qx(t) { for (var e = t.split(/\n+/g), i = Xx(e.shift()), n = [], o = 0; o < e.length; o++) { var a; let r = Xx(e[o]).split(gE); let s = ""; let l = !1; isNaN(r[0]) ? (l = !0, s = r[0], r = r.slice(1), n[o] = { name: s, value: [] }, a = n[o].value) : a = n[o] = []; for (let u = 0; u < r.length; u++)a.push(+r[u]); a.length === 1 && (l ? n[o].value = a[0] : n[o] = a[0]); } return { name: i, data: n }; } function Kx(t, e) { const i = { series: [] }; return d(t.split(new RegExp(`\n*${fE}\n*`, "g")), (t, n) => { if (jx(t)) { var o = Yx(t); const a = e[n]; const r = `${a.axisDim}Axis`; a && (i[r] = i[r] || [], i[r][a.axisIndex] = { data: o.categories }, i.series = i.series.concat(o.series)); } else { o = qx(t); i.series.push(o); } }), i; } function $x(t) { this._dom = null, this.model = t; } function Jx(t, e) { return f(t, (t, i) => { const n = e && e[i]; return w(n) && !y(n) ? (w(t) && !y(t) && (t = t.value), r({ value: t }, n)) : t; }); } function Qx(t, e) { const i = n_(t); mE(e, (e, n) => { for (var o = i.length - 1; o >= 0 && !i[o][n]; o--);if (o < 0) { const a = t.queryComponents({ mainType: "dataZoom", subType: "select", id: n })[0]; if (a) { const r = a.getPercentRange(); i[0][n] = { dataZoomId: n, start: r[0], end: r[1] }; } } }), i.push(e); } function t_(t) { const e = n_(t); const i = e[e.length - 1]; e.length > 1 && e.pop(); const n = {}; return mE(i, (t, i) => { for (let o = e.length - 1; o >= 0; o--) if (t = e[o][i]) { n[i] = t; break; } }), n; } function e_(t) { t[vE] = null; } function i_(t) { return n_(t).length; } function n_(t) { let e = t[vE]; return e || (e = t[vE] = [{}]), e; } function o_(t, e, i) { (this._brushController = new Rf(i.getZr())).on("brush", m(this._onBrush, this)).mount(), this._isZoomActive; } function a_(t) { const e = {}; return d(["xAxisIndex", "yAxisIndex"], (i) => { e[i] = t[i], e[i] == null && (e[i] = "all"), (!1 === e[i] || e[i] === "none") && (e[i] = []); }), e; } function r_(t, e) { t.setIconStatus("back", i_(e) > 1 ? "emphasis" : "normal"); } function s_(t, e, i, n, o) { let a = i._isZoomActive; n && n.type === "takeGlobalCursor" && (a = n.key === "dataZoomSelect" && n.dataZoomSelectActive), i._isZoomActive = a, t.setIconStatus("zoom", a ? "emphasis" : "normal"); const r = new hy(a_(t.option), e, { include: ["grid"] }); i._brushController.setPanels(r.makePanelOpts(o, t => (t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect"))).enableBrush(!!a && { brushType: "auto", brushStyle: { lineWidth: 0, fill: "rgba(0,0,0,0.2)" } }); } function l_(t) { this.model = t; } function u_(t) { return ME(t); } function h_() { if (!AE && DE) { AE = !0; const t = DE.styleSheets; t.length < 31 ? DE.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)"); } } function c_(t) { return parseInt(t, 10); } function d_(t, e) { h_(), this.root = t, this.storage = e; const i = document.createElement("div"); const n = document.createElement("div"); i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this.resize(); const o = e.delFromStorage; const a = e.addToStorage; e.delFromStorage = function (t) { o.call(e, t), t && t.onRemove && t.onRemove(n); }, e.addToStorage = function (t) { t.onAdd && t.onAdd(n), a.call(e, t); }, this._firstPaint = !0; } function f_(t) { return function () { Yw(`In IE8.0 VML mode painter not support method "${t}"`); }; } function p_(t) { return document.createElementNS(lR, t); } function g_(t) { return dR(1e4 * t) / 1e4; } function m_(t) { return t < yR && t > -yR; } function v_(t, e) { const i = e ? t.textFill : t.fill; return i != null && i !== cR; } function y_(t, e) { const i = e ? t.textStroke : t.stroke; return i != null && i !== cR; } function x_(t, e) { e && __(t, "transform", `matrix(${hR.call(e, ",")})`); } function __(t, e, i) { (!i || i.type !== "linear" && i.type !== "radial") && t.setAttribute(e, i); } function w_(t, e, i) { t.setAttributeNS("http://www.w3.org/1999/xlink", e, i); } function b_(t, e, i, n) { if (v_(e, i)) { let o = i ? e.textFill : e.fill; o = o === "transparent" ? cR : o, t.getAttribute("clip-path") !== "none" && o === cR && (o = "rgba(0, 0, 0, 0.002)"), __(t, "fill", o), __(t, "fill-opacity", e.fillOpacity != null ? e.fillOpacity * e.opacity : e.opacity); } else __(t, "fill", cR); if (y_(e, i)) { let a = i ? e.textStroke : e.stroke; __(t, "stroke", a = a === "transparent" ? cR : a), __(t, "stroke-width", (i ? e.textStrokeWidth : e.lineWidth) / (!i && e.strokeNoScale ? n.getLineScale() : 1)), __(t, "paint-order", i ? "stroke" : "fill"), __(t, "stroke-opacity", e.strokeOpacity != null ? e.strokeOpacity : e.opacity), e.lineDash ? (__(t, "stroke-dasharray", e.lineDash.join(",")), __(t, "stroke-dashoffset", dR(e.lineDashOffset || 0))) : __(t, "stroke-dasharray", ""), e.lineCap && __(t, "stroke-linecap", e.lineCap), e.lineJoin && __(t, "stroke-linejoin", e.lineJoin), e.miterLimit && __(t, "stroke-miterlimit", e.miterLimit); } else __(t, "stroke", cR); } function S_(t) { for (var e = [], i = t.data, n = t.len(), o = 0; o < n;) { let a = ""; let r = 0; switch (i[o++]) { case uR.M: a = "M", r = 2; break; case uR.L: a = "L", r = 2; break; case uR.Q: a = "Q", r = 4; break; case uR.C: a = "C", r = 6; break; case uR.A: var s = i[o++]; var l = i[o++]; var u = i[o++]; var h = i[o++]; var c = i[o++]; var d = i[o++]; var f = i[o++]; var p = i[o++]; var g = Math.abs(d); var m = m_(g - mR) && !m_(g); var v = !1; v = g >= mR || !m_(g) && (d > -gR && d < 0 || d > gR) == !!p; var y = g_(s + u * pR(c)); var x = g_(l + h * fR(c)); m && (d = p ? mR - 1e-4 : 1e-4 - mR, v = !0, o === 9 && e.push("M", y, x)); var _ = g_(s + u * pR(c + d)); var w = g_(l + h * fR(c + d)); e.push("A", g_(u), g_(h), dR(f * vR), +v, +p, _, w); break; case uR.Z: a = "Z"; break; case uR.R: var _ = g_(i[o++]); var w = g_(i[o++]); var b = g_(i[o++]); var S = g_(i[o++]); e.push("M", _, w, "L", _ + b, w, "L", _ + b, w + S, "L", _, w + S, "L", _, w); }a && e.push(a); for (let M = 0; M < r; M++)e.push(g_(i[o++])); } return e.join(" "); } function M_(t) { return t === "middle" ? "middle" : t === "bottom" ? "after-edge" : "hanging"; } function I_() {} function T_(t, e, i, n) { for (let o = 0, a = e.length, r = 0, s = 0; o < a; o++) { const l = e[o]; if (l.removed) { for (var u = [], h = s; h < s + l.count; h++)u.push(h); l.indices = u, s += l.count; } else { for (var u = [], h = r; h < r + l.count; h++)u.push(h); l.indices = u, r += l.count, l.added || (s += l.count); } } return e; } function A_(t) { return { newPos: t.newPos, components: t.components.slice(0) }; } function D_(t, e, i, n, o) { this._zrId = t, this._svgRoot = e, this._tagNames = typeof i === "string" ? [i] : i, this._markLabel = n, this._domName = o || "_dom", this.nextId = 0; } function C_(t, e) { D_.call(this, t, e, ["linearGradient", "radialGradient"], "__gradient_in_use__"); } function L_(t, e) { D_.call(this, t, e, "clipPath", "__clippath_in_use__"); } function k_(t, e) { D_.call(this, t, e, ["filter"], "__filter_in_use__", "_shadowDom"); } function P_(t) { return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY || t.textShadowBlur || t.textShadowOffsetX || t.textShadowOffsetY); } function N_(t) { return parseInt(t, 10); } function O_(t) { return t instanceof kn ? xR : t instanceof fi ? _R : t instanceof rM ? wR : xR; } function E_(t, e) { return e && t && e.parentNode !== t; } function R_(t, e, i) { if (E_(t, e) && i) { const n = i.nextSibling; n ? t.insertBefore(e, n) : t.appendChild(e); } } function z_(t, e) { if (E_(t, e)) { const i = t.firstChild; i ? t.insertBefore(e, i) : t.appendChild(e); } } function B_(t, e) { e && t && e.parentNode === t && t.removeChild(e); } function V_(t) { return t.__textSvgEl; } function G_(t) { return t.__svgEl; } function F_(t) { return function () { Yw(`In SVG mode painter not support method "${t}"`); }; } let W_ = 2311; var H_ = function () { return W_++; }; let Z_ = {}; var U_ = Z_ = typeof wx === "object" && typeof wx.getSystemInfoSync === "function" ? {
    browser: {}, os: {}, node: !1, wxa: !0, canvasSupported: !0, svgSupported: !1, touchEventsSupported: !0, domSupported: !1,
  } : typeof document === "undefined" && typeof self !== "undefined" ? {
    browser: {}, os: {}, node: !1, worker: !0, canvasSupported: !0, domSupported: !1,
  } : typeof navigator === "undefined" ? {
    browser: {}, os: {}, node: !0, worker: !1, canvasSupported: !0, svgSupported: !0, domSupported: !1,
  } : (function (t) {
    const e = {}; const i = {}; const n = t.match(/Firefox\/([\d.]+)/); const o = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/); const a = t.match(/Edge\/([\d.]+)/); const r = /micromessenger/i.test(t); return n && (i.firefox = !0, i.version = n[1]), o && (i.ie = !0, i.version = o[1]), a && (i.edge = !0, i.version = a[1]), r && (i.weChat = !0), {
      browser: i, os: e, node: !1, canvasSupported: !!document.createElement("canvas").getContext, svgSupported: typeof SVGRect !== "undefined", touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge, pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 11), domSupported: typeof document !== "undefined",
    };
  }(navigator.userAgent)); var X_ = {
    "[object Function]": 1, "[object RegExp]": 1, "[object Date]": 1, "[object Error]": 1, "[object CanvasGradient]": 1, "[object CanvasPattern]": 1, "[object Image]": 1, "[object Canvas]": 1,
  }; var j_ = {
    "[object Int8Array]": 1, "[object Uint8Array]": 1, "[object Uint8ClampedArray]": 1, "[object Int16Array]": 1, "[object Uint16Array]": 1, "[object Int32Array]": 1, "[object Uint32Array]": 1, "[object Float32Array]": 1, "[object Float64Array]": 1,
  }; var Y_ = Object.prototype.toString; const q_ = Array.prototype; var K_ = q_.forEach; var $_ = q_.filter; var J_ = q_.slice; var Q_ = q_.map; var tw = q_.reduce; var ew = {}; var iw = function () { return ew.createCanvas(); }; ew.createCanvas = function () { return document.createElement("canvas"); }; let nw; var ow = "__ec_primitive__"; E.prototype = {
    constructor: E, get(t) { return this.data.hasOwnProperty(t) ? this.data[t] : null; }, set(t, e) { return this.data[t] = e; }, each(t, e) { void 0 !== e && (t = m(t, e)); for (const i in this.data) this.data.hasOwnProperty(i) && t(this.data[i], i); }, removeKey(t) { delete this.data[t]; },
  }; const aw = (Object.freeze || Object)({
    $override: e, clone: i, merge: n, mergeAll: o, extend: a, defaults: r, createCanvas: iw, getContext: s, indexOf: l, inherits: u, mixin: h, isArrayLike: c, each: d, map: f, reduce: p, filter: g, find(t, e, i) { if (t && e) for (let n = 0, o = t.length; n < o; n++) if (e.call(i, t[n], n, t)) return t[n]; }, bind: m, curry: v, isArray: y, isFunction: x, isString: _, isObject: w, isBuiltInObject: b, isTypedArray: S, isDom: M, eqNaN: I, retrieve: T, retrieve2: A, retrieve3: D, slice: C, normalizeCssArray: L, assert: k, trim: P, setAsPrimitive: N, isPrimitive: O, createHashMap: R, concatArray: z, noop: B,
  }); var rw = typeof Float32Array === "undefined" ? Array : Float32Array; const sw = X; const lw = j; var uw = K; var hw = $; const cw = (Object.freeze || Object)({
    create: V, copy: G, clone: F, set: W, add: H, scaleAndAdd: Z, sub: U, len: X, length: sw, lenSquare: j, lengthSquare: lw, mul(t, e, i) { return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t; }, div(t, e, i) { return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t; }, dot(t, e) { return t[0] * e[0] + t[1] * e[1]; }, scale: Y, normalize: q, distance: K, dist: uw, distanceSquare: $, distSquare: hw, negate(t, e) { return t[0] = -e[0], t[1] = -e[1], t; }, lerp: J, applyTransform: Q, min: tt, max: et,
  }); it.prototype = {
    constructor: it, _dragStart(t) { const e = t.target; e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(nt(e, t), "dragstart", t.event)); }, _drag(t) { const e = this._draggingTarget; if (e) { const i = t.offsetX; const n = t.offsetY; const o = i - this._x; const a = n - this._y; this._x = i, this._y = n, e.drift(o, a, t), this.dispatchToElement(nt(e, t), "drag", t.event); const r = this.findHover(i, n, e).target; const s = this._dropTarget; this._dropTarget = r, e !== r && (s && r !== s && this.dispatchToElement(nt(s, t), "dragleave", t.event), r && r !== s && this.dispatchToElement(nt(r, t), "dragenter", t.event)); } }, _dragEnd(t) { const e = this._draggingTarget; e && (e.dragging = !1), this.dispatchToElement(nt(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(nt(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null; },
  }; const dw = Array.prototype.slice; var fw = function (t) { this._$handlers = {}, this._$eventProcessor = t; }; fw.prototype = {
    constructor: fw, one(t, e, i, n) { return at(this, t, e, i, n, !0); }, on(t, e, i, n) { return at(this, t, e, i, n, !1); }, isSilent(t) { const e = this._$handlers; return !e[t] || !e[t].length; }, off(t, e) { const i = this._$handlers; if (!t) return this._$handlers = {}, this; if (e) { if (i[t]) { for (var n = [], o = 0, a = i[t].length; o < a; o++)i[t][o].h !== e && n.push(i[t][o]); i[t] = n; }i[t] && i[t].length === 0 && delete i[t]; } else delete i[t]; return this; }, trigger(t) { const e = this._$handlers[t]; const i = this._$eventProcessor; if (e) { let n = arguments; const o = n.length; o > 3 && (n = dw.call(n, 1)); for (let a = e.length, r = 0; r < a;) { const s = e[r]; if (i && i.filter && s.query != null && !i.filter(t, s.query))r++; else { switch (o) { case 1: s.h.call(s.ctx); break; case 2: s.h.call(s.ctx, n[1]); break; case 3: s.h.call(s.ctx, n[1], n[2]); break; default: s.h.apply(s.ctx, n); }s.one ? (e.splice(r, 1), a--) : r++; } } } return i && i.afterTrigger && i.afterTrigger(t), this; }, triggerWithContext(t) { const e = this._$handlers[t]; const i = this._$eventProcessor; if (e) { let n = arguments; const o = n.length; o > 4 && (n = dw.call(n, 1, n.length - 1)); for (let a = n[n.length - 1], r = e.length, s = 0; s < r;) { const l = e[s]; if (i && i.filter && l.query != null && !i.filter(t, l.query))s++; else { switch (o) { case 1: l.h.call(a); break; case 2: l.h.call(a, n[1]); break; case 3: l.h.call(a, n[1], n[2]); break; default: l.h.apply(a, n); }l.one ? (e.splice(s, 1), r--) : s++; } } } return i && i.afterTrigger && i.afterTrigger(t), this; },
  }; var pw = typeof window !== "undefined" && !!window.addEventListener; var gw = /^(?:mouse|pointer|contextmenu|drag|drop)|click/; var mw = pw ? function (t) { t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0; } : function (t) { t.returnValue = !1, t.cancelBubble = !0; }; const vw = function () { this._track = []; }; vw.prototype = {
    constructor: vw,
    recognize(t, e, i) { return this._doTrack(t, e, i), this._recognize(t); },
    clear() { return this._track.length = 0, this; },
    _doTrack(t, e, i) {
      const n = t.touches; if (n) {
        for (var o = {
            points: [], touches: [], target: e, event: t,
          }, a = 0, r = n.length; a < r; a++) { const s = n[a]; const l = st(i, s, {}); o.points.push([l.zrX, l.zrY]), o.touches.push(s); } this._track.push(o);
      }
    },
    _recognize(t) { for (const e in yw) if (yw.hasOwnProperty(e)) { const i = yw[e](this._track, t); if (i) return i; } },
  }; var yw = { pinch(t, e) { const i = t.length; if (i) { const n = (t[i - 1] || {}).points; const o = (t[i - 2] || {}).points || n; if (o && o.length > 1 && n && n.length > 1) { let a = ft(n) / ft(o); !isFinite(a) && (a = 1), e.pinchScale = a; const r = pt(n); return e.pinchX = r[0], e.pinchY = r[1], { type: "pinch", target: t[0].target, event: e }; } } } }; var xw = "silent"; vt.prototype.dispose = function () {}; const _w = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"]; const ww = function (t, e, i, n) { fw.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new vt(), this.proxy = null, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, this._gestureMgr, it.call(this), this.setHandlerProxy(i); }; ww.prototype = {
    constructor: ww, setHandlerProxy(t) { this.proxy && this.proxy.dispose(), t && (d(_w, function (e) { t.on && t.on(e, this[e], this); }, this), t.handler = this), this.proxy = t; }, mousemove(t) { const e = t.zrX; const i = t.zrY; let n = this._hovered; let o = n.target; o && !o.__zr && (o = (n = this.findHover(n.x, n.y)).target); const a = this._hovered = this.findHover(e, i); const r = a.target; const s = this.proxy; s.setCursor && s.setCursor(r ? r.cursor : "default"), o && r !== o && this.dispatchToElement(n, "mouseout", t), this.dispatchToElement(a, "mousemove", t), r && r !== o && this.dispatchToElement(a, "mouseover", t); }, mouseout(t) { this.dispatchToElement(this._hovered, "mouseout", t); let e; let i = t.toElement || t.relatedTarget; do { i = i && i.parentNode; } while (i && i.nodeType !== 9 && !(e = i === this.painterRoot));!e && this.trigger("globalout", { event: t }); }, resize(t) { this._hovered = {}; }, dispatch(t, e) { const i = this[t]; i && i.call(this, e); }, dispose() { this.proxy.dispose(), this.storage = this.proxy = this.painter = null; }, setCursorStyle(t) { const e = this.proxy; e.setCursor && e.setCursor(t); }, dispatchToElement(t, e, i) { let n = (t = t || {}).target; if (!n || !n.silent) { for (var o = `on${e}`, a = gt(e, t, i); n && (n[o] && (a.cancelBubble = n[o].call(n, a)), n.trigger(e, a), n = n.parent, !a.cancelBubble););a.cancelBubble || (this.trigger(e, a), this.painter && this.painter.eachOtherLayer((t) => { typeof t[o] === "function" && t[o].call(t, a), t.trigger && t.trigger(e, a); })); } }, findHover(t, e, i) { for (var n = this.storage.getDisplayList(), o = { x: t, y: e }, a = n.length - 1; a >= 0; a--) { var r; if (n[a] !== i && !n[a].ignore && (r = yt(n[a], t, e)) && (!o.topTarget && (o.topTarget = n[a]), r !== xw)) { o.target = n[a]; break; } } return o; }, processGesture(t, e) { this._gestureMgr || (this._gestureMgr = new vw()); const i = this._gestureMgr; e === "start" && i.clear(); const n = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom); if (e === "end" && i.clear(), n) { const o = n.type; t.gestureEvent = o, this.dispatchToElement({ target: n.target }, o, n.event); } },
  }, d(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], (t) => { ww.prototype[t] = function (e) { const i = this.findHover(e.zrX, e.zrY); const n = i.target; if (t === "mousedown") this._downEl = n, this._downPoint = [e.zrX, e.zrY], this._upEl = n; else if (t === "mouseup") this._upEl = n; else if (t === "click") { if (this._downEl !== this._upEl || !this._downPoint || uw(this._downPoint, [e.zrX, e.zrY]) > 4) return; this._downPoint = null; } this.dispatchToElement(i, t, e); }; }), h(ww, fw), h(ww, it); var bw = typeof Float32Array === "undefined" ? Array : Float32Array; const Sw = (Object.freeze || Object)({
    create: xt, identity: _t, copy: wt, mul: bt, translate: St, rotate: Mt, scale: It, invert: Tt, clone: At,
  }); const Mw = _t; var Iw = 5e-5; var Tw = function (t) { (t = t || {}).position || (this.position = [0, 0]), t.rotation == null && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null; }; const Aw = Tw.prototype; Aw.transform = null, Aw.needLocalTransform = function () { return Dt(this.rotation) || Dt(this.position[0]) || Dt(this.position[1]) || Dt(this.scale[0] - 1) || Dt(this.scale[1] - 1); }; const Dw = []; Aw.updateTransform = function () { const t = this.parent; const e = t && t.transform; const i = this.needLocalTransform(); let n = this.transform; if (i || e) { n = n || xt(), i ? this.getLocalTransform(n) : Mw(n), e && (i ? bt(n, t.transform, n) : wt(n, t.transform)), this.transform = n; const o = this.globalScaleRatio; if (o != null && o !== 1) { this.getGlobalScale(Dw); const a = Dw[0] < 0 ? -1 : 1; const r = Dw[1] < 0 ? -1 : 1; const s = ((Dw[0] - a) * o + a) / Dw[0] || 0; const l = ((Dw[1] - r) * o + r) / Dw[1] || 0; n[0] *= s, n[1] *= s, n[2] *= l, n[3] *= l; } this.invTransform = this.invTransform || xt(), Tt(this.invTransform, n); } else n && Mw(n); }, Aw.getLocalTransform = function (t) { return Tw.getLocalTransform(this, t); }, Aw.setTransform = function (t) { const e = this.transform; const i = t.dpr || 1; e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0); }, Aw.restoreTransform = function (t) { const e = t.dpr || 1; t.setTransform(e, 0, 0, e, 0, 0); }; const Cw = []; const Lw = xt(); Aw.setLocalTransform = function (t) { if (t) { let e = t[0] * t[0] + t[1] * t[1]; let i = t[2] * t[2] + t[3] * t[3]; const n = this.position; const o = this.scale; Dt(e - 1) && (e = Math.sqrt(e)), Dt(i - 1) && (i = Math.sqrt(i)), t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), n[0] = t[4], n[1] = t[5], o[0] = e, o[1] = i, this.rotation = Math.atan2(-t[1] / i, t[0] / e); } }, Aw.decomposeTransform = function () { if (this.transform) { const t = this.parent; let e = this.transform; t && t.transform && (bt(Cw, t.invTransform, e), e = Cw); const i = this.origin; i && (i[0] || i[1]) && (Lw[4] = i[0], Lw[5] = i[1], bt(Cw, e, Lw), Cw[4] -= i[0], Cw[5] -= i[1], e = Cw), this.setLocalTransform(e); } }, Aw.getGlobalScale = function (t) { const e = this.transform; return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t); }, Aw.transformCoordToLocal = function (t, e) { const i = [t, e]; const n = this.invTransform; return n && Q(i, i, n), i; }, Aw.transformCoordToGlobal = function (t, e) { const i = [t, e]; const n = this.transform; return n && Q(i, i, n), i; }, Tw.getLocalTransform = function (t, e) { Mw(e = e || []); const i = t.origin; const n = t.scale || [1, 1]; const o = t.rotation || 0; const a = t.position || [0, 0]; return i && (e[4] -= i[0], e[5] -= i[1]), It(e, e, n), o && Mt(e, e, o), i && (e[4] += i[0], e[5] += i[1]), e[4] += a[0], e[5] += a[1], e; }; var kw = {
    linear(t) { return t; }, quadraticIn(t) { return t * t; }, quadraticOut(t) { return t * (2 - t); }, quadraticInOut(t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }, cubicIn(t) { return t * t * t; }, cubicOut(t) { return --t * t * t + 1; }, cubicInOut(t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }, quarticIn(t) { return t * t * t * t; }, quarticOut(t) { return 1 - --t * t * t * t; }, quarticInOut(t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }, quinticIn(t) { return t * t * t * t * t; }, quinticOut(t) { return --t * t * t * t * t + 1; }, quinticInOut(t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }, sinusoidalIn(t) { return 1 - Math.cos(t * Math.PI / 2); }, sinusoidalOut(t) { return Math.sin(t * Math.PI / 2); }, sinusoidalInOut(t) { return 0.5 * (1 - Math.cos(Math.PI * t)); }, exponentialIn(t) { return t === 0 ? 0 : Math.pow(1024, t - 1); }, exponentialOut(t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t); }, exponentialInOut(t) { return t === 0 ? 0 : t === 1 ? 1 : (t *= 2) < 1 ? 0.5 * Math.pow(1024, t - 1) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))); }, circularIn(t) { return 1 - Math.sqrt(1 - t * t); }, circularOut(t) { return Math.sqrt(1 - --t * t); }, circularInOut(t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }, elasticIn(t) { let e; let i = 0.1; return t === 0 ? 0 : t === 1 ? 1 : (!i || i < 1 ? (i = 1, e = 0.1) : e = 0.4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / 0.4)); }, elasticOut(t) { let e; let i = 0.1; return t === 0 ? 0 : t === 1 ? 1 : (!i || i < 1 ? (i = 1, e = 0.1) : e = 0.4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / 0.4) + 1); }, elasticInOut(t) { let e; let i = 0.1; return t === 0 ? 0 : t === 1 ? 1 : (!i || i < 1 ? (i = 1, e = 0.1) : e = 0.4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / 0.4) * -0.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / 0.4) * 0.5 + 1); }, backIn(t) { const e = 1.70158; return t * t * ((e + 1) * t - e); }, backOut(t) { const e = 1.70158; return --t * t * ((e + 1) * t + e) + 1; }, backInOut(t) { const e = 2.5949095; return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2); }, bounceIn(t) { return 1 - kw.bounceOut(1 - t); }, bounceOut(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }, bounceInOut(t) { return t < 0.5 ? 0.5 * kw.bounceIn(2 * t) : 0.5 * kw.bounceOut(2 * t - 1) + 0.5; },
  }; Ct.prototype = {
    constructor: Ct, step(t, e) { if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) this._pausedTime += e; else { let i = (t - this._startTime - this._pausedTime) / this._life; if (!(i < 0)) { i = Math.min(i, 1); const n = this.easing; const o = typeof n === "string" ? kw[n] : n; const a = typeof o === "function" ? o(i) : i; return this.fire("frame", a), i === 1 ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null; } } }, restart(t) { const e = (t - this._startTime - this._pausedTime) % this._life; this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1; }, fire(t, e) { this[t = `on${t}`] && this[t](this._target, e); }, pause() { this._paused = !0; }, resume() { this._paused = !1; },
  }; const Pw = function () { this.head = null, this.tail = null, this._len = 0; }; const Nw = Pw.prototype; Nw.insert = function (t) { const e = new Ow(t); return this.insertEntry(e), e; }, Nw.insertEntry = function (t) { this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++; }, Nw.remove = function (t) { const e = t.prev; const i = t.next; e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--; }, Nw.len = function () { return this._len; }, Nw.clear = function () { this.head = this.tail = null, this._len = 0; }; var Ow = function (t) { this.value = t, this.next, this.prev; }; const Ew = function (t) { this._list = new Pw(), this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null; }; const Rw = Ew.prototype; Rw.put = function (t, e) { const i = this._list; const n = this._map; let o = null; if (n[t] == null) { const a = i.len(); let r = this._lastRemovedEntry; if (a >= this._maxSize && a > 0) { const s = i.head; i.remove(s), delete n[s.key], o = s.value, this._lastRemovedEntry = s; }r ? r.value = e : r = new Ow(e), r.key = t, i.insertEntry(r), n[t] = r; } return o; }, Rw.get = function (t) { const e = this._map[t]; const i = this._list; if (e != null) return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value; }, Rw.clear = function () { this._list.clear(), this._map = {}; }; var zw = {
    transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1],
  }; var Bw = new Ew(20); var Vw = null; const Gw = Ut; const Fw = Xt; const Ww = (Object.freeze || Object)({
    parse: Gt, lift: Ht, toHex: Zt, fastLerp: Ut, fastMapToColor: Gw, lerp: Xt, mapToColor: Fw, modifyHSL: jt, modifyAlpha: Yt, stringify: qt,
  }); var Hw = Array.prototype.slice; const Zw = function (t, e, i, n) { this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || Kt, this._setter = n || $t, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []; }; Zw.prototype = {
    when(t, e) { const i = this._tracks; for (const n in e) if (e.hasOwnProperty(n)) { if (!i[n]) { i[n] = []; const o = this._getter(this._target, n); if (o == null) continue; t !== 0 && i[n].push({ time: 0, value: ae(o) }); }i[n].push({ time: t, value: e[n] }); } return this; }, during(t) { return this._onframeList.push(t), this; }, pause() { for (let t = 0; t < this._clipList.length; t++) this._clipList[t].pause(); this._paused = !0; }, resume() { for (let t = 0; t < this._clipList.length; t++) this._clipList[t].resume(); this._paused = !1; }, isPaused() { return !!this._paused; }, _doneCallback() { this._tracks = {}, this._clipList.length = 0; for (let t = this._doneList, e = t.length, i = 0; i < e; i++)t[i].call(this); }, start(t, e) { let i; const n = this; let o = 0; for (const a in this._tracks) if (this._tracks.hasOwnProperty(a)) { const r = le(this, t, () => { --o || n._doneCallback(); }, this._tracks[a], a, e); r && (this._clipList.push(r), o++, this.animation && this.animation.addClip(r), i = r); } if (i) { const s = i.onframe; i.onframe = function (t, e) { s(t, e); for (let i = 0; i < n._onframeList.length; i++)n._onframeList[i](t, e); }; } return o || this._doneCallback(), this; }, stop(t) { for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) { const o = e[n]; t && o.onframe(this._target, 1), i && i.removeClip(o); }e.length = 0; }, delay(t) { return this._delay = t, this; }, done(t) { return t && this._doneList.push(t), this; }, getClips() { return this._clipList; },
  }; let Uw = 1; typeof window !== "undefined" && (Uw = Math.max(window.devicePixelRatio || 1, 1)); const Xw = Uw; const jw = function () {}; var Yw = jw; const qw = function () { this.animators = []; }; qw.prototype = {
    constructor: qw, animate(t, e) { let i; let n = !1; const o = this; const a = this.__zr; if (t) { const r = t.split("."); let s = o; n = r[0] === "shape"; for (let u = 0, h = r.length; u < h; u++)s && (s = s[r[u]]); s && (i = s); } else i = o; if (i) { const c = o.animators; const d = new Zw(i, e); return d.during((t) => { o.dirty(n); }).done(() => { c.splice(l(c, d), 1); }), c.push(d), a && a.animation.addAnimator(d), d; }Yw(`Property "${t}" is not existed in element ${o.id}`); }, stopAnimation(t) { for (var e = this.animators, i = e.length, n = 0; n < i; n++)e[n].stop(t); return e.length = 0, this; }, animateTo(t, e, i, n, o, a) { ue(this, t, e, i, n, o, a); }, animateFrom(t, e, i, n, o, a) { ue(this, t, e, i, n, o, a, !0); },
  }; var Kw = function (t) { Tw.call(this, t), fw.call(this, t), qw.call(this, t), this.id = t.id || H_(); }; Kw.prototype = {
    type: "element", name: "", __zr: null, ignore: !1, clipPath: null, isGroup: !1, drift(t, e) { switch (this.draggable) { case "horizontal": e = 0; break; case "vertical": t = 0; } let i = this.transform; i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1); }, beforeUpdate() {}, afterUpdate() {}, update() { this.updateTransform(); }, traverse(t, e) {}, attrKV(t, e) { if (t === "position" || t === "scale" || t === "origin") { if (e) { let i = this[t]; i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]; } } else this[t] = e; }, hide() { this.ignore = !0, this.__zr && this.__zr.refresh(); }, show() { this.ignore = !1, this.__zr && this.__zr.refresh(); }, attr(t, e) { if (typeof t === "string") this.attrKV(t, e); else if (w(t)) for (const i in t)t.hasOwnProperty(i) && this.attrKV(i, t[i]); return this.dirty(!1), this; }, setClipPath(t) { const e = this.__zr; e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1); }, removeClipPath() { const t = this.clipPath; t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1)); }, addSelfToZr(t) { this.__zr = t; const e = this.animators; if (e) for (let i = 0; i < e.length; i++)t.animation.addAnimator(e[i]); this.clipPath && this.clipPath.addSelfToZr(t); }, removeSelfFromZr(t) { this.__zr = null; const e = this.animators; if (e) for (let i = 0; i < e.length; i++)t.animation.removeAnimator(e[i]); this.clipPath && this.clipPath.removeSelfFromZr(t); },
  }, h(Kw, qw), h(Kw, Tw), h(Kw, fw); const $w = Q; const Jw = Math.min; const Qw = Math.max; de.prototype = {
    constructor: de,
    union(t) { const e = Jw(t.x, this.x); const i = Jw(t.y, this.y); this.width = Qw(t.x + t.width, this.x + this.width) - e, this.height = Qw(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i; },
    applyTransform: (function () { const t = []; const e = []; const i = []; const n = []; return function (o) { if (o) { t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this.height, $w(t, t, o), $w(e, e, o), $w(i, i, o), $w(n, n, o), this.x = Jw(t[0], e[0], i[0], n[0]), this.y = Jw(t[1], e[1], i[1], n[1]); const a = Qw(t[0], e[0], i[0], n[0]); const r = Qw(t[1], e[1], i[1], n[1]); this.width = a - this.x, this.height = r - this.y; } }; }()),
    calculateTransform(t) { const e = this; const i = t.width / e.width; const n = t.height / e.height; const o = xt(); return St(o, o, [-e.x, -e.y]), It(o, o, [i, n]), St(o, o, [t.x, t.y]), o; },
    intersect(t) { if (!t) return !1; t instanceof de || (t = de.create(t)); const e = this; const i = e.x; const n = e.x + e.width; const o = e.y; const a = e.y + e.height; const r = t.x; const s = t.x + t.width; const l = t.y; const u = t.y + t.height; return !(n < r || s < i || a < l || u < o); },
    contain(t, e) { const i = this; return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height; },
    clone() { return new de(this.x, this.y, this.width, this.height); },
    copy(t) { this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height; },
    plain() {
      return {
        x: this.x, y: this.y, width: this.width, height: this.height,
      };
    },
  }, de.create = function (t) { return new de(t.x, t.y, t.width, t.height); }; var tb = function (t) { t = t || {}, Kw.call(this, t); for (const e in t)t.hasOwnProperty(e) && (this[e] = t[e]); this._children = [], this.__storage = null, this.__dirty = !0; }; tb.prototype = {
    constructor: tb, isGroup: !0, type: "group", silent: !1, children() { return this._children.slice(); }, childAt(t) { return this._children[t]; }, childOfName(t) { for (let e = this._children, i = 0; i < e.length; i++) if (e[i].name === t) return e[i]; }, childCount() { return this._children.length; }, add(t) { return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this; }, addBefore(t, e) { if (t && t !== this && t.parent !== this && e && e.parent === this) { const i = this._children; const n = i.indexOf(e); n >= 0 && (i.splice(n, 0, t), this._doAdd(t)); } return this; }, _doAdd(t) { t.parent && t.parent.remove(t), t.parent = this; const e = this.__storage; const i = this.__zr; e && e !== t.__storage && (e.addToStorage(t), t instanceof tb && t.addChildrenToStorage(e)), i && i.refresh(); }, remove(t) { const e = this.__zr; const i = this.__storage; const n = this._children; const o = l(n, t); return o < 0 ? this : (n.splice(o, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof tb && t.delChildrenFromStorage(i)), e && e.refresh(), this); }, removeAll() { let t; let e; const i = this._children; const n = this.__storage; for (e = 0; e < i.length; e++)t = i[e], n && (n.delFromStorage(t), t instanceof tb && t.delChildrenFromStorage(n)), t.parent = null; return i.length = 0, this; }, eachChild(t, e) { for (let i = this._children, n = 0; n < i.length; n++) { const o = i[n]; t.call(e, o, n); } return this; }, traverse(t, e) { for (let i = 0; i < this._children.length; i++) { const n = this._children[i]; t.call(e, n), n.type === "group" && n.traverse(t, e); } return this; }, addChildrenToStorage(t) { for (let e = 0; e < this._children.length; e++) { const i = this._children[e]; t.addToStorage(i), i instanceof tb && i.addChildrenToStorage(t); } }, delChildrenFromStorage(t) { for (let e = 0; e < this._children.length; e++) { const i = this._children[e]; t.delFromStorage(i), i instanceof tb && i.delChildrenFromStorage(t); } }, dirty() { return this.__dirty = !0, this.__zr && this.__zr.refresh(), this; }, getBoundingRect(t) { for (var e = null, i = new de(0, 0, 0, 0), n = t || this._children, o = [], a = 0; a < n.length; a++) { const r = n[a]; if (!r.ignore && !r.invisible) { const s = r.getBoundingRect(); const l = r.getLocalTransform(o); l ? (i.copy(s), i.applyTransform(l), (e = e || i.clone()).union(i)) : (e = e || s.clone()).union(s); } } return e || i; },
  }, u(tb, Kw); var eb = 32; var ib = 7; const nb = function () { this._roots = [], this._displayList = [], this._displayListLen = 0; }; nb.prototype = {
    constructor: nb, traverse(t, e) { for (let i = 0; i < this._roots.length; i++) this._roots[i].traverse(t, e); }, getDisplayList(t, e) { return e = e || !1, t && this.updateDisplayList(e), this._displayList; }, updateDisplayList(t) { this._displayListLen = 0; for (var e = this._roots, i = this._displayList, n = 0, o = e.length; n < o; n++) this._updateAndAddDisplayable(e[n], null, t); i.length = this._displayListLen, U_.canvasSupported && _e(i, we); }, _updateAndAddDisplayable(t, e, i) { if (!t.ignore || i) { t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate(); const n = t.clipPath; if (n) { e = e ? e.slice() : []; for (let o = n, a = t; o;)o.parent = a, o.updateTransform(), e.push(o), a = o, o = o.clipPath; } if (t.isGroup) { for (let r = t._children, s = 0; s < r.length; s++) { const l = r[s]; t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i); }t.__dirty = !1; } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t; } }, addRoot(t) { t.__storage !== this && (t instanceof tb && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t)); }, delRoot(t) { if (t == null) { for (i = 0; i < this._roots.length; i++) { const e = this._roots[i]; e instanceof tb && e.delChildrenFromStorage(this); } return this._roots = [], this._displayList = [], void (this._displayListLen = 0); } if (t instanceof Array) for (var i = 0, n = t.length; i < n; i++) this.delRoot(t[i]); else { const o = l(this._roots, t); o >= 0 && (this.delFromStorage(t), this._roots.splice(o, 1), t instanceof tb && t.delChildrenFromStorage(this)); } }, addToStorage(t) { return t && (t.__storage = this, t.dirty(!1)), this; }, delFromStorage(t) { return t && (t.__storage = null), this; }, dispose() { this._renderList = this._roots = null; }, displayableSortFunc: we,
  }; const ob = {
    shadowBlur: 1, shadowOffsetX: 1, shadowOffsetY: 1, textShadowBlur: 1, textShadowOffsetX: 1, textShadowOffsetY: 1, textBoxShadowBlur: 1, textBoxShadowOffsetX: 1, textBoxShadowOffsetY: 1,
  }; var ab = function (t, e, i) { return ob.hasOwnProperty(e) ? i *= t.dpr : i; }; var rb = { NONE: 0, STYLE_BIND: 1, PLAIN_TEXT: 2 }; var sb = 9; const lb = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]]; var ub = function (t) { this.extendFrom(t, !1); }; ub.prototype = {
    constructor: ub, fill: "#000", stroke: null, opacity: 1, fillOpacity: null, strokeOpacity: null, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, font: null, textFont: null, fontStyle: null, fontWeight: null, fontSize: null, fontFamily: null, textTag: null, textFill: "#000", textStroke: null, textWidth: null, textHeight: null, textStrokeWidth: 0, textLineHeight: null, textPosition: "inside", textRect: null, textOffset: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowColor: "transparent", textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textBoxShadowColor: "transparent", textBoxShadowBlur: 0, textBoxShadowOffsetX: 0, textBoxShadowOffsetY: 0, transformText: !1, textRotation: 0, textOrigin: null, textBackgroundColor: null, textBorderColor: null, textBorderWidth: 0, textBorderRadius: 0, textPadding: null, rich: null, truncate: null, blend: null, bind(t, e, i) { const n = this; const o = i && i.style; const a = !o || t.__attrCachedBy !== rb.STYLE_BIND; t.__attrCachedBy = rb.STYLE_BIND; for (let r = 0; r < lb.length; r++) { const s = lb[r]; const l = s[0]; (a || n[l] !== o[l]) && (t[l] = ab(t, l, n[l] || s[1])); } if ((a || n.fill !== o.fill) && (t.fillStyle = n.fill), (a || n.stroke !== o.stroke) && (t.strokeStyle = n.stroke), (a || n.opacity !== o.opacity) && (t.globalAlpha = n.opacity == null ? 1 : n.opacity), (a || n.blend !== o.blend) && (t.globalCompositeOperation = n.blend || "source-over"), this.hasStroke()) { const u = n.lineWidth; t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1); } }, hasFill() { const t = this.fill; return t != null && t !== "none"; }, hasStroke() { const t = this.stroke; return t != null && t !== "none" && this.lineWidth > 0; }, extendFrom(t, e) { if (t) for (const i in t)!t.hasOwnProperty(i) || !0 !== e && (!1 === e ? this.hasOwnProperty(i) : t[i] == null) || (this[i] = t[i]); }, set(t, e) { typeof t === "string" ? this[t] = e : this.extendFrom(t, !0); }, clone() { const t = new this.constructor(); return t.extendFrom(this, !0), t; }, getGradient(t, e, i) { for (var n = (e.type === "radial" ? Se : be)(t, e, i), o = e.colorStops, a = 0; a < o.length; a++)n.addColorStop(o[a].offset, o[a].color); return n; },
  }; for (var hb = ub.prototype, cb = 0; cb < lb.length; cb++) { const db = lb[cb]; db[0] in hb || (hb[db[0]] = db[1]); }ub.getGradient = hb.getGradient; const fb = function (t, e) { this.image = t, this.repeat = e, this.type = "pattern"; }; fb.prototype.getCanvasPattern = function (t) { return t.createPattern(this.image, this.repeat || "repeat"); }; const pb = function (t, e, i) { let n; i = i || Xw, typeof t === "string" ? n = Ie(t, e, i) : w(t) && (t = (n = t).id), this.id = t, this.dom = n; const o = n.style; o && (n.onselectstart = Me, o["-webkit-user-select"] = "none", o["user-select"] = "none", o["-webkit-touch-callout"] = "none", o["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", o.padding = 0, o.margin = 0, o["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = 0.7, this.dpr = i; }; pb.prototype = {
    constructor: pb,
    __dirty: !0,
    __used: !1,
    __drawIndex: 0,
    __startIndex: 0,
    __endIndex: 0,
    incremental: !1,
    getElementCount() { return this.__endIndex - this.__startIndex; },
    initContext() { this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr; },
    createBackBuffer() { const t = this.dpr; this.domBack = Ie(`back-${this.id}`, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t); },
    resize(t, e) { const i = this.dpr; const n = this.dom; const o = n.style; const a = this.domBack; o && (o.width = `${t}px`, o.height = `${e}px`), n.width = t * i, n.height = e * i, a && (a.width = t * i, a.height = e * i, i !== 1 && this.ctxBack.scale(i, i)); },
    clear(t, e) {
      const i = this.dom; const n = this.ctx; const o = i.width; const a = i.height; var e = e || this.clearColor; const r = this.motionBlur && !t; const s = this.lastFrameAlpha; const l = this.dpr; if (r && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(i, 0, 0, o / l, a / l)), n.clearRect(0, 0, o, a), e && e !== "transparent") {
        let u; e.colorStops ? (u = e.__canvasGradient || ub.getGradient(n, e, {
          x: 0, y: 0, width: o, height: a,
        }), e.__canvasGradient = u) : e.image && (u = fb.prototype.getCanvasPattern.call(e, n)), n.save(), n.fillStyle = u || e, n.fillRect(0, 0, o, a), n.restore();
      } if (r) { const h = this.domBack; n.save(), n.globalAlpha = s, n.drawImage(h, 0, 0, o, a), n.restore(); }
    },
  }; const gb = typeof window !== "undefined" && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) { setTimeout(t, 16); }; var mb = new Ew(50); var vb = {}; var yb = 0; var xb = 5e3; var _b = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g; var wb = "12px sans-serif"; var bb = {}; bb.measureText = function (t, e) { const i = s(); return i.font = e || wb, i.measureText(t); }; var Sb = wb; var Mb = { left: 1, right: 1, center: 1 }; var Ib = { top: 1, bottom: 1, middle: 1 }; var Tb = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]]; const Ab = new de(); const Db = function () {}; Db.prototype = { constructor: Db, drawRectText(t, e) { const i = this.style; e = i.textRect || e, this.__dirty && Ye(i); let n = i.text; if (n != null && (n += ""), ci(n, i)) { t.save(); const o = this.transform; i.transformText ? this.setTransform(t) : o && (Ab.copy(e), Ab.applyTransform(o), e = Ab), Ke(this, t, n, i, e, sb), t.restore(); } } }, di.prototype = {
    constructor: di, type: "displayable", __dirty: !0, invisible: !1, z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: "pointer", rectHover: !1, progressive: !1, incremental: !1, globalScaleRatio: 1, beforeBrush(t) {}, afterBrush(t) {}, brush(t, e) {}, getBoundingRect() {}, contain(t, e) { return this.rectContain(t, e); }, traverse(t, e) { t.call(e, this); }, rectContain(t, e) { const i = this.transformCoordToLocal(t, e); return this.getBoundingRect().contain(i[0], i[1]); }, dirty() { this.__dirty = this.__dirtyText = !0, this._rect = null, this.__zr && this.__zr.refresh(); }, animateStyle(t) { return this.animate("style", t); }, attrKV(t, e) { t !== "style" ? Kw.prototype.attrKV.call(this, t, e) : this.style.set(e); }, setStyle(t, e) { return this.style.set(t, e), this.dirty(!1), this; }, useStyle(t) { return this.style = new ub(t, this), this.dirty(!1), this; },
  }, u(di, Kw), h(di, Db), fi.prototype = {
    constructor: fi, type: "image", brush(t, e) { const i = this.style; const n = i.image; i.bind(t, this, e); const o = this._image = Ae(n, this._image, this, this.onload); if (o && Ce(o)) { const a = i.x || 0; const r = i.y || 0; let s = i.width; let l = i.height; const u = o.width / o.height; if (s == null && l != null ? s = l * u : l == null && s != null ? l = s / u : s == null && l == null && (s = o.width, l = o.height), this.setTransform(t), i.sWidth && i.sHeight) { var h = i.sx || 0; var c = i.sy || 0; t.drawImage(o, h, c, i.sWidth, i.sHeight, a, r, s, l); } else if (i.sx && i.sy) { const d = s - (h = i.sx); const f = l - (c = i.sy); t.drawImage(o, h, c, d, f, a, r, s, l); } else t.drawImage(o, a, r, s, l); i.text != null && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect())); } }, getBoundingRect() { const t = this.style; return this._rect || (this._rect = new de(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect; },
  }, u(fi, di); var Cb = new de(0, 0, 0, 0); var Lb = new de(0, 0, 0, 0); const kb = function (t, e, i) { this.type = "canvas"; const n = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS"; this._opts = i = a({}, i || {}), this.dpr = i.devicePixelRatio || Xw, this._singleCanvas = n, this.root = t; const o = t.style; o && (o["-webkit-tap-highlight-color"] = "transparent", o["-webkit-user-select"] = o["user-select"] = o["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e; const r = this._zlevelList = []; const s = this._layers = {}; if (this._layerConfig = {}, this._needsManuallyCompositing = !1, n) { let l = t.width; let u = t.height; i.width != null && (l = i.width), i.height != null && (u = i.height), this.dpr = i.devicePixelRatio || 1, t.width = l * this.dpr, t.height = u * this.dpr, this._width = l, this._height = u; const h = new pb(t, this, this.dpr); h.__builtin__ = !0, h.initContext(), s[314159] = h, h.zlevel = 314159, r.push(314159), this._domRoot = t; } else { this._width = this._getSize(0), this._height = this._getSize(1); const c = this._domRoot = xi(this._width, this._height); t.appendChild(c); } this._hoverlayer = null, this._hoverElements = []; }; kb.prototype = {
    constructor: kb,
    getType() { return "canvas"; },
    isSingleCanvas() { return this._singleCanvas; },
    getViewportRoot() { return this._domRoot; },
    getViewportRootOffset() { const t = this.getViewportRoot(); if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 }; },
    refresh(t) { const e = this.storage.getDisplayList(!0); const i = this._zlevelList; this._redrawId = Math.random(), this._paintList(e, t, this._redrawId); for (let n = 0; n < i.length; n++) { const o = i[n]; const a = this._layers[o]; if (!a.__builtin__ && a.refresh) { const r = n === 0 ? this._backgroundColor : null; a.refresh(r); } } return this.refreshHover(), this; },
    addHover(t, e) {
      if (!t.__hoverMir) {
        const i = new t.constructor({
          style: t.style, shape: t.shape, z: t.z, z2: t.z2, silent: t.silent,
        }); return i.__from = t, t.__hoverMir = i, e && i.setStyle(e), this._hoverElements.push(i), i;
      }
    },
    removeHover(t) { const e = t.__hoverMir; const i = this._hoverElements; const n = l(i, e); n >= 0 && i.splice(n, 1), t.__hoverMir = null; },
    clearHover(t) { for (var e = this._hoverElements, i = 0; i < e.length; i++) { const n = e[i].__from; n && (n.__hoverMir = null); }e.length = 0; },
    refreshHover() { const t = this._hoverElements; let e = t.length; let i = this._hoverlayer; if (i && i.clear(), e) { _e(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(1e5)); const n = {}; i.ctx.save(); for (let o = 0; o < e;) { const a = t[o]; const r = a.__from; r && r.__zr ? (o++, r.invisible || (a.transform = r.transform, a.invTransform = r.invTransform, a.__clipPaths = r.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t.splice(o, 1), r.__hoverMir = null, e--); }i.ctx.restore(); } },
    getHoverLayer() { return this.getLayer(1e5); },
    _paintList(t, e, i) { if (this._redrawId === i) { e = e || !1, this._updateLayerStatus(t); const n = this._doPaintList(t, e); if (this._needsManuallyCompositing && this._compositeManually(), !n) { const o = this; gb(() => { o._paintList(t, e, i); }); } } },
    _compositeManually() { const t = this.getLayer(314159).ctx; const e = this._domRoot.width; const i = this._domRoot.height; t.clearRect(0, 0, e, i), this.eachBuiltinLayer((n) => { n.virtual && t.drawImage(n.dom, 0, 0, e, i); }); },
    _doPaintList(t, e) { for (var i = [], n = 0; n < this._zlevelList.length; n++) { const o = this._zlevelList[n]; (s = this._layers[o]).__builtin__ && s !== this._hoverlayer && (s.__dirty || e) && i.push(s); } for (var a = !0, r = 0; r < i.length; r++) { var s = i[r]; const l = s.ctx; const u = {}; l.save(); let h = e ? s.__startIndex : s.__drawIndex; const c = !e && s.incremental && Date.now; const f = c && Date.now(); const p = s.zlevel === this._zlevelList[0] ? this._backgroundColor : null; if (s.__startIndex === s.__endIndex)s.clear(!1, p); else if (h === s.__startIndex) { const g = t[h]; g.incremental && g.notClear && !e || s.clear(!1, p); }h === -1 && (console.error("For some unknown reason. drawIndex is -1"), h = s.__startIndex); for (var m = h; m < s.__endIndex; m++) { const v = t[m]; if (this._doPaintEl(v, s, e, u), v.__dirty = v.__dirtyText = !1, c && Date.now() - f > 15) break; }s.__drawIndex = m, s.__drawIndex < s.__endIndex && (a = !1), u.prevElClipPaths && l.restore(), l.restore(); } return U_.wxa && d(this._layers, (t) => { t && t.ctx && t.ctx.draw && t.ctx.draw(); }), a; },
    _doPaintEl(t, e, i, n) { const o = e.ctx; const a = t.transform; if ((e.__dirty || i) && !t.invisible && t.style.opacity !== 0 && (!a || a[0] || a[3]) && (!t.culling || !mi(t, this._width, this._height))) { const r = t.__clipPaths; n.prevElClipPaths && !vi(r, n.prevElClipPaths) || (n.prevElClipPaths && (e.ctx.restore(), n.prevElClipPaths = null, n.prevEl = null), r && (o.save(), yi(r, o), n.prevElClipPaths = r)), t.beforeBrush && t.beforeBrush(o), t.brush(o, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(o); } },
    getLayer(t, e) { this._singleCanvas && !this._needsManuallyCompositing && (t = 314159); let i = this._layers[t]; return i || ((i = new pb(`zr_${t}`, this, this.dpr)).zlevel = t, i.__builtin__ = !0, this._layerConfig[t] && n(i, this._layerConfig[t], !0), e && (i.virtual = e), this.insertLayer(t, i), i.initContext()), i; },
    insertLayer(t, e) { const i = this._layers; const n = this._zlevelList; const o = n.length; let a = null; let r = -1; const s = this._domRoot; if (i[t])Yw(`ZLevel ${t} has been used already`); else if (gi(e)) { if (o > 0 && t > n[0]) { for (r = 0; r < o - 1 && !(n[r] < t && n[r + 1] > t); r++);a = i[n[r]]; } if (n.splice(r + 1, 0, t), i[t] = e, !e.virtual) if (a) { const l = a.dom; l.nextSibling ? s.insertBefore(e.dom, l.nextSibling) : s.appendChild(e.dom); } else s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom); } else Yw(`Layer of zlevel ${t} is not valid`); },
    eachLayer(t, e) { let i; let n; const o = this._zlevelList; for (n = 0; n < o.length; n++)i = o[n], t.call(e, this._layers[i], i); },
    eachBuiltinLayer(t, e) { let i; let n; let o; const a = this._zlevelList; for (o = 0; o < a.length; o++)n = a[o], (i = this._layers[n]).__builtin__ && t.call(e, i, n); },
    eachOtherLayer(t, e) { let i; let n; let o; const a = this._zlevelList; for (o = 0; o < a.length; o++)n = a[o], (i = this._layers[n]).__builtin__ || t.call(e, i, n); },
    getLayers() { return this._layers; },
    _updateLayerStatus(t) { function e(t) { i && (i.__endIndex !== t && (i.__dirty = !0), i.__endIndex = t); } if (this.eachBuiltinLayer((t, e) => { t.__dirty = t.__used = !1; }), this._singleCanvas) for (o = 1; o < t.length; o++) if ((r = t[o]).zlevel !== t[o - 1].zlevel || r.incremental) { this._needsManuallyCompositing = !0; break; } for (var i = null, n = 0, o = 0; o < t.length; o++) { var a; var r = t[o]; const s = r.zlevel; r.incremental ? ((a = this.getLayer(s + 0.001, this._needsManuallyCompositing)).incremental = !0, n = 1) : a = this.getLayer(s + (n > 0 ? 0.01 : 0), this._needsManuallyCompositing), a.__builtin__ || Yw(`ZLevel ${s} has been used by unkown layer ${a.id}`), a !== i && (a.__used = !0, a.__startIndex !== o && (a.__dirty = !0), a.__startIndex = o, a.incremental ? a.__drawIndex = -1 : a.__drawIndex = o, e(o), i = a), r.__dirty && (a.__dirty = !0, a.incremental && a.__drawIndex < 0 && (a.__drawIndex = o)); }e(o), this.eachBuiltinLayer((t, e) => { !t.__used && t.getElementCount() > 0 && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex); }); },
    clear() { return this.eachBuiltinLayer(this._clearLayer), this; },
    _clearLayer(t) { t.clear(); },
    setBackgroundColor(t) { this._backgroundColor = t; },
    configLayer(t, e) { if (e) { const i = this._layerConfig; i[t] ? n(i[t], e, !0) : i[t] = e; for (let o = 0; o < this._zlevelList.length; o++) { const a = this._zlevelList[o]; a !== t && a !== t + 0.01 || n(this._layers[a], i[t], !0); } } },
    delLayer(t) { const e = this._layers; const i = this._zlevelList; const n = e[t]; n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(l(i, t), 1)); },
    resize(t, e) { if (this._domRoot.style) { const i = this._domRoot; i.style.display = "none"; const n = this._opts; if (t != null && (n.width = t), e != null && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width !== t || e !== this._height) { i.style.width = `${t}px`, i.style.height = `${e}px`; for (const o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e); d(this._progressiveLayers, (i) => { i.resize(t, e); }), this.refresh(!0); } this._width = t, this._height = e; } else { if (t == null || e == null) return; this._width = t, this._height = e, this.getLayer(314159).resize(t, e); } return this; },
    clearLayer(t) { const e = this._layers[t]; e && e.clear(); },
    dispose() { this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null; },
    getRenderedCanvas(t) { if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[314159].dom; const e = new pb("image", this, t.pixelRatio || this.dpr); if (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), t.pixelRatio <= this.dpr) { this.refresh(); const i = e.dom.width; const n = e.dom.height; const o = e.ctx; this.eachLayer((t) => { t.__builtin__ ? o.drawImage(t.dom, 0, 0, i, n) : t.renderToCanvas && (e.ctx.save(), t.renderToCanvas(e.ctx), e.ctx.restore()); }); } else for (let a = {}, r = this.storage.getDisplayList(!0), s = 0; s < r.length; s++) { const l = r[s]; this._doPaintEl(l, e, !0, a); } return e.dom; },
    getWidth() { return this._width; },
    getHeight() { return this._height; },
    _getSize(t) { const e = this._opts; const i = ["width", "height"][t]; const n = ["clientWidth", "clientHeight"][t]; const o = ["paddingLeft", "paddingTop"][t]; const a = ["paddingRight", "paddingBottom"][t]; if (e[i] != null && e[i] !== "auto") return parseFloat(e[i]); const r = this.root; const s = document.defaultView.getComputedStyle(r); return (r[n] || pi(s[i]) || pi(r.style[i])) - (pi(s[o]) || 0) - (pi(s[a]) || 0) | 0; },
    pathToImage(t, e) { e = e || this.dpr; const i = document.createElement("canvas"); const n = i.getContext("2d"); const o = t.getBoundingRect(); const a = t.style; const r = a.shadowBlur * e; const s = a.shadowOffsetX * e; const l = a.shadowOffsetY * e; const u = a.hasStroke() ? a.lineWidth : 0; const h = Math.max(u / 2, -s + r); const c = Math.max(u / 2, s + r); const d = Math.max(u / 2, -l + r); const f = Math.max(u / 2, l + r); const p = o.width + h + c; const g = o.height + d + f; i.width = p * e, i.height = g * e, n.scale(e, e), n.clearRect(0, 0, p, g), n.dpr = e; const m = { position: t.position, rotation: t.rotation, scale: t.scale }; t.position = [h - o.x, d - o.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(n); const v = new fi({ style: { x: 0, y: 0, image: i } }); return m.position != null && (v.position = t.position = m.position), m.rotation != null && (v.rotation = t.rotation = m.rotation), m.scale != null && (v.scale = t.scale = m.scale), v; },
  }; const Pb = function (t) { t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {}, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, fw.call(this); }; Pb.prototype = {
    constructor: Pb, addClip(t) { this._clips.push(t); }, addAnimator(t) { t.animation = this; for (let e = t.getClips(), i = 0; i < e.length; i++) this.addClip(e[i]); }, removeClip(t) { const e = l(this._clips, t); e >= 0 && this._clips.splice(e, 1); }, removeAnimator(t) { for (let e = t.getClips(), i = 0; i < e.length; i++) this.removeClip(e[i]); t.animation = null; }, _update() { for (var t = (new Date()).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, o = [], a = [], r = 0; r < n; r++) { const s = i[r]; const l = s.step(t, e); l && (o.push(l), a.push(s)); } for (r = 0; r < n;)i[r]._needsRemove ? (i[r] = i[n - 1], i.pop(), n--) : r++; n = o.length; for (r = 0; r < n; r++)a[r].fire(o[r]); this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update(); }, _startLoop() { function t() { e._running && (gb(t), !e._paused && e._update()); } var e = this; this._running = !0, gb(t); }, start() { this._time = (new Date()).getTime(), this._pausedTime = 0, this._startLoop(); }, stop() { this._running = !1; }, pause() { this._paused || (this._pauseStart = (new Date()).getTime(), this._paused = !0); }, resume() { this._paused && (this._pausedTime += (new Date()).getTime() - this._pauseStart, this._paused = !1); }, clear() { this._clips = []; }, isFinished() { return !this._clips.length; }, animate(t, e) { const i = new Zw(t, (e = e || {}).loop, e.getter, e.setter); return this.addAnimator(i), i; },
  }, h(Pb, fw); var Nb = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"]; var Ob = ["touchstart", "touchend", "touchmove"]; const Eb = {
    pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1,
  }; var Rb = f(Nb, (t) => { const e = t.replace("mouse", "pointer"); return Eb[e] ? e : t; }); var zb = {
    mousemove(t) { t = ut(this.dom, t), this.trigger("mousemove", t); }, mouseout(t) { let e = (t = ut(this.dom, t)).toElement || t.relatedTarget; if (e !== this.dom) for (;e && e.nodeType !== 9;) { if (e === this.dom) return; e = e.parentNode; } this.trigger("mouseout", t); }, touchstart(t) { (t = ut(this.dom, t)).zrByTouch = !0, this._lastTouchMoment = new Date(), this.handler.processGesture(this, t, "start"), zb.mousemove.call(this, t), zb.mousedown.call(this, t), wi(this); }, touchmove(t) { (t = ut(this.dom, t)).zrByTouch = !0, this.handler.processGesture(this, t, "change"), zb.mousemove.call(this, t), wi(this); }, touchend(t) { (t = ut(this.dom, t)).zrByTouch = !0, this.handler.processGesture(this, t, "end"), zb.mouseup.call(this, t), +new Date() - this._lastTouchMoment < 300 && zb.click.call(this, t), wi(this); }, pointerdown(t) { zb.mousedown.call(this, t); }, pointermove(t) { bi(t) || zb.mousemove.call(this, t); }, pointerup(t) { zb.mouseup.call(this, t); }, pointerout(t) { bi(t) || zb.mouseout.call(this, t); },
  }; d(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], (t) => { zb[t] = function (e) { e = ut(this.dom, e), this.trigger(t, e); }; }); const Bb = Mi.prototype; Bb.dispose = function () { for (let t = Nb.concat(Ob), e = 0; e < t.length; e++) { const i = t[e]; ct(this.dom, _i(i), this._handlers[i]); } }, Bb.setCursor = function (t) { this.dom.style && (this.dom.style.cursor = t || "default"); }, h(Mi, fw); const Vb = !U_.canvasSupported; var Gb = { canvas: kb }; var Fb = {}; var Wb = function (t, e, i) { i = i || {}, this.dom = e, this.id = t; const n = this; const o = new nb(); let a = i.renderer; if (Vb) { if (!Gb.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8"); a = "vml"; } else a && Gb[a] || (a = "canvas"); const r = new Gb[a](e, o, i, t); this.storage = o, this.painter = r; const s = U_.node || U_.worker ? null : new Mi(r.getViewportRoot()); this.handler = new ww(o, r, s, r.root), this.animation = new Pb({ stage: { update: m(this.flush, this) } }), this.animation.start(), this._needsRefresh; const l = o.delFromStorage; const u = o.addToStorage; o.delFromStorage = function (t) { l.call(o, t), t && t.removeSelfFromZr(n); }, o.addToStorage = function (t) { u.call(o, t), t.addSelfToZr(n); }; }; Wb.prototype = {
    constructor: Wb, getId() { return this.id; }, add(t) { this.storage.addRoot(t), this._needsRefresh = !0; }, remove(t) { this.storage.delRoot(t), this._needsRefresh = !0; }, configLayer(t, e) { this.painter.configLayer && this.painter.configLayer(t, e), this._needsRefresh = !0; }, setBackgroundColor(t) { this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this._needsRefresh = !0; }, refreshImmediately() { this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1; }, refresh() { this._needsRefresh = !0; }, flush() { let t; this._needsRefresh && (t = !0, this.refreshImmediately()), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately()), t && this.trigger("rendered"); }, addHover(t, e) { if (this.painter.addHover) { const i = this.painter.addHover(t, e); return this.refreshHover(), i; } }, removeHover(t) { this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover()); }, clearHover() { this.painter.clearHover && (this.painter.clearHover(), this.refreshHover()); }, refreshHover() { this._needsRefreshHover = !0; }, refreshHoverImmediately() { this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover(); }, resize(t) { t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize(); }, clearAnimation() { this.animation.clear(); }, getWidth() { return this.painter.getWidth(); }, getHeight() { return this.painter.getHeight(); }, pathToImage(t, e) { return this.painter.pathToImage(t, e); }, setCursorStyle(t) { this.handler.setCursorStyle(t); }, findHover(t, e) { return this.handler.findHover(t, e); }, on(t, e, i) { this.handler.on(t, e, i); }, off(t, e) { this.handler.off(t, e); }, trigger(t, e) { this.handler.trigger(t, e); }, clear() { this.storage.delRoot(), this.painter.clear(); }, dispose() { this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, Ai(this.id); },
  }; const Hb = (Object.freeze || Object)({
    version: "4.0.6", init: Ii, dispose(t) { if (t)t.dispose(); else { for (const e in Fb)Fb.hasOwnProperty(e) && Fb[e].dispose(); Fb = {}; } return this; }, getInstance(t) { return Fb[t]; }, registerPainter: Ti,
  }); var Zb = d; var Ub = w; var Xb = y; var jb = "series\0"; var Yb = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"]; var qb = 0; var Kb = "."; var $b = "___EC__COMPONENT__CONTAINER___"; var Jb = 0; const Qb = function (t) { for (let e = 0; e < t.length; e++)t[e][1] || (t[e][1] = t[e][0]); return function (e, i, n) { for (var o = {}, a = 0; a < t.length; a++) { const r = t[a][1]; if (!(i && l(i, r) >= 0 || n && l(n, r) < 0)) { const s = e.getShallow(r); s != null && (o[t[a][0]] = s); } } return o; }; }; const tS = Qb([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]); const eS = { getLineStyle(t) { const e = tS(this, t); const i = this.getLineDash(e.lineWidth); return i && (e.lineDash = i), e; }, getLineDash(t) { t == null && (t = 1); const e = this.get("type"); const i = Math.max(t, 2); const n = 4 * t; return e === "solid" || e == null ? null : e === "dashed" ? [n, n] : [i, i]; } }; const iS = Qb([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]); const nS = { getAreaStyle(t, e) { return iS(this, t, e); } }; var oS = Math.pow; var aS = Math.sqrt; var rS = 1e-8; var sS = 1e-4; var lS = aS(3); var uS = 1 / 3; var hS = V(); var cS = V(); var dS = V(); var fS = Math.min; var pS = Math.max; var gS = Math.sin; var mS = Math.cos; var vS = 2 * Math.PI; var yS = V(); var xS = V(); var _S = V(); var wS = []; var bS = []; const SS = {
    M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7,
  }; const MS = []; const IS = []; const TS = []; const AS = []; const DS = Math.min; const CS = Math.max; const LS = Math.cos; const kS = Math.sin; const PS = Math.sqrt; const NS = Math.abs; const OS = typeof Float32Array !== "undefined"; var ES = function (t) { this._saveData = !t, this._saveData && (this.data = []), this._ctx = null; }; ES.prototype = {
    constructor: ES, _xi: 0, _yi: 0, _x0: 0, _y0: 0, _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale(t, e) { this._ux = NS(1 / Xw / t) || 0, this._uy = NS(1 / Xw / e) || 0; }, getContext() { return this._ctx; }, beginPath(t) { return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this; }, moveTo(t, e) { return this.addData(SS.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this; }, lineTo(t, e) { const i = NS(t - this._xi) > this._ux || NS(e - this._yi) > this._uy || this._len < 5; return this.addData(SS.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this; }, bezierCurveTo(t, e, i, n, o, a) { return this.addData(SS.C, t, e, i, n, o, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, o, a) : this._ctx.bezierCurveTo(t, e, i, n, o, a)), this._xi = o, this._yi = a, this; }, quadraticCurveTo(t, e, i, n) { return this.addData(SS.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this; }, arc(t, e, i, n, o, a) { return this.addData(SS.A, t, e, i, i, n, o - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, o, a), this._xi = LS(o) * i + t, this._yi = kS(o) * i + e, this; }, arcTo(t, e, i, n, o) { return this._ctx && this._ctx.arcTo(t, e, i, n, o), this; }, rect(t, e, i, n) { return this._ctx && this._ctx.rect(t, e, i, n), this.addData(SS.R, t, e, i, n), this; }, closePath() { this.addData(SS.Z); const t = this._ctx; const e = this._x0; const i = this._y0; return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this; }, fill(t) { t && t.fill(), this.toStatic(); }, stroke(t) { t && t.stroke(), this.toStatic(); }, setLineDash(t) { if (t instanceof Array) { this._lineDash = t, this._dashIdx = 0; for (var e = 0, i = 0; i < t.length; i++)e += t[i]; this._dashSum = e; } return this; }, setLineDashOffset(t) { return this._dashOffset = t, this; }, len() { return this._len; }, setData(t) { const e = t.length; this.data && this.data.length === e || !OS || (this.data = new Float32Array(e)); for (let i = 0; i < e; i++) this.data[i] = t[i]; this._len = e; }, appendPath(t) { t instanceof Array || (t = [t]); for (var e = t.length, i = 0, n = this._len, o = 0; o < e; o++)i += t[o].len(); OS && this.data instanceof Float32Array && (this.data = new Float32Array(n + i)); for (o = 0; o < e; o++) for (let a = t[o].data, r = 0; r < a.length; r++) this.data[n++] = a[r]; this._len = n; }, addData(t) { if (this._saveData) { let e = this.data; this._len + arguments.length > e.length && (this._expandData(), e = this.data); for (let i = 0; i < arguments.length; i++)e[this._len++] = arguments[i]; this._prevCmd = t; } }, _expandData() { if (!(this.data instanceof Array)) { for (var t = [], e = 0; e < this._len; e++)t[e] = this.data[e]; this.data = t; } }, _needsDash() { return this._lineDash; }, _dashedLineTo(t, e) { let i; let n; const o = this._dashSum; let a = this._dashOffset; const r = this._lineDash; const s = this._ctx; const l = this._xi; const u = this._yi; let h = t - l; let c = e - u; const d = PS(h * h + c * c); let f = l; let p = u; const g = r.length; for (h /= d, c /= d, a < 0 && (a = o + a), f -= (a %= o) * h, p -= a * c; h > 0 && f <= t || h < 0 && f >= t || h === 0 && (c > 0 && p <= e || c < 0 && p >= e);)f += h * (i = r[n = this._dashIdx]), p += c * i, this._dashIdx = (n + 1) % g, h > 0 && f < l || h < 0 && f > l || c > 0 && p < u || c < 0 && p > u || s[n % 2 ? "moveTo" : "lineTo"](h >= 0 ? DS(f, t) : CS(f, t), c >= 0 ? DS(p, e) : CS(p, e)); h = f - t, c = p - e, this._dashOffset = -PS(h * h + c * c); }, _dashedBezierTo(t, e, i, n, o, a) { let r; let s; let l; let u; let h; const c = this._dashSum; let d = this._dashOffset; const f = this._lineDash; const p = this._ctx; const g = this._xi; const m = this._yi; const v = Qi; let y = 0; let x = this._dashIdx; const _ = f.length; let w = 0; for (d < 0 && (d = c + d), d %= c, r = 0; r < 1; r += 0.1)s = v(g, t, i, o, r + 0.1) - v(g, t, i, o, r), l = v(m, e, n, a, r + 0.1) - v(m, e, n, a, r), y += PS(s * s + l * l); for (;x < _ && !((w += f[x]) > d); x++);for (r = (w - d) / y; r <= 1;)u = v(g, t, i, o, r), h = v(m, e, n, a, r), x % 2 ? p.moveTo(u, h) : p.lineTo(u, h), r += f[x] / y, x = (x + 1) % _; x % 2 != 0 && p.lineTo(o, a), s = o - u, l = a - h, this._dashOffset = -PS(s * s + l * l); }, _dashedQuadraticTo(t, e, i, n) { const o = i; const a = n; i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, o, a); }, toStatic() { const t = this.data; t instanceof Array && (t.length = this._len, OS && (this.data = new Float32Array(t))); }, getBoundingRect() { MS[0] = MS[1] = TS[0] = TS[1] = Number.MAX_VALUE, IS[0] = IS[1] = AS[0] = AS[1] = -Number.MAX_VALUE; for (var t = this.data, e = 0, i = 0, n = 0, o = 0, a = 0; a < t.length;) { const r = t[a++]; switch (a === 1 && (n = e = t[a], o = i = t[a + 1]), r) { case SS.M: e = n = t[a++], i = o = t[a++], TS[0] = n, TS[1] = o, AS[0] = n, AS[1] = o; break; case SS.L: fn(e, i, t[a], t[a + 1], TS, AS), e = t[a++], i = t[a++]; break; case SS.C: pn(e, i, t[a++], t[a++], t[a++], t[a++], t[a], t[a + 1], TS, AS), e = t[a++], i = t[a++]; break; case SS.Q: gn(e, i, t[a++], t[a++], t[a], t[a + 1], TS, AS), e = t[a++], i = t[a++]; break; case SS.A: var s = t[a++]; var l = t[a++]; var u = t[a++]; var h = t[a++]; var c = t[a++]; var d = t[a++] + c; a += 1; var f = 1 - t[a++]; a === 1 && (n = LS(c) * u + s, o = kS(c) * h + l), mn(s, l, u, h, c, d, f, TS, AS), e = LS(d) * u + s, i = kS(d) * h + l; break; case SS.R: fn(n = e = t[a++], o = i = t[a++], n + t[a++], o + t[a++], TS, AS); break; case SS.Z: e = n, i = o; }tt(MS, MS, TS), et(IS, IS, AS); } return a === 0 && (MS[0] = MS[1] = IS[0] = IS[1] = 0), new de(MS[0], MS[1], IS[0] - MS[0], IS[1] - MS[1]); }, rebuildPath(t) { for (var e, i, n, o, a, r, s = this.data, l = this._ux, u = this._uy, h = this._len, c = 0; c < h;) { const d = s[c++]; switch (c === 1 && (e = n = s[c], i = o = s[c + 1]), d) { case SS.M: e = n = s[c++], i = o = s[c++], t.moveTo(n, o); break; case SS.L: a = s[c++], r = s[c++], (NS(a - n) > l || NS(r - o) > u || c === h - 1) && (t.lineTo(a, r), n = a, o = r); break; case SS.C: t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], o = s[c - 1]; break; case SS.Q: t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], o = s[c - 1]; break; case SS.A: var f = s[c++]; var p = s[c++]; var g = s[c++]; var m = s[c++]; var v = s[c++]; var y = s[c++]; var x = s[c++]; var _ = s[c++]; var w = g > m ? g : m; var b = g > m ? 1 : g / m; var S = g > m ? m / g : 1; var M = v + y; Math.abs(g - m) > 0.001 ? (t.translate(f, p), t.rotate(x), t.scale(b, S), t.arc(0, 0, w, v, M, 1 - _), t.scale(1 / b, 1 / S), t.rotate(-x), t.translate(-f, -p)) : t.arc(f, p, w, v, M, 1 - _), c === 1 && (e = LS(v) * g + f, i = kS(v) * m + p), n = LS(M) * g + f, o = kS(M) * m + p; break; case SS.R: e = n = s[c], i = o = s[c + 1], t.rect(s[c++], s[c++], s[c++], s[c++]); break; case SS.Z: t.closePath(), n = e, o = i; } } },
  }, ES.CMD = SS; var RS = 2 * Math.PI; var zS = 2 * Math.PI; var BS = ES.CMD; var VS = 2 * Math.PI; var GS = 1e-4; var FS = [-1, -1, -1]; var WS = [-1, -1]; const HS = fb.prototype.getCanvasPattern; const ZS = Math.abs; const US = new ES(!0); kn.prototype = {
    constructor: kn, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, subPixelOptimize: !1, brush(t, e) { const i = this.style; const n = this.path || US; const o = i.hasStroke(); const a = i.hasFill(); const r = i.fill; const s = i.stroke; const l = a && !!r.colorStops; const u = o && !!s.colorStops; const h = a && !!r.image; const c = o && !!s.image; if (i.bind(t, this, e), this.setTransform(t), this.__dirty) { let d; l && (d = d || this.getBoundingRect(), this._fillGradient = i.getGradient(t, r, d)), u && (d = d || this.getBoundingRect(), this._strokeGradient = i.getGradient(t, s, d)); }l ? t.fillStyle = this._fillGradient : h && (t.fillStyle = HS.call(r, t)), u ? t.strokeStyle = this._strokeGradient : c && (t.strokeStyle = HS.call(s, t)); const f = i.lineDash; const p = i.lineDashOffset; const g = !!t.setLineDash; const m = this.getGlobalScale(); if (n.setScale(m[0], m[1]), this.__dirtyPath || f && !g && o ? (n.beginPath(t), f && !g && (n.setLineDash(f), n.setLineDashOffset(p)), this.buildPath(n, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), a) if (i.fillOpacity != null) { v = t.globalAlpha; t.globalAlpha = i.fillOpacity * i.opacity, n.fill(t), t.globalAlpha = v; } else n.fill(t); if (f && g && (t.setLineDash(f), t.lineDashOffset = p), o) if (i.strokeOpacity != null) { var v = t.globalAlpha; t.globalAlpha = i.strokeOpacity * i.opacity, n.stroke(t), t.globalAlpha = v; } else n.stroke(t); f && g && t.setLineDash([]), i.text != null && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect())); }, buildPath(t, e, i) {}, createPathProxy() { this.path = new ES(); }, getBoundingRect() { let t = this._rect; const e = this.style; const i = !t; if (i) { let n = this.path; n || (n = this.path = new ES()), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect(); } if (this._rect = t, e.hasStroke()) { const o = this._rectWithStroke || (this._rectWithStroke = t.clone()); if (this.__dirty || i) { o.copy(t); let a = e.lineWidth; const r = e.strokeNoScale ? this.getLineScale() : 1; e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), r > 1e-10 && (o.width += a / r, o.height += a / r, o.x -= a / r / 2, o.y -= a / r / 2); } return o; } return t; }, contain(t, e) { const i = this.transformCoordToLocal(t, e); const n = this.getBoundingRect(); const o = this.style; if (t = i[0], e = i[1], n.contain(t, e)) { const a = this.path.data; if (o.hasStroke()) { let r = o.lineWidth; const s = o.strokeNoScale ? this.getLineScale() : 1; if (s > 1e-10 && (o.hasFill() || (r = Math.max(r, this.strokeContainThreshold)), Ln(a, r / s, t, e))) return !0; } if (o.hasFill()) return Cn(a, t, e); } return !1; }, dirty(t) { t == null && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = this.__dirtyText = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty(); }, animateShape(t) { return this.animate("shape", t); }, attrKV(t, e) { t === "shape" ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : di.prototype.attrKV.call(this, t, e); }, setShape(t, e) { const i = this.shape; if (i) { if (w(t)) for (const n in t)t.hasOwnProperty(n) && (i[n] = t[n]); else i[t] = e; this.dirty(!0); } return this; }, getLineScale() { const t = this.transform; return t && ZS(t[0] - 1) > 1e-10 && ZS(t[3] - 1) > 1e-10 ? Math.sqrt(ZS(t[0] * t[3] - t[2] * t[1])) : 1; },
  }, kn.extend = function (t) { const e = function (e) { kn.call(this, e), t.style && this.style.extendFrom(t.style, !1); const i = t.shape; if (i) { this.shape = this.shape || {}; const n = this.shape; for (const o in i)!n.hasOwnProperty(o) && i.hasOwnProperty(o) && (n[o] = i[o]); }t.init && t.init.call(this, e); }; u(e, kn); for (const i in t)i !== "style" && i !== "shape" && (e.prototype[i] = t[i]); return e; }, u(kn, di); const XS = ES.CMD; const jS = [[], [], []]; const YS = Math.sqrt; const qS = Math.atan2; var KS = function (t, e) { let i; let n; let o; let a; let r; let s; const l = t.data; const u = XS.M; const h = XS.C; const c = XS.L; const d = XS.R; const f = XS.A; const p = XS.Q; for (o = 0, a = 0; o < l.length;) { switch (i = l[o++], a = o, n = 0, i) { case u: case c: n = 1; break; case h: n = 3; break; case p: n = 2; break; case f: var g = e[4]; var m = e[5]; var v = YS(e[0] * e[0] + e[1] * e[1]); var y = YS(e[2] * e[2] + e[3] * e[3]); var x = qS(-e[1] / y, e[0] / v); l[o] *= v, l[o++] += g, l[o] *= y, l[o++] += m, l[o++] *= v, l[o++] *= y, l[o++] += x, l[o++] += x, a = o += 2; break; case d: s[0] = l[o++], s[1] = l[o++], Q(s, s, e), l[a++] = s[0], l[a++] = s[1], s[0] += l[o++], s[1] += l[o++], Q(s, s, e), l[a++] = s[0], l[a++] = s[1]; } for (r = 0; r < n; r++)(s = jS[r])[0] = l[o++], s[1] = l[o++], Q(s, s, e), l[a++] = s[0], l[a++] = s[1]; } }; var $S = Math.sqrt; var JS = Math.sin; var QS = Math.cos; var tM = Math.PI; const eM = function (t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]); }; var iM = function (t, e) { return (t[0] * e[0] + t[1] * e[1]) / (eM(t) * eM(e)); }; var nM = function (t, e) { return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(iM(t, e)); }; var oM = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi; var aM = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; var rM = function (t) { di.call(this, t); }; rM.prototype = {
    constructor: rM, type: "text", brush(t, e) { const i = this.style; this.__dirty && Ye(i), i.fill = i.stroke = i.shadowBlur = i.shadowColor = i.shadowOffsetX = i.shadowOffsetY = null; let n = i.text; n != null && (n += ""), ci(n, i) ? (this.setTransform(t), Ke(this, t, n, i, null, e), this.restoreTransform(t)) : t.__attrCachedBy = rb.NONE; }, getBoundingRect() { const t = this.style; if (this.__dirty && Ye(t), !this._rect) { let e = t.text; e != null ? e += "" : e = ""; const i = ke(`${t.text}`, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.rich); if (i.x += t.x || 0, i.y += t.y || 0, si(t.textStroke, t.textStrokeWidth)) { const n = t.textStrokeWidth; i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n; } this._rect = i; } return this._rect; },
  }, u(rM, di); const sM = kn.extend({ type: "circle", shape: { cx: 0, cy: 0, r: 0 }, buildPath(t, e, i) { i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0); } }); const lM = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]]; const uM = function (t) { return U_.browser.ie && U_.browser.version >= 11 ? function () { let e; const i = this.__clipPaths; const n = this.style; if (i) for (let o = 0; o < i.length; o++) { const a = i[o]; const r = a && a.shape; const s = a && a.type; if (r && (s === "sector" && r.startAngle === r.endAngle || s === "rect" && (!r.width || !r.height))) { for (l = 0; l < lM.length; l++)lM[l][2] = n[lM[l][0]], n[lM[l][0]] = lM[l][1]; e = !0; break; } } if (t.apply(this, arguments), e) for (var l = 0; l < lM.length; l++)n[lM[l][0]] = lM[l][2]; } : t; }; var hM = kn.extend({
    type: "sector",
    shape: {
      cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0,
    },
    brush: uM(kn.prototype.brush),
    buildPath(t, e) { const i = e.cx; const n = e.cy; const o = Math.max(e.r0 || 0, 0); const a = Math.max(e.r, 0); const r = e.startAngle; const s = e.endAngle; const l = e.clockwise; const u = Math.cos(r); const h = Math.sin(r); t.moveTo(u * o + i, h * o + n), t.lineTo(u * a + i, h * a + n), t.arc(i, n, a, r, s, !l), t.lineTo(Math.cos(s) * o + i, Math.sin(s) * o + n), o !== 0 && t.arc(i, n, o, s, r, l), t.closePath(); },
  }); const cM = kn.extend({
    type: "ring",
    shape: {
      cx: 0, cy: 0, r: 0, r0: 0,
    },
    buildPath(t, e) { const i = e.cx; const n = e.cy; const o = 2 * Math.PI; t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, o, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, o, !0); },
  }); var dM = function (t, e) { for (var i = t.length, n = [], o = 0, a = 1; a < i; a++)o += K(t[a - 1], t[a]); let r = o / 2; r = r < i ? i : r; for (a = 0; a < r; a++) { var s; var l; var u; const h = a / (r - 1) * (e ? i : i - 1); const c = Math.floor(h); const d = h - c; const f = t[c % i]; e ? (s = t[(c - 1 + i) % i], l = t[(c + 1) % i], u = t[(c + 2) % i]) : (s = t[c === 0 ? c : c - 1], l = t[c > i - 2 ? i - 1 : c + 1], u = t[c > i - 3 ? i - 1 : c + 2]); const p = d * d; const g = d * p; n.push([zn(s[0], f[0], l[0], u[0], d, p, g), zn(s[1], f[1], l[1], u[1], d, p, g)]); } return n; }; var fM = function (t, e, i, n) { let o; let a; let r; let s; const l = []; const u = []; const h = []; const c = []; if (n) { r = [1 / 0, 1 / 0], s = [-1 / 0, -1 / 0]; for (var d = 0, f = t.length; d < f; d++)tt(r, r, t[d]), et(s, s, t[d]); tt(r, r, n[0]), et(s, s, n[1]); } for (var d = 0, f = t.length; d < f; d++) { const p = t[d]; if (i)o = t[d ? d - 1 : f - 1], a = t[(d + 1) % f]; else { if (d === 0 || d === f - 1) { l.push(F(t[d])); continue; }o = t[d - 1], a = t[d + 1]; }U(u, a, o), Y(u, u, e); let g = K(p, o); let m = K(p, a); const v = g + m; v !== 0 && (g /= v, m /= v), Y(h, u, -g), Y(c, u, m); const y = H([], p, h); const x = H([], p, c); n && (et(y, y, r), tt(y, y, s), et(x, x, r), tt(x, x, s)), l.push(y), l.push(x); } return i && l.push(l.shift()), l; }; var pM = kn.extend({ type: "polygon", shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath(t, e) { Bn(t, e, !0); } }); var gM = kn.extend({
    type: "polyline", shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: "#000", fill: null }, buildPath(t, e) { Bn(t, e, !1); },
  }); var mM = Math.round; const vM = {}; var yM = kn.extend({
    type: "rect",
    shape: {
      r: 0, x: 0, y: 0, width: 0, height: 0,
    },
    buildPath(t, e) { let i; let n; let o; let a; this.subPixelOptimize ? (Gn(vM, e, this.style), i = vM.x, n = vM.y, o = vM.width, a = vM.height, vM.r = e.r, e = vM) : (i = e.x, n = e.y, o = e.width, a = e.height), e.r ? je(t, e) : t.rect(i, n, o, a), t.closePath(); },
  }); const xM = {}; var _M = kn.extend({
    type: "line",
    shape: {
      x1: 0, y1: 0, x2: 0, y2: 0, percent: 1,
    },
    style: { stroke: "#000", fill: null },
    buildPath(t, e) { let i; let n; let o; let a; this.subPixelOptimize ? (Vn(xM, e, this.style), i = xM.x1, n = xM.y1, o = xM.x2, a = xM.y2) : (i = e.x1, n = e.y1, o = e.x2, a = e.y2); const r = e.percent; r !== 0 && (t.moveTo(i, n), r < 1 && (o = i * (1 - r) + o * r, a = n * (1 - r) + a * r), t.lineTo(o, a)); },
    pointAt(t) { const e = this.shape; return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]; },
  }); const wM = []; var bM = kn.extend({
    type: "bezier-curve",
    shape: {
      x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1,
    },
    style: { stroke: "#000", fill: null },
    buildPath(t, e) { const i = e.x1; const n = e.y1; let o = e.x2; let a = e.y2; let r = e.cpx1; let s = e.cpy1; let l = e.cpx2; let u = e.cpy2; const h = e.percent; h !== 0 && (t.moveTo(i, n), l == null || u == null ? (h < 1 && (hn(i, r, o, h, wM), r = wM[1], o = wM[2], hn(n, s, a, h, wM), s = wM[1], a = wM[2]), t.quadraticCurveTo(r, s, o, a)) : (h < 1 && (on(i, r, l, o, h, wM), r = wM[1], l = wM[2], o = wM[3], on(n, s, u, a, h, wM), s = wM[1], u = wM[2], a = wM[3]), t.bezierCurveTo(r, s, l, u, o, a))); },
    pointAt(t) { return Wn(this.shape, t, !1); },
    tangentAt(t) { const e = Wn(this.shape, t, !0); return q(e, e); },
  }); const SM = kn.extend({
    type: "arc",
    shape: {
      cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0,
    },
    style: { stroke: "#000", fill: null },
    buildPath(t, e) { const i = e.cx; const n = e.cy; const o = Math.max(e.r, 0); const a = e.startAngle; const r = e.endAngle; const s = e.clockwise; const l = Math.cos(a); const u = Math.sin(a); t.moveTo(l * o + i, u * o + n), t.arc(i, n, o, a, r, !s); },
  }); const MM = kn.extend({
    type: "compound", shape: { paths: null }, _updatePathDirty() { for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++)t = t || e[i].__dirtyPath; this.__dirtyPath = t, this.__dirty = this.__dirty || t; }, beforeBrush() { this._updatePathDirty(); for (let t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++)t[i].path || t[i].createPathProxy(), t[i].path.setScale(e[0], e[1]); }, buildPath(t, e) { for (let i = e.paths || [], n = 0; n < i.length; n++)i[n].buildPath(t, i[n].shape, !0); }, afterBrush() { for (let t = this.shape.paths || [], e = 0; e < t.length; e++)t[e].__dirtyPath = !1; }, getBoundingRect() { return this._updatePathDirty(), kn.prototype.getBoundingRect.call(this); },
  }); const IM = function (t) { this.colorStops = t || []; }; IM.prototype = { constructor: IM, addColorStop(t, e) { this.colorStops.push({ offset: t, color: e }); } }; var TM = function (t, e, i, n, o, a) { this.x = t == null ? 0 : t, this.y = e == null ? 0 : e, this.x2 = i == null ? 1 : i, this.y2 = n == null ? 0 : n, this.type = "linear", this.global = a || !1, IM.call(this, o); }; TM.prototype = { constructor: TM }, u(TM, IM); const AM = function (t, e, i, n, o) { this.x = t == null ? 0.5 : t, this.y = e == null ? 0.5 : e, this.r = i == null ? 0.5 : i, this.type = "radial", this.global = o || !1, IM.call(this, n); }; AM.prototype = { constructor: AM }, u(AM, IM), Hn.prototype.incremental = !0, Hn.prototype.clearDisplaybles = function () { this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), this.notClear = !1; }, Hn.prototype.addDisplayable = function (t, e) { e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.dirty(); }, Hn.prototype.addDisplayables = function (t, e) { e = e || !1; for (let i = 0; i < t.length; i++) this.addDisplayable(t[i], e); }, Hn.prototype.eachPendingDisplayable = function (t) { for (e = this._cursor; e < this._displayables.length; e++)t && t(this._displayables[e]); for (var e = 0; e < this._temporaryDisplayables.length; e++)t && t(this._temporaryDisplayables[e]); }, Hn.prototype.update = function () { this.updateTransform(); for (t = this._cursor; t < this._displayables.length; t++)(e = this._displayables[t]).parent = this, e.update(), e.parent = null; for (var t = 0; t < this._temporaryDisplayables.length; t++) { var e = this._temporaryDisplayables[t]; e.parent = this, e.update(), e.parent = null; } }, Hn.prototype.brush = function (t, e) { for (i = this._cursor; i < this._displayables.length; i++)(n = this._displayables[i]).beforeBrush && n.beforeBrush(t), n.brush(t, i === this._cursor ? null : this._displayables[i - 1]), n.afterBrush && n.afterBrush(t); this._cursor = i; for (var i = 0; i < this._temporaryDisplayables.length; i++) { var n = this._temporaryDisplayables[i]; n.beforeBrush && n.beforeBrush(t), n.brush(t, i === 0 ? null : this._temporaryDisplayables[i - 1]), n.afterBrush && n.afterBrush(t); } this._temporaryDisplayables = [], this.notClear = !0; }; const DM = []; Hn.prototype.getBoundingRect = function () { if (!this._rect) { for (var t = new de(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) { const i = this._displayables[e]; const n = i.getBoundingRect().clone(); i.needLocalTransform() && n.applyTransform(i.getLocalTransform(DM)), t.union(n); } this._rect = t; } return this._rect; }, Hn.prototype.contain = function (t, e) { const i = this.transformCoordToLocal(t, e); if (this.getBoundingRect().contain(i[0], i[1])) for (let n = 0; n < this._displayables.length; n++) if (this._displayables[n].contain(t, e)) return !0; return !1; }, u(Hn, di); var CM = Math.round; var LM = Math.max; var kM = Math.min; var PM = {}; var NM = 1; const OM = function (t, e) { for (var i = [], n = t.length, o = 0; o < n; o++) { const a = t[o]; a.path || a.createPathProxy(), a.__dirtyPath && a.buildPath(a.path, a.shape, !0), i.push(a.path); } const r = new kn(e); return r.createPathProxy(), r.buildPath = function (t) { t.appendPath(i); const e = t.getContext(); e && t.rebuildPath(e); }, r; }; var EM = R(); var RM = 0; var zM = (Object.freeze || Object)({
    Z2_EMPHASIS_LIFT: NM,
    extendShape: Zn,
    extendPath(t, e) { return Rn(t, e); },
    makePath: Un,
    makeImage: Xn,
    mergePath: OM,
    resizePath: Yn,
    subPixelOptimizeLine: qn,
    subPixelOptimizeRect: Kn,
    subPixelOptimize: $n,
    setElementHoverStyle: ao,
    isInEmphasis: ro,
    setHoverStyle: co,
    setAsHoverStyleTrigger: fo,
    setLabelStyle: po,
    setTextStyle: go,
    setText(t, e, i) { let n; const o = { isRectText: !0 }; !1 === i ? n = !0 : o.autoColor = i, mo(t, e, o, n); },
    getFont: bo,
    updateProps: Mo,
    initProps: Io,
    getTransform: To,
    applyTransform: Ao,
    transformDirection: Do,
    groupTransition: Co,
    clipPointsByRect: Lo,
    clipRectByRect(t, e) {
      const i = LM(t.x, e.x); const n = kM(t.x + t.width, e.x + e.width); const o = LM(t.y, e.y); const a = kM(t.y + t.height, e.y + e.height); if (n >= i && a >= o) {
        return {
          x: i, y: o, width: n - i, height: a - o,
        };
      }
    },
    createIcon: ko,
    Group: tb,
    Image: fi,
    Text: rM,
    Circle: sM,
    Sector: hM,
    Ring: cM,
    Polygon: pM,
    Polyline: gM,
    Rect: yM,
    Line: _M,
    BezierCurve: bM,
    Arc: SM,
    IncrementalDisplayable: Hn,
    CompoundPath: MM,
    LinearGradient: TM,
    RadialGradient: AM,
    BoundingRect: de,
  }); const BM = ["textStyle", "color"]; const VM = {
    getTextColor(t) { const e = this.ecModel; return this.getShallow("color") || (!t && e ? e.get(BM) : null); },
    getFont() {
      return bo({
        fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily"),
      }, this.ecModel);
    },
    getTextRect(t) { return ke(t, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("rich"), this.getShallow("truncateText")); },
  }; const GM = Qb([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]); const FM = { getItemStyle(t, e) { const i = GM(this, t, e); const n = this.getBorderLineDash(); return n && (i.lineDash = n), i; }, getBorderLineDash() { const t = this.get("borderType"); return t === "solid" || t == null ? null : t === "dashed" ? [5, 5] : [1, 1]; } }; const WM = h; var HM = Bi(); Po.prototype = {
    constructor: Po, init: null, mergeOption(t) { n(this.option, t, !0); }, get(t, e) { return t == null ? this.option : No(this.option, this.parsePath(t), !e && Oo(this, t)); }, getShallow(t, e) { const i = this.option; let n = i == null ? i : i[t]; const o = !e && Oo(this, t); return n == null && o && (n = o.getShallow(t)), n; }, getModel(t, e) { let i; const n = t == null ? this.option : No(this.option, t = this.parsePath(t)); return e = e || (i = Oo(this, t)) && i.getModel(t), new Po(n, e, this.ecModel); }, isEmpty() { return this.option == null; }, restoreData() {}, clone() { return new (0, this.constructor)(i(this.option)); }, setReadOnly(t) {}, parsePath(t) { return typeof t === "string" && (t = t.split(".")), t; }, customizeGetParent(t) { HM(this).getParent = t; }, isAnimationEnabled() { if (!U_.node) { if (this.option.animation != null) return !!this.option.animation; if (this.parentModel) return this.parentModel.isAnimationEnabled(); } },
  }, Xi(Po), ji(Po), WM(Po, eS), WM(Po, nS), WM(Po, VM), WM(Po, FM); var ZM = 0; var UM = 1e-4; var XM = 9007199254740991; var jM = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; const YM = (Object.freeze || Object)({
    linearMap: zo, parsePercent: Bo, round: Vo, asc: Go, getPrecision: Fo, getPrecisionSafe: Wo, getPixelPrecision: Ho, getPercentWithPrecision: Zo, MAX_SAFE_INTEGER: XM, remRadian: Uo, isRadianAroundZero: Xo, parseDate: jo, quantity: Yo, nice: Ko, quantile(t, e) { const i = (t.length - 1) * e + 1; const n = Math.floor(i); const o = +t[n - 1]; const a = i - n; return a ? o + a * (t[n] - o) : o; }, reformIntervals: $o, isNumeric: Jo,
  }); var qM = L; var KM = /([&<>"'])/g; var $M = {
    "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;",
  }; var JM = ["a", "b", "c", "d", "e", "f", "g"]; var QM = function (t, e) { return `{${t}${e == null ? "" : e}}`; }; const tI = ze; const eI = ke; const iI = (Object.freeze || Object)({
    addCommas: Qo, toCamelCase: ta, normalizeCssArray: qM, encodeHTML: ea, formatTpl: ia, formatTplSimple: na, getTooltipMarker: oa, formatTime: ra, capitalFirst: sa, truncateText: tI, getTextRect: eI,
  }); var nI = d; var oI = ["left", "right", "top", "bottom", "width", "height"]; var aI = [["width", "left", "right"], ["height", "top", "bottom"]]; var rI = la; const sI = (v(la, "vertical"), v(la, "horizontal"), {
    getBoxLayoutParams() {
      return {
        left: this.get("left"), top: this.get("top"), right: this.get("right"), bottom: this.get("bottom"), width: this.get("width"), height: this.get("height"),
      };
    },
  }); const lI = Bi(); var uI = Po.extend({
    type: "component", id: "", name: "", mainType: "", subType: "", componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, $constructor(t, e, i, n) { Po.call(this, t, e, i, n), this.uid = Eo("ec_cpt_model"); }, init(t, e, i, n) { this.mergeDefaultAndTheme(t, i); }, mergeDefaultAndTheme(t, e) { const i = this.layoutMode; const o = i ? pa(t) : {}; n(t, e.getTheme().get(this.mainType)), n(t, this.getDefaultOption()), i && fa(t, o, i); }, mergeOption(t, e) { n(this.option, t, !0); const i = this.layoutMode; i && fa(this.option, t, i); }, optionUpdated(t, e) {}, getDefaultOption() { const t = lI(this); if (!t.defaultOption) { for (var e = [], i = this.constructor; i;) { const o = i.prototype.defaultOption; o && e.push(o), i = i.superClass; } for (var a = {}, r = e.length - 1; r >= 0; r--)a = n(a, e[r], !0); t.defaultOption = a; } return t.defaultOption; }, getReferringComponents(t) { return this.ecModel.queryComponents({ mainType: t, index: this.get(`${t}Index`, !0), id: this.get(`${t}Id`, !0) }); },
  }); Ki(uI, { registerWhenExtend: !0 }), (function (t) { const e = {}; t.registerSubTypeDefaulter = function (t, i) { t = Zi(t), e[t.main] = i; }, t.determineSubType = function (i, n) { let o = n.type; if (!o) { const a = Zi(i).main; t.hasSubTypes(i) && e[a] && (o = e[a](n)); } return o; }; }(uI)), (function (t, e) { function i(t) { const i = {}; const a = []; return d(t, (r) => { const s = n(i, r); const u = o(s.originalDeps = e(r), t); s.entryCount = u.length, s.entryCount === 0 && a.push(r), d(u, (t) => { l(s.predecessor, t) < 0 && s.predecessor.push(t); const e = n(i, t); l(e.successor, t) < 0 && e.successor.push(r); }); }), { graph: i, noEntryList: a }; } function n(t, e) { return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e]; } function o(t, e) { const i = []; return d(t, (t) => { l(e, t) >= 0 && i.push(t); }), i; }t.topologicalTravel = function (t, e, n, o) { function a(t) { s[t].entryCount--, s[t].entryCount === 0 && l.push(t); } if (t.length) { const r = i(e); var s = r.graph; var l = r.noEntryList; const u = {}; for (d(t, (t) => { u[t] = !0; }); l.length;) { const h = l.pop(); const c = s[h]; const f = !!u[h]; f && (n.call(o, h, c.originalDeps.slice()), delete u[h]), d(c.successor, f ? (t) => { u[t] = !0, a(t); } : a); }d(u, () => { throw new Error("Circle dependency may exists"); }); } }; }(uI, (t) => { let e = []; return d(uI.getClassesByMainType(t), (t) => { e = e.concat(t.prototype.dependencies || []); }), e = f(e, t => Zi(t).main), t !== "dataset" && l(e, "dataset") <= 0 && e.unshift("dataset"), e; })), h(uI, sI); let hI = ""; typeof navigator !== "undefined" && (hI = navigator.platform || ""); var cI = {
    color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
    gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
    textStyle: {
      fontFamily: hI.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal",
    },
    blendMode: null,
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 300,
    animationEasing: "exponentialOut",
    animationEasingUpdate: "cubicOut",
    animationThreshold: 2e3,
    progressiveThreshold: 3e3,
    progressive: 400,
    hoverLayerThreshold: 3e3,
    useUTC: !1,
  }; const dI = Bi(); const fI = { clearColorPalette() { dI(this).colorIdx = 0, dI(this).colorNameMap = {}; }, getColorFromPalette(t, e, i) { const n = dI(e = e || this); const o = n.colorIdx || 0; const a = n.colorNameMap = n.colorNameMap || {}; if (a.hasOwnProperty(t)) return a[t]; const r = Di(this.get("color", !0)); const s = this.get("colorLayer", !0); let l = i != null && s ? ma(s, i) : r; if ((l = l || r) && l.length) { const u = l[o]; return t && (a[t] = u), n.colorIdx = (o + 1) % l.length, u; } } }; var pI = {
    cartesian2d(t, e, i, n) { const o = t.getReferringComponents("xAxis")[0]; const a = t.getReferringComponents("yAxis")[0]; e.coordSysDims = ["x", "y"], i.set("x", o), i.set("y", a), ya(o) && (n.set("x", o), e.firstCategoryDimIndex = 0), ya(a) && (n.set("y", a), e.firstCategoryDimIndex = 1); }, singleAxis(t, e, i, n) { const o = t.getReferringComponents("singleAxis")[0]; e.coordSysDims = ["single"], i.set("single", o), ya(o) && (n.set("single", o), e.firstCategoryDimIndex = 0); }, polar(t, e, i, n) { const o = t.getReferringComponents("polar")[0]; const a = o.findAxisModel("radiusAxis"); const r = o.findAxisModel("angleAxis"); e.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", r), ya(a) && (n.set("radius", a), e.firstCategoryDimIndex = 0), ya(r) && (n.set("angle", r), e.firstCategoryDimIndex = 1); }, geo(t, e, i, n) { e.coordSysDims = ["lng", "lat"]; }, parallel(t, e, i, n) { const o = t.ecModel; const a = o.getComponent("parallel", t.get("parallelIndex")); const r = e.coordSysDims = a.dimensions.slice(); d(a.parallelAxisIndex, (t, a) => { const s = o.getComponent("parallelAxis", t); const l = r[a]; i.set(l, s), ya(s) && e.firstCategoryDimIndex == null && (n.set(l, s), e.firstCategoryDimIndex = a); }); },
  }; var gI = "original"; var mI = "arrayRows"; var vI = "objectRows"; var yI = "keyedColumns"; var xI = "unknown"; var _I = "typedArray"; var wI = "column"; var bI = "row"; xa.seriesDataToSource = function (t) { return new xa({ data: t, sourceFormat: S(t) ? _I : gI, fromDataset: !1 }); }, ji(xa); var SI = Bi(); var MI = "\0_ec_inner"; const II = Po.extend({
    init(t, e, i, n) { i = i || {}, this.option = null, this._theme = new Po(i), this._optionManager = n; },
    setOption(t, e) { k(!(MI in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption(null); },
    resetOption(t) { let e = !1; const i = this._optionManager; if (!t || t === "recreate") { const n = i.mountOption(t === "recreate"); this.option && t !== "recreate" ? (this.restoreData(), this.mergeOption(n)) : Oa.call(this, n), e = !0; } if (t !== "timeline" && t !== "media" || this.restoreData(), !t || t === "recreate" || t === "timeline") { const o = i.getTimelineOption(this); o && (this.mergeOption(o), e = !0); } if (!t || t === "recreate" || t === "media") { const a = i.getMediaOption(this, this._api); a.length && d(a, function (t) { this.mergeOption(t, e = !0); }, this); } return e; },
    mergeOption(t) { const e = this.option; const o = this._componentsMap; const r = []; ba(this), d(t, (t, o) => { t != null && (uI.hasClass(o) ? o && r.push(o) : e[o] = e[o] == null ? i(t) : n(e[o], t, !0)); }), uI.topologicalTravel(r, uI.getAllClassMainTypes(), function (i, n) { const r = Di(t[i]); const s = Pi(o.get(i), r); Ni(s), d(s, (t, e) => { const n = t.option; w(n) && (t.keyInfo.mainType = i, t.keyInfo.subType = Ra(i, n, t.exist)); }); const l = Ea(o, n); e[i] = [], o.set(i, []), d(s, function (t, n) { let r = t.exist; const s = t.option; if (k(w(s) || r, "Empty component definition"), s) { const u = uI.getClass(i, t.keyInfo.subType, !0); if (r && r instanceof u)r.name = t.keyInfo.name, r.mergeOption(s, this), r.optionUpdated(s, !1); else { const h = a({ dependentModels: l, componentIndex: n }, t.keyInfo); a(r = new u(s, this, this, h), h), r.init(s, this, this, h), r.optionUpdated(null, !0); } } else r.mergeOption({}, this), r.optionUpdated({}, !1); o.get(i)[n] = r, e[i][n] = r.option; }, this), i === "series" && za(this, o.get("series")); }, this), this._seriesIndicesMap = R(this._seriesIndices = this._seriesIndices || []); },
    getOption() { const t = i(this.option); return d(t, (e, i) => { if (uI.hasClass(i)) { for (let n = (e = Di(e)).length - 1; n >= 0; n--)Ei(e[n]) && e.splice(n, 1); t[i] = e; } }), delete t[MI], t; },
    getTheme() { return this._theme; },
    getComponent(t, e) { const i = this._componentsMap.get(t); if (i) return i[e || 0]; },
    queryComponents(t) { const e = t.mainType; if (!e) return []; let i = t.index; const n = t.id; const o = t.name; const a = this._componentsMap.get(e); if (!a || !a.length) return []; let r; if (i != null)y(i) || (i = [i]), r = g(f(i, t => a[t]), t => !!t); else if (n != null) { const s = y(n); r = g(a, t => s && l(n, t.id) >= 0 || !s && t.id === n); } else if (o != null) { const u = y(o); r = g(a, t => u && l(o, t.name) >= 0 || !u && t.name === o); } else r = a.slice(); return Ba(r, t); },
    findComponents(t) {
      const e = t.query; const i = t.mainType; const n = (function (t) {
        const e = `${i}Index`; const n = `${i}Id`; const o = `${i}Name`; return !t || t[e] == null && t[n] == null && t[o] == null ? null : {
          mainType: i, index: t[e], id: t[n], name: t[o],
        };
      }(e)); return (function (e) { return t.filter ? g(e, t.filter) : e; }(Ba(n ? this.queryComponents(n) : this._componentsMap.get(i), t)));
    },
    eachComponent(t, e, i) { const n = this._componentsMap; typeof t === "function" ? (i = e, e = t, n.each((t, n) => { d(t, (t, o) => { e.call(i, n, t, o); }); })) : _(t) ? d(n.get(t), e, i) : w(t) && d(this.findComponents(t), e, i); },
    getSeriesByName(t) { return g(this._componentsMap.get("series"), e => e.name === t); },
    getSeriesByIndex(t) { return this._componentsMap.get("series")[t]; },
    getSeriesByType(t) { return g(this._componentsMap.get("series"), e => e.subType === t); },
    getSeries() { return this._componentsMap.get("series").slice(); },
    getSeriesCount() { return this._componentsMap.get("series").length; },
    eachSeries(t, e) { d(this._seriesIndices, function (i) { const n = this._componentsMap.get("series")[i]; t.call(e, n, i); }, this); },
    eachRawSeries(t, e) { d(this._componentsMap.get("series"), t, e); },
    eachSeriesByType(t, e, i) { d(this._seriesIndices, function (n) { const o = this._componentsMap.get("series")[n]; o.subType === t && e.call(i, o, n); }, this); },
    eachRawSeriesByType(t, e, i) { return d(this.getSeriesByType(t), e, i); },
    isSeriesFiltered(t) { return this._seriesIndicesMap.get(t.componentIndex) == null; },
    getCurrentSeriesIndices() { return (this._seriesIndices || []).slice(); },
    filterSeries(t, e) { za(this, g(this._componentsMap.get("series"), t, e)); },
    restoreData(t) { const e = this._componentsMap; za(this, e.get("series")); const i = []; e.each((t, e) => { i.push(e); }), uI.topologicalTravel(i, uI.getAllClassMainTypes(), (i, n) => { d(e.get(i), (e) => { (i !== "series" || !Pa(e, t)) && e.restoreData(); }); }); },
  }); h(II, fI); var TI = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"]; const AI = {}; Ga.prototype = {
    constructor: Ga, create(t, e) { let i = []; d(AI, (n, o) => { const a = n.create(t, e); i = i.concat(a || []); }), this._coordinateSystems = i; }, update(t, e) { d(this._coordinateSystems, (i) => { i.update && i.update(t, e); }); }, getCoordinateSystems() { return this._coordinateSystems.slice(); },
  }, Ga.register = function (t, e) { AI[t] = e; }, Ga.get = function (t) { return AI[t]; }; var DI = d; const CI = i; var LI = f; var kI = n; var PI = /^(min|max)?(.+)$/; Fa.prototype = {
    constructor: Fa, setOption(t, e) { t && d(Di(t.series), (t) => { t && t.data && S(t.data) && N(t.data); }), t = CI(t, !0); const i = this._optionBackup; const n = Wa.call(this, t, e, !i); this._newBaseOption = n.baseOption, i ? (Xa(i.baseOption, n.baseOption), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n; }, mountOption(t) { const e = this._optionBackup; return this._timelineOptions = LI(e.timelineOptions, CI), this._mediaList = LI(e.mediaList, CI), this._mediaDefault = CI(e.mediaDefault), this._currentMediaIndices = [], CI(t ? e.baseOption : this._newBaseOption); }, getTimelineOption(t) { let e; const i = this._timelineOptions; if (i.length) { const n = t.getComponent("timeline"); n && (e = CI(i[n.getCurrentIndex()], !0)); } return e; }, getMediaOption(t) { const e = this._api.getWidth(); const i = this._api.getHeight(); const n = this._mediaList; const o = this._mediaDefault; let a = []; let r = []; if (!n.length && !o) return r; for (let s = 0, l = n.length; s < l; s++)Ha(n[s].query, e, i) && a.push(s); return !a.length && o && (a = [-1]), a.length && !Ua(a, this._currentMediaIndices) && (r = LI(a, t => CI(t === -1 ? o.option : n[t].option))), this._currentMediaIndices = a, r; },
  }; const NI = d; var OI = w; var EI = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"]; const RI = function (t, e) { NI(Qa(t.series), (t) => { OI(t) && Ja(t); }); const i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"]; e && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), NI(i, (e) => { NI(Qa(t[e]), (t) => { t && (Ka(t, "axisLabel"), Ka(t.axisPointer, "label")); }); }), NI(Qa(t.parallel), (t) => { const e = t && t.parallelAxisDefault; Ka(e, "axisLabel"), Ka(e && e.axisPointer, "label"); }), NI(Qa(t.calendar), (t) => { Ya(t, "itemStyle"), Ka(t, "dayLabel"), Ka(t, "monthLabel"), Ka(t, "yearLabel"); }), NI(Qa(t.radar), (t) => { Ka(t, "name"); }), NI(Qa(t.geo), (t) => { OI(t) && ($a(t), NI(Qa(t.regions), (t) => { $a(t); })); }), NI(Qa(t.timeline), (t) => { $a(t), Ya(t, "label"), Ya(t, "itemStyle"), Ya(t, "controlStyle", !0); const e = t.data; y(e) && d(e, (t) => { w(t) && (Ya(t, "label"), Ya(t, "itemStyle")); }); }), NI(Qa(t.toolbox), (t) => { Ya(t, "iconStyle"), NI(t.feature, (t) => { Ya(t, "iconStyle"); }); }), Ka(tr(t.axisPointer), "label"), Ka(tr(t.tooltip).axisPointer, "label"); }; var zI = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]]; const BI = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"]; var VI = function (t, e) { RI(t, e), t.series = Di(t.series), d(t.series, (t) => { if (w(t)) { const e = t.type; if (e !== "pie" && e !== "gauge" || t.clockWise != null && (t.clockwise = t.clockWise), e === "gauge") { const i = er(t, "pointer.color"); i != null && ir(t, "itemStyle.normal.color", i); }nr(t); } }), t.dataRange && (t.visualMap = t.dataRange), d(BI, (e) => { let i = t[e]; i && (y(i) || (i = [i]), d(i, (t) => { nr(t); })); }); }; const GI = ar.prototype; GI.pure = !1, GI.persistent = !0, GI.getSource = function () { return this._source; }; var FI = {
    arrayRows_column: {
      pure: !0, count() { return Math.max(0, this._data.length - this._source.startIndex); }, getItem(t) { return this._data[t + this._source.startIndex]; }, appendData: lr,
    },
    arrayRows_row: {
      pure: !0, count() { const t = this._data[0]; return t ? Math.max(0, t.length - this._source.startIndex) : 0; }, getItem(t) { t += this._source.startIndex; for (var e = [], i = this._data, n = 0; n < i.length; n++) { const o = i[n]; e.push(o ? o[t] : null); } return e; }, appendData() { throw new Error('Do not support appendData when set seriesLayoutBy: "row".'); },
    },
    objectRows: {
      pure: !0, count: rr, getItem: sr, appendData: lr,
    },
    keyedColumns: {
      pure: !0, count() { const t = this._source.dimensionsDefine[0].name; const e = this._data[t]; return e ? e.length : 0; }, getItem(t) { for (var e = [], i = this._source.dimensionsDefine, n = 0; n < i.length; n++) { const o = this._data[i[n].name]; e.push(o ? o[t] : null); } return e; }, appendData(t) { const e = this._data; d(t, (t, i) => { for (let n = e[i] || (e[i] = []), o = 0; o < (t || []).length; o++)n.push(t[o]); }); },
    },
    original: { count: rr, getItem: sr, appendData: lr },
    typedArray: {
      persistent: !1, pure: !0, count() { return this._data ? this._data.length / this._dimSize : 0; }, getItem(t, e) { t -= this._offset, e = e || []; for (let i = this._dimSize * t, n = 0; n < this._dimSize; n++)e[n] = this._data[i + n]; return e; }, appendData(t) { this._data = t; }, clean() { this._offset += this.count(), this._data = null; },
    },
  }; var WI = {
    arrayRows: ur, objectRows(t, e, i, n) { return i != null ? t[n] : t; }, keyedColumns: ur, original(t, e, i, n) { const o = Li(t); return i != null && o instanceof Array ? o[i] : o; }, typedArray: ur,
  }; const HI = {
    arrayRows: hr, objectRows(t, e, i, n) { return cr(t[e], this._dimensionInfos[e]); }, keyedColumns: hr, original(t, e, i, n) { const o = t && (t.value == null ? t : t.value); return !this._rawData.pure && ki(t) && (this.hasItemOption = !0), cr(o instanceof Array ? o[n] : o, this._dimensionInfos[e]); }, typedArray(t, e, i, n) { return t[n]; },
  }; const ZI = /\{@(.+?)\}/g; const UI = {
    getDataParams(t, e) {
      const i = this.getData(e); const n = this.getRawValue(t, e); const o = i.getRawIndex(t); const a = i.getName(t); const r = i.getRawDataItem(t); const s = i.getItemVisual(t, "color"); const l = this.ecModel.getComponent("tooltip"); const u = Hi(l && l.get("renderMode")); const h = this.mainType; const c = h === "series"; return {
        componentType: h, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: c ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: c ? this.id : null, seriesName: c ? this.name : null, name: a, dataIndex: o, data: r, dataType: e, value: n, color: s, marker: oa({ color: s, renderMode: u }), $vars: ["seriesName", "name", "value"],
      };
    },
    getFormattedLabel(t, e, i, n, o) { e = e || "normal"; const a = this.getData(i); const r = a.getItemModel(t); const s = this.getDataParams(t, i); n != null && s.value instanceof Array && (s.value = s.value[n]); const l = r.get(e === "normal" ? [o || "label", "formatter"] : [e, o || "label", "formatter"]); return typeof l === "function" ? (s.status = e, l(s)) : typeof l === "string" ? ia(l, s).replace(ZI, (e, i) => { const n = i.length; return i.charAt(0) === "[" && i.charAt(n - 1) === "]" && (i = +i.slice(1, n - 1)), dr(a, t, i); }) : void 0; },
    getRawValue(t, e) { return dr(this.getData(e), t); },
    formatTooltip() {},
  }; const XI = gr.prototype; XI.perform = function (t) { function e(t) { return !(t >= 1) && (t = 1), t; } const i = this._upstream; const n = t && t.skip; if (this._dirty && i) { const o = this.context; o.data = o.outputData = i.context.outputData; } this.__pipeline && (this.__pipeline.currentTask = this); let a; this._plan && !n && (a = this._plan(this.context)); const r = e(this._modBy); const s = this._modDataCount || 0; const l = e(t && t.modBy); const u = t && t.modDataCount || 0; r === l && s === u || (a = "reset"); let h; (this._dirty || a === "reset") && (this._dirty = !1, h = vr(this, n)), this._modBy = l, this._modDataCount = u; const c = t && t.step; if (this._dueEnd = i ? i._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, this._progress) { const d = this._dueIndex; const f = Math.min(c != null ? this._dueIndex + c : 1 / 0, this._dueEnd); if (!n && (h || d < f)) { const p = this._progress; if (y(p)) for (let g = 0; g < p.length; g++)mr(this, p[g], d, f, l, u); else mr(this, p, d, f, l, u); } this._dueIndex = f; const m = this._settedOutputEnd != null ? this._settedOutputEnd : f; this._outputDueEnd = m; } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd; return this.unfinished(); }; var jI = (function () { function t() { return n < i ? n++ : null; } function e() { const t = n % r * o + Math.ceil(n / r); const e = n >= i ? null : t < a ? t : n; return n++, e; } let i; let n; let o; let a; let r; var s = { reset(l, u, h, c) { n = l, i = u, o = h, a = c, r = Math.ceil(a / o), s.next = o > 1 && a > 0 ? e : t; } }; return s; }()); XI.dirty = function () { this._dirty = !0, this._onDirty && this._onDirty(this.context); }, XI.unfinished = function () { return this._progress && this._dueIndex < this._dueEnd; }, XI.pipe = function (t) { (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty()); }, XI.dispose = function () { this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0); }, XI.getUpstream = function () { return this._upstream; }, XI.getDownstream = function () { return this._downstream; }, XI.setOutputEnd = function (t) { this._outputDueEnd = this._settedOutputEnd = t; }; const YI = Bi(); var qI = uI.extend({
    type: "series.__base__",
    seriesIndex: 0,
    coordinateSystem: null,
    defaultOption: null,
    legendDataProvider: null,
    visualColorAccessPath: "itemStyle.color",
    layoutMode: null,
    init(t, e, i, n) { this.seriesIndex = this.componentIndex, this.dataTask = pr({ count: _r, reset: wr }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(t, i), Sa(this); const o = this.getInitialData(t, i); Sr(o, this), this.dataTask.context.data = o, YI(this).dataBeforeProcessed = o, yr(this); },
    mergeDefaultAndTheme(t, e) { const i = this.layoutMode; const o = i ? pa(t) : {}; let a = this.subType; uI.hasClass(a) && (a += "Series"), n(t, e.getTheme().get(this.subType)), n(t, this.getDefaultOption()), Ci(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && fa(t, o, i); },
    mergeOption(t, e) { t = n(this.option, t, !0), this.fillDataTextStyle(t.data); const i = this.layoutMode; i && fa(this.option, t, i), Sa(this); const o = this.getInitialData(t, e); Sr(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, YI(this).dataBeforeProcessed = o, yr(this); },
    fillDataTextStyle(t) { if (t && !S(t)) for (let e = ["show"], i = 0; i < t.length; i++)t[i] && t[i].label && Ci(t[i], "label", e); },
    getInitialData() {},
    appendData(t) { this.getRawData().appendData(t.data); },
    getData(t) { const e = Ir(this); if (e) { const i = e.context.data; return t == null ? i : i.getLinkedData(t); } return YI(this).data; },
    setData(t) { const e = Ir(this); if (e) { const i = e.context; i.data !== t && e.modifyOutputEnd && e.setOutputEnd(t.count()), i.outputData = t, e !== this.dataTask && (i.data = t); }YI(this).data = t; },
    getSource() { return wa(this); },
    getRawData() { return YI(this).dataBeforeProcessed; },
    getBaseAxis() { const t = this.coordinateSystem; return t && t.getBaseAxis && t.getBaseAxis(); },
    formatTooltip(t, e, i, n) {
      function o(t) { return { renderMode: n, content: ea(Qo(t)), style: l }; } const a = this; const r = (n = n || "html") === "html" ? "<br/>" : "\n"; const s = n === "richText"; var l = {}; let u = 0; const h = this.getData(); const c = h.mapDimension("defaultedTooltip", !0); const f = c.length; const g = this.getRawValue(t); const m = y(g); let v = h.getItemVisual(t, "color"); w(v) && v.colorStops && (v = (v.colorStops[0] || {}).color), v = v || "transparent"; const x = (f > 1 || m && !f ? (function (i) {
        function o(t, i) {
          const o = h.getDimensionInfo(i); if (o && !1 !== o.otherDims.tooltip) {
            const c = o.type; const d = `sub${a.seriesIndex}at${u}`; const p = oa({
              color: v, type: "subItem", renderMode: n, markerId: d,
            }); const g = typeof p === "string" ? p : p.content; const m = (r ? `${g + ea(o.displayName || "-")}: ` : "") + ea(c === "ordinal" ? `${t}` : c === "time" ? e ? "" : ra("yyyy/MM/dd hh:mm:ss", t) : Qo(t)); m && f.push(m), s && (l[d] = v, ++u);
          }
        } var r = p(i, (t, e, i) => { const n = h.getDimensionInfo(i); return t |= n && !1 !== n.tooltip && n.displayName != null; }, 0); var f = []; c.length ? d(c, (e) => { o(dr(h, t, e), e); }) : d(i, o); const g = r ? s ? "\n" : "<br/>" : ""; const m = g + f.join(g || ", "); return { renderMode: n, content: m, style: l };
      }(g)) : o(f ? dr(h, t, c[0]) : m ? g[0] : g)).content; const _ = `${a.seriesIndex}at${u}`; const b = oa({
        color: v, type: "item", renderMode: n, markerId: _,
      }); l[_] = v, ++u; const S = h.getName(t); let M = this.name; Oi(this) || (M = ""), M = M ? ea(M) + (e ? ": " : r) : ""; const I = typeof b === "string" ? b : b.content; return { html: e ? I + M + x : M + I + (S ? `${ea(S)}: ${x}` : x), markers: l };
    },
    isAnimationEnabled() { if (U_.node) return !1; let t = this.getShallow("animation"); return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t; },
    restoreData() { this.dataTask.dirty(); },
    getColorFromPalette(t, e, i) { const n = this.ecModel; let o = fI.getColorFromPalette.call(this, t, e, i); return o || (o = n.getColorFromPalette(t, e, i)), o; },
    coordDimToDataDim(t) { return this.getRawData().mapDimension(t, !0); },
    getProgressive() { return this.get("progressive"); },
    getProgressiveThreshold() { return this.get("progressiveThreshold"); },
    getAxisTooltipData: null,
    getTooltipPosition: null,
    pipeTask: null,
    preventIncremental: null,
    pipelineContext: null,
  }); h(qI, UI), h(qI, fI); var KI = function () { this.group = new tb(), this.uid = Eo("viewComponent"); }; KI.prototype = {
    constructor: KI, init(t, e) {}, render(t, e, i, n) {}, dispose() {}, filterForExposedEvent: null,
  }; const $I = KI.prototype; $I.updateView = $I.updateLayout = $I.updateVisual = function (t, e, i, n) {}, Xi(KI), Ki(KI, { registerWhenExtend: !0 }); const JI = function () { const t = Bi(); return function (e) { const i = t(e); const n = e.pipelineContext; const o = i.large; const a = i.progressiveRender; const r = i.large = n.large; const s = i.progressiveRender = n.progressiveRender; return !!(o ^ r || a ^ s) && "reset"; }; }; var QI = Bi(); var tT = JI(); Tr.prototype = {
    type: "chart", init(t, e) {}, render(t, e, i, n) {}, highlight(t, e, i, n) { Dr(t.getData(), n, "emphasis"); }, downplay(t, e, i, n) { Dr(t.getData(), n, "normal"); }, remove(t, e) { this.group.removeAll(); }, dispose() {}, incrementalPrepareRender: null, incrementalRender: null, updateTransform: null, filterForExposedEvent: null,
  }; const eT = Tr.prototype; eT.updateView = eT.updateLayout = eT.updateVisual = function (t, e, i, n) { this.render(t, e, i, n); }, Xi(Tr), Ki(Tr, { registerWhenExtend: !0 }), Tr.markUpdateMethod = function (t, e) { QI(t).updateMethod = e; }; var iT = { incrementalPrepareRender: { progress(t, e) { e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload); } }, render: { forceFirstProgress: !0, progress(t, e) { e.view.render(e.model, e.ecModel, e.api, e.payload); } } }; var nT = "\0__throttleOriginMethod"; var oT = "\0__throttleRate"; var aT = "\0__throttleType"; const rT = { createOnAllSeries: !0, performRawSeries: !0, reset(t, e) { const i = t.getData(); const n = (t.visualColorAccessPath || "itemStyle.color").split("."); const o = t.get(n) || t.getColorFromPalette(t.name, null, e.getSeriesCount()); if (i.setVisual("color", o), !e.isSeriesFiltered(t)) { typeof o !== "function" || o instanceof IM || i.each((e) => { i.setItemVisual(e, "color", o(t.getDataParams(e))); }); return { dataEach: i.hasItemOption ? function (t, e) { const i = t.getItemModel(e).get(n, !0); i != null && t.setItemVisual(e, "color", i); } : null }; } } }; const sT = {
    toolbox: {
      brush: {
        title: {
          rect: "矩形选择", polygon: "圈选", lineX: "横向选择", lineY: "纵向选择", keep: "保持选择", clear: "清除选择",
        },
      },
      dataView: { title: "数据视图", lang: ["数据视图", "关闭", "刷新"] },
      dataZoom: { title: { zoom: "区域缩放", back: "区域缩放还原" } },
      magicType: {
        title: {
          line: "切换为折线图", bar: "切换为柱状图", stack: "切换为堆叠", tiled: "切换为平铺",
        },
      },
      restore: { title: "还原" },
      saveAsImage: { title: "保存为图片", lang: ["右键另存为图片"] },
    },
    series: {
      typeNames: {
        pie: "饼图", bar: "柱状图", line: "折线图", scatter: "散点图", effectScatter: "涟漪散点图", radar: "雷达图", tree: "树图", treemap: "矩形树图", boxplot: "箱型图", candlestick: "K线图", k: "K线图", heatmap: "热力图", map: "地图", parallel: "平行坐标图", lines: "线图", graph: "关系图", sankey: "桑基图", funnel: "漏斗图", gauge: "仪表盘图", pictorialBar: "象形柱图", themeRiver: "主题河流图", sunburst: "旭日图",
      },
    },
    aria: {
      general: { withTitle: "这是一个关于“{title}”的图表。", withoutTitle: "这是一个图表，" },
      series: {
        single: { prefix: "", withName: "图表类型是{seriesType}，表示{seriesName}。", withoutName: "图表类型是{seriesType}。" },
        multiple: {
          prefix: "它由{seriesCount}个图表系列组成。", withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，", withoutName: "第{seriesId}个系列是一个{seriesType}，", separator: { middle: "；", end: "。" },
        },
      },
      data: {
        allData: "其数据是——", partialData: "其中，前{displayCnt}项是——", withName: "{name}的数据是{value}", withoutName: "{value}", separator: { middle: "，", end: "" },
      },
    },
  }; var lT = function (t, e) { function i(t, e) { if (typeof t !== "string") return t; let i = t; return d(e, (t, e) => { i = i.replace(new RegExp(`\\{\\s*${e}\\s*\\}`, "g"), t); }), i; } function n(t) { const e = a.get(t); if (e == null) { for (var i = t.split("."), n = sT.aria, o = 0; o < i.length; ++o)n = n[i[o]]; return n; } return e; } function o(t) { return sT.series.typeNames[t] || "自定义图"; } var a = e.getModel("aria"); if (a.get("show")) if (a.get("description"))t.setAttribute("aria-label", a.get("description")); else { let r = 0; e.eachSeries((t, e) => { ++r; }, this); let s; const l = a.get("data.maxCount") || 10; const u = a.get("series.maxCount") || 10; const h = Math.min(r, u); if (!(r < 1)) { const c = (function () { let t = e.getModel("title").option; return t && t.length && (t = t[0]), t && t.text; }()); s = c ? i(n("general.withTitle"), { title: c }) : n("general.withoutTitle"); const f = []; s += i(n(r > 1 ? "series.multiple.prefix" : "series.single.prefix"), { seriesCount: r }), e.eachSeries((t, e) => { if (e < h) { let a; const s = t.get("name"); const u = `series.${r > 1 ? "multiple" : "single"}.`; a = i(a = n(s ? `${u}withName` : `${u}withoutName`), { seriesId: t.seriesIndex, seriesName: t.get("name"), seriesType: o(t.subType) }); const c = t.getData(); window.data = c, c.count() > l ? a += i(n("data.partialData"), { displayCnt: l }) : a += n("data.allData"); for (var d = [], p = 0; p < c.count(); p++) if (p < l) { const g = c.getName(p); const m = dr(c, p); d.push(i(n(g ? "data.withName" : "data.withoutName"), { name: g, value: m })); }a += d.join(n("data.separator.middle")) + n("data.separator.end"), f.push(a); } }), s += f.join(n("series.multiple.separator.middle")) + n("series.multiple.separator.end"), t.setAttribute("aria-label", s); } } }; const uT = Math.PI; const hT = Or.prototype; hT.restoreData = function (t, e) { t.restoreData(e), this._stageTaskMap.each((t) => { const e = t.overallTask; e && e.dirty(); }); }, hT.getPerformArgs = function (t, e) { if (t.__pipeline) { const i = this._pipelineMap.get(t.__pipeline.id); const n = i.context; const o = !e && i.progressiveEnabled && (!n || n.progressiveRender) && t.__idxInPipeline > i.blockIndex ? i.step : null; const a = n && n.modDataCount; return { step: o, modBy: a != null ? Math.ceil(a / o) : null, modDataCount: a }; } }, hT.getPipeline = function (t) { return this._pipelineMap.get(t); }, hT.updateStreamModes = function (t, e) { const i = this._pipelineMap.get(t.uid); const n = t.getData().count(); const o = i.progressiveEnabled && e.incrementalPrepareRender && n >= i.threshold; const a = t.get("large") && n >= t.get("largeThreshold"); const r = t.get("progressiveChunkMode") === "mod" ? n : null; t.pipelineContext = i.context = { progressiveRender: o, modDataCount: r, large: a }; }, hT.restorePipelines = function (t) {
    const e = this; const i = e._pipelineMap = R(); t.eachSeries((t) => {
      const n = t.getProgressive(); const o = t.uid; i.set(o, {
        id: o, head: null, tail: null, threshold: t.getProgressiveThreshold(), progressiveEnabled: n && !(t.preventIncremental && t.preventIncremental()), blockIndex: -1, step: Math.round(n || 700), count: 0,
      }), Xr(e, t, t.dataTask);
    });
  }, hT.prepareStageTasks = function () { const t = this._stageTaskMap; const e = this.ecInstance.getModel(); const i = this.api; d(this._allHandlers, function (n) { const o = t.get(n.uid) || t.set(n.uid, []); n.reset && Rr(this, n, o, e, i), n.overallReset && zr(this, n, o, e, i); }, this); }, hT.prepareView = function (t, e, i, n) { const o = t.renderTask; const a = o.context; a.model = e, a.ecModel = i, a.api = n, o.__block = !t.incrementalPrepareRender, Xr(this, e, o); }, hT.performDataProcessorTasks = function (t, e) { Er(this, this._dataProcessorHandlers, t, e, { block: !0 }); }, hT.performVisualTasks = function (t, e, i) { Er(this, this._visualHandlers, t, e, i); }, hT.performSeriesTasks = function (t) { let e; t.eachSeries((t) => { e |= t.dataTask.perform(); }), this.unfinished |= e; }, hT.plan = function () { this._pipelineMap.each((t) => { let e = t.tail; do { if (e.__block) { t.blockIndex = e.__idxInPipeline; break; }e = e.getUpstream(); } while (e); }); }; var cT = hT.updatePayload = function (t, e) { e !== "remain" && (t.context.payload = e); }; var dT = Zr(0); Or.wrapStageHandler = function (t, e) { return x(t) && (t = { overallReset: t, seriesType: jr(t) }), t.uid = Eo("stageHandler"), e && (t.visualType = e), t; }; let fT; var pT = {}; var gT = {}; Yr(pT, II), Yr(gT, Va), pT.eachSeriesByType = pT.eachRawSeriesByType = function (t) { fT = t; }, pT.eachComponent = function (t) { t.mainType === "series" && t.subType && (fT = t.subType); }; const mT = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"]; const vT = { color: mT, colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], mT] }; const yT = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"]; const xT = {
    color: yT,
    backgroundColor: "#333",
    tooltip: { axisPointer: { lineStyle: { color: "#eee" }, crossStyle: { color: "#eee" } } },
    legend: { textStyle: { color: "#eee" } },
    textStyle: { color: "#eee" },
    title: { textStyle: { color: "#eee" } },
    toolbox: { iconStyle: { normal: { borderColor: "#eee" } } },
    dataZoom: { textStyle: { color: "#eee" } },
    visualMap: { textStyle: { color: "#eee" } },
    timeline: {
      lineStyle: { color: "#eee" }, itemStyle: { normal: { color: yT[1] } }, label: { normal: { textStyle: { color: "#eee" } } }, controlStyle: { normal: { color: "#eee", borderColor: "#eee" } },
    },
    timeAxis: {
      axisLine: { lineStyle: { color: "#eee" } }, axisTick: { lineStyle: { color: "#eee" } }, axisLabel: { textStyle: { color: "#eee" } }, splitLine: { lineStyle: { type: "dashed", color: "#aaa" } }, splitArea: { areaStyle: { color: "#eee" } },
    },
    logAxis: {
      axisLine: { lineStyle: { color: "#eee" } }, axisTick: { lineStyle: { color: "#eee" } }, axisLabel: { textStyle: { color: "#eee" } }, splitLine: { lineStyle: { type: "dashed", color: "#aaa" } }, splitArea: { areaStyle: { color: "#eee" } },
    },
    valueAxis: {
      axisLine: { lineStyle: { color: "#eee" } }, axisTick: { lineStyle: { color: "#eee" } }, axisLabel: { textStyle: { color: "#eee" } }, splitLine: { lineStyle: { type: "dashed", color: "#aaa" } }, splitArea: { areaStyle: { color: "#eee" } },
    },
    categoryAxis: {
      axisLine: { lineStyle: { color: "#eee" } }, axisTick: { lineStyle: { color: "#eee" } }, axisLabel: { textStyle: { color: "#eee" } }, splitLine: { lineStyle: { type: "dashed", color: "#aaa" } }, splitArea: { areaStyle: { color: "#eee" } },
    },
    line: { symbol: "circle" },
    graph: { color: yT },
    gauge: { title: { textStyle: { color: "#eee" } } },
    candlestick: {
      itemStyle: {
        normal: {
          color: "#FD1050", color0: "#0CF49B", borderColor: "#FD1050", borderColor0: "#0CF49B",
        },
      },
    },
  }; xT.categoryAxis.splitLine.show = !1, uI.extend({
    type: "dataset",
    defaultOption: {
      seriesLayoutBy: wI, sourceHeader: null, dimensions: null, source: null,
    },
    optionUpdated() { _a(this); },
  }), KI.extend({ type: "dataset" }); const _T = kn.extend({
    type: "ellipse",
    shape: {
      cx: 0, cy: 0, rx: 0, ry: 0,
    },
    buildPath(t, e) { const i = 0.5522848; const n = e.cx; const o = e.cy; const a = e.rx; const r = e.ry; const s = a * i; const l = r * i; t.moveTo(n - a, o), t.bezierCurveTo(n - a, o - l, n - s, o - r, n, o - r), t.bezierCurveTo(n + s, o - r, n + a, o - l, n + a, o), t.bezierCurveTo(n + a, o + l, n + s, o + r, n, o + r), t.bezierCurveTo(n - s, o + r, n - a, o + l, n - a, o), t.closePath(); },
  }); var wT = /[\s,]+/; Kr.prototype.parse = function (t, e) {
    e = e || {}; const i = qr(t); if (!i) throw new Error("Illegal svg"); let n = new tb(); this._root = n; const o = i.getAttribute("viewBox") || ""; let a = parseFloat(i.getAttribute("width") || e.width); let r = parseFloat(i.getAttribute("height") || e.height); isNaN(a) && (a = null), isNaN(r) && (r = null), ts(i, n, null, !0); for (let s = i.firstChild; s;) this._parseNode(s, n), s = s.nextSibling; let l; let u; if (o) {
      const h = P(o).split(wT); h.length >= 4 && (l = {
        x: parseFloat(h[0] || 0), y: parseFloat(h[1] || 0), width: parseFloat(h[2]), height: parseFloat(h[3]),
      });
    } if (l && a != null && r != null && (u = os(l, a, r), !e.ignoreViewBox)) { const c = n; (n = new tb()).add(c), c.scale = u.scale.slice(), c.position = u.position.slice(); } return e.ignoreRootClip || a == null || r == null || n.setClipPath(new yM({
      shape: {
        x: 0, y: 0, width: a, height: r,
      },
    })), {
      root: n, width: a, height: r, viewBoxRect: l, viewBoxTransform: u,
    };
  }, Kr.prototype._parseNode = function (t, e) { const i = t.nodeName.toLowerCase(); i === "defs" ? this._isDefine = !0 : i === "text" && (this._isText = !0); let n; if (this._isDefine) { if (r = ST[i]) { const o = r.call(this, t); const a = t.getAttribute("id"); a && (this._defs[a] = o); } } else { var r = bT[i]; r && (n = r.call(this, t, e), e.add(n)); } for (let s = t.firstChild; s;)s.nodeType === 1 && this._parseNode(s, n), s.nodeType === 3 && this._isText && this._parseText(s, n), s = s.nextSibling; i === "defs" ? this._isDefine = !1 : i === "text" && (this._isText = !1); }, Kr.prototype._parseText = function (t, e) { if (t.nodeType === 1) { const i = t.getAttribute("dx") || 0; const n = t.getAttribute("dy") || 0; this._textX += parseFloat(i), this._textY += parseFloat(n); } const o = new rM({ style: { text: t.textContent, transformText: !0 }, position: [this._textX || 0, this._textY || 0] }); Jr(e, o), ts(t, o, this._defs); const a = o.style.fontSize; a && a < 9 && (o.style.fontSize = 9, o.scale = o.scale || [1, 1], o.scale[0] *= a / 9, o.scale[1] *= a / 9); const r = o.getBoundingRect(); return this._textX += r.width, e.add(o), o; }; var bT = {
    g(t, e) { const i = new tb(); return Jr(e, i), ts(t, i, this._defs), i; },
    rect(t, e) {
      const i = new yM(); return Jr(e, i), ts(t, i, this._defs), i.setShape({
        x: parseFloat(t.getAttribute("x") || 0), y: parseFloat(t.getAttribute("y") || 0), width: parseFloat(t.getAttribute("width") || 0), height: parseFloat(t.getAttribute("height") || 0),
      }), i;
    },
    circle(t, e) { const i = new sM(); return Jr(e, i), ts(t, i, this._defs), i.setShape({ cx: parseFloat(t.getAttribute("cx") || 0), cy: parseFloat(t.getAttribute("cy") || 0), r: parseFloat(t.getAttribute("r") || 0) }), i; },
    line(t, e) {
      const i = new _M(); return Jr(e, i), ts(t, i, this._defs), i.setShape({
        x1: parseFloat(t.getAttribute("x1") || 0), y1: parseFloat(t.getAttribute("y1") || 0), x2: parseFloat(t.getAttribute("x2") || 0), y2: parseFloat(t.getAttribute("y2") || 0),
      }), i;
    },
    ellipse(t, e) {
      const i = new _T(); return Jr(e, i), ts(t, i, this._defs), i.setShape({
        cx: parseFloat(t.getAttribute("cx") || 0), cy: parseFloat(t.getAttribute("cy") || 0), rx: parseFloat(t.getAttribute("rx") || 0), ry: parseFloat(t.getAttribute("ry") || 0),
      }), i;
    },
    polygon(t, e) { let i = t.getAttribute("points"); i && (i = Qr(i)); const n = new pM({ shape: { points: i || [] } }); return Jr(e, n), ts(t, n, this._defs), n; },
    polyline(t, e) { const i = new kn(); Jr(e, i), ts(t, i, this._defs); let n = t.getAttribute("points"); return n && (n = Qr(n)), new gM({ shape: { points: n || [] } }); },
    image(t, e) {
      const i = new fi(); return Jr(e, i), ts(t, i, this._defs), i.setStyle({
        image: t.getAttribute("xlink:href"), x: t.getAttribute("x"), y: t.getAttribute("y"), width: t.getAttribute("width"), height: t.getAttribute("height"),
      }), i;
    },
    text(t, e) { const i = t.getAttribute("x") || 0; const n = t.getAttribute("y") || 0; const o = t.getAttribute("dx") || 0; const a = t.getAttribute("dy") || 0; this._textX = parseFloat(i) + parseFloat(o), this._textY = parseFloat(n) + parseFloat(a); const r = new tb(); return Jr(e, r), ts(t, r, this._defs), r; },
    tspan(t, e) { const i = t.getAttribute("x"); const n = t.getAttribute("y"); i != null && (this._textX = parseFloat(i)), n != null && (this._textY = parseFloat(n)); const o = t.getAttribute("dx") || 0; const a = t.getAttribute("dy") || 0; const r = new tb(); return Jr(e, r), ts(t, r, this._defs), this._textX += o, this._textY += a, r; },
    path(t, e) { const i = En(t.getAttribute("d") || ""); return Jr(e, i), ts(t, i, this._defs), i; },
  }; var ST = { lineargradient(t) { const e = parseInt(t.getAttribute("x1") || 0, 10); const i = parseInt(t.getAttribute("y1") || 0, 10); const n = parseInt(t.getAttribute("x2") || 10, 10); const o = parseInt(t.getAttribute("y2") || 0, 10); const a = new TM(e, i, n, o); return $r(t, a), a; }, radialgradient(t) {} }; var MT = {
    fill: "fill", stroke: "stroke", "stroke-width": "lineWidth", opacity: "opacity", "fill-opacity": "fillOpacity", "stroke-opacity": "strokeOpacity", "stroke-dasharray": "lineDash", "stroke-dashoffset": "lineDashOffset", "stroke-linecap": "lineCap", "stroke-linejoin": "lineJoin", "stroke-miterlimit": "miterLimit", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "text-align": "textAlign", "alignment-baseline": "textBaseline",
  }; var IT = /url\(\s*#(.*?)\)/; var TT = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g; var AT = /([^\s:;]+)\s*:\s*([^:;]+)/g; const DT = R(); var CT = { registerMap(t, e, i) { let n; return y(e) ? n = e : e.svg ? n = [{ type: "svg", source: e.svg, specialAreas: e.specialAreas }] : (e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), n = [{ type: "geoJSON", source: e, specialAreas: i }]), d(n, (t) => { let e = t.type; e === "geoJson" && (e = t.type = "geoJSON"), (0, LT[e])(t); }), DT.set(t, n); }, retrieveMap(t) { return DT.get(t); } }; var LT = { geoJSON(t) { const e = t.source; t.geoJSON = _(e) ? typeof JSON !== "undefined" && JSON.parse ? JSON.parse(e) : new Function(`return (${e});`)() : e; }, svg(t) { t.svgXML = qr(t.source); } }; var kT = k; var PT = d; var NT = x; var OT = w; var ET = uI.parseClassType; const RT = { zrender: "4.0.6" }; var zT = 1e3; var BT = 1e3; var VT = 3e3; const GT = {
    PROCESSOR: { FILTER: zT, STATISTIC: 5e3 },
    VISUAL: {
      LAYOUT: BT, GLOBAL: 2e3, CHART: VT, COMPONENT: 4e3, BRUSH: 5e3,
    },
  }; var FT = "__flagInMainProcess"; var WT = "__optionUpdated"; var HT = /^[a-zA-Z0-9_]+$/; ss.prototype.on = rs("on"), ss.prototype.off = rs("off"), ss.prototype.one = rs("one"), h(ss, fw); const ZT = ls.prototype; ZT._onframe = function () { if (!this._disposed) { const t = this._scheduler; if (this[WT]) { const e = this[WT].silent; this[FT] = !0, hs(this), UT.update.call(this), this[FT] = !1, this[WT] = !1, ps.call(this, e), gs.call(this, e); } else if (t.unfinished) { let i = 1; const n = this._model; this._api; t.unfinished = !1; do { const o = +new Date(); t.performSeriesTasks(n), t.performDataProcessorTasks(n), ds(this, n), t.performVisualTasks(n), ws(this, this._model, 0, "remain"), i -= +new Date() - o; } while (i > 0 && t.unfinished);t.unfinished || this._zr.flush(); } } }, ZT.getDom = function () { return this._dom; }, ZT.getZr = function () { return this._zr; }, ZT.setOption = function (t, e, i) { let n; if (OT(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[FT] = !0, !this._model || e) { const o = new Fa(this._api); const a = this._theme; const r = this._model = new II(null, null, a, o); r.scheduler = this._scheduler, r.init(null, null, a, o); } this._model.setOption(t, KT), i ? (this[WT] = { silent: n }, this[FT] = !1) : (hs(this), UT.update.call(this), this._zr.flush(), this[WT] = !1, this[FT] = !1, ps.call(this, n), gs.call(this, n)); }, ZT.setTheme = function () { console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0"); }, ZT.getModel = function () { return this._model; }, ZT.getOption = function () { return this._model && this._model.getOption(); }, ZT.getWidth = function () { return this._zr.getWidth(); }, ZT.getHeight = function () { return this._zr.getHeight(); }, ZT.getDevicePixelRatio = function () { return this._zr.painter.dpr || window.devicePixelRatio || 1; }, ZT.getRenderedCanvas = function (t) { if (U_.canvasSupported) return (t = t || {}).pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor"), this._zr.painter.getRenderedCanvas(t); }, ZT.getSvgDataUrl = function () { if (U_.svgSupported) { const t = this._zr; return d(t.storage.getDisplayList(), (t) => { t.stopAnimation(!0); }), t.painter.pathToDataUrl(); } }, ZT.getDataURL = function (t) { const e = (t = t || {}).excludeComponents; const i = this._model; const n = []; const o = this; PT(e, (t) => { i.eachComponent({ mainType: t }, (t) => { const e = o._componentsMap[t.__viewId]; e.group.ignore || (n.push(e), e.group.ignore = !0); }); }); const a = this._zr.painter.getType() === "svg" ? this.getSvgDataUrl() : this.getRenderedCanvas(t).toDataURL(`image/${t && t.type || "png"}`); return PT(n, (t) => { t.group.ignore = !1; }), a; }, ZT.getConnectedDataURL = function (t) { if (U_.canvasSupported) { const e = this.group; const n = Math.min; const o = Math.max; if (iA[e]) { let a = 1 / 0; let r = 1 / 0; let s = -1 / 0; let l = -1 / 0; const u = []; const h = t && t.pixelRatio || 1; d(eA, (h, c) => { if (h.group === e) { const d = h.getRenderedCanvas(i(t)); const f = h.getDom().getBoundingClientRect(); a = n(f.left, a), r = n(f.top, r), s = o(f.right, s), l = o(f.bottom, l), u.push({ dom: d, left: f.left, top: f.top }); } }); const c = (s *= h) - (a *= h); const f = (l *= h) - (r *= h); const p = iw(); p.width = c, p.height = f; const g = Ii(p); return PT(u, (t) => { const e = new fi({ style: { x: t.left * h - a, y: t.top * h - r, image: t.dom } }); g.add(e); }), g.refreshImmediately(), p.toDataURL(`image/${t && t.type || "png"}`); } return this.getDataURL(t); } }, ZT.convertToPixel = v(us, "convertToPixel"), ZT.convertFromPixel = v(us, "convertFromPixel"), ZT.containPixel = function (t, e) { let i; return t = Vi(this._model, t), d(t, function (t, n) { n.indexOf("Models") >= 0 && d(t, function (t) { const o = t.coordinateSystem; if (o && o.containPoint)i |= !!o.containPoint(e); else if (n === "seriesModels") { const a = this._chartsMap[t.__viewId]; a && a.containPoint && (i |= a.containPoint(e, t)); } }, this); }, this), !!i; }, ZT.getVisual = function (t, e) { const i = (t = Vi(this._model, t, { defaultMainType: "series" })).seriesModel.getData(); const n = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? i.indexOfRawIndex(t.dataIndex) : null; return n != null ? i.getItemVisual(n, e) : i.getVisual(e); }, ZT.getViewOfComponentModel = function (t) { return this._componentsMap[t.__viewId]; }, ZT.getViewOfSeriesModel = function (t) { return this._chartsMap[t.__viewId]; }; var UT = {
    prepareAndUpdate(t) { hs(this), UT.update.call(this, t); }, update(t) { const e = this._model; const i = this._api; const n = this._zr; const o = this._coordSysMgr; const a = this._scheduler; if (e) { a.restoreData(e, t), a.performSeriesTasks(e), o.create(e, i), a.performDataProcessorTasks(e, t), ds(this, e), o.update(e, i), ys(e), a.performVisualTasks(e, t), xs(this, e, i, t); let r = e.get("backgroundColor") || "transparent"; if (U_.canvasSupported)n.setBackgroundColor(r); else { const s = Gt(r); r = qt(s, "rgb"), s[3] === 0 && (r = "transparent"); }bs(e, i); } }, updateTransform(t) { const e = this._model; const i = this; const n = this._api; if (e) { const o = []; e.eachComponent((a, r) => { const s = i.getViewOfComponentModel(r); if (s && s.__alive) if (s.updateTransform) { const l = s.updateTransform(r, e, n, t); l && l.update && o.push(s); } else o.push(s); }); const a = R(); e.eachSeries((o) => { const r = i._chartsMap[o.__viewId]; if (r.updateTransform) { const s = r.updateTransform(o, e, n, t); s && s.update && a.set(o.uid, 1); } else a.set(o.uid, 1); }), ys(e), this._scheduler.performVisualTasks(e, t, { setDirty: !0, dirtyMap: a }), ws(i, e, 0, t, a), bs(e, this._api); } }, updateView(t) { const e = this._model; e && (Tr.markUpdateMethod(t, "updateView"), ys(e), this._scheduler.performVisualTasks(e, t, { setDirty: !0 }), xs(this, this._model, this._api, t), bs(e, this._api)); }, updateVisual(t) { UT.update.call(this, t); }, updateLayout(t) { UT.update.call(this, t); },
  }; ZT.resize = function (t) { this._zr.resize(t); const e = this._model; if (this._loadingFX && this._loadingFX.resize(), e) { const i = e.resetOption("media"); const n = t && t.silent; this[FT] = !0, i && hs(this), UT.update.call(this), this[FT] = !1, ps.call(this, n), gs.call(this, n); } }, ZT.showLoading = function (t, e) { if (OT(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), tA[t]) { const i = tA[t](this._api, e); const n = this._zr; this._loadingFX = i, n.add(i); } }, ZT.hideLoading = function () { this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null; }, ZT.makeActionFromEvent = function (t) { const e = a({}, t); return e.type = YT[t.type], e; }, ZT.dispatchAction = function (t, e) { OT(e) || (e = { silent: !!e }), jT[t.type] && this._model && (this[FT] ? this._pendingActions.push(t) : (fs.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : !1 !== e.flush && U_.browser.weChat && this._throttledZrFlush(), ps.call(this, e.silent), gs.call(this, e.silent))); }, ZT.appendData = function (t) { const e = t.seriesIndex; this.getModel().getSeriesByIndex(e).appendData(t), this._scheduler.unfinished = !0; }, ZT.on = rs("on"), ZT.off = rs("off"), ZT.one = rs("one"); const XT = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"]; ZT._initEvents = function () {
    PT(XT, function (t) {
      const e = function (e) {
        let i; const n = this.getModel(); const o = e.target; if (t === "globalout")i = {}; else if (o && o.dataIndex != null) { const r = o.dataModel || n.getSeriesByIndex(o.seriesIndex); i = r && r.getDataParams(o.dataIndex, o.dataType, o) || {}; } else o && o.eventData && (i = a({}, o.eventData)); if (i) {
          let s = i.componentType; let l = i.componentIndex; s !== "markLine" && s !== "markPoint" && s !== "markArea" || (s = "series", l = i.seriesIndex); const u = s && l != null && n.getComponent(s, l); const h = u && this[u.mainType === "series" ? "_chartsMap" : "_componentsMap"][u.__viewId]; i.event = e, i.type = t, this._ecEventProcessor.eventInfo = {
            targetEl: o, packedEvent: i, model: u, view: h,
          }, this.trigger(t, i);
        }
      }; e.zrEventfulCallAtLast = !0, this._zr.on(t, e, this);
    }, this), PT(YT, function (t, e) { this._messageCenter.on(e, function (t) { this.trigger(e, t); }, this); }, this);
  }, ZT.isDisposed = function () { return this._disposed; }, ZT.clear = function () { this.setOption({ series: [] }, !0); }, ZT.dispose = function () { if (!this._disposed) { this._disposed = !0, Fi(this.getDom(), aA, ""); const t = this._api; const e = this._model; PT(this._componentsViews, (i) => { i.dispose(e, t); }), PT(this._chartsViews, (i) => { i.dispose(e, t); }), this._zr.dispose(), delete eA[this.id]; } }, h(ls, fw), As.prototype = {
    constructor: As, normalizeQuery(t) { const e = {}; const i = {}; const n = {}; if (_(t)) { const o = ET(t); e.mainType = o.main || null, e.subType = o.sub || null; } else { const a = ["Index", "Name", "Id"]; const r = { name: 1, dataIndex: 1, dataType: 1 }; d(t, (t, o) => { for (var s = !1, l = 0; l < a.length; l++) { const u = a[l]; const h = o.lastIndexOf(u); if (h > 0 && h === o.length - u.length) { const c = o.slice(0, h); c !== "data" && (e.mainType = c, e[u.toLowerCase()] = t, s = !0); } }r.hasOwnProperty(o) && (i[o] = t, s = !0), s || (n[o] = t); }); } return { cptQuery: e, dataQuery: i, otherQuery: n }; }, filter(t, e, i) { function n(t, e, i, n) { return t[i] == null || e[n || i] === t[i]; } const o = this.eventInfo; if (!o) return !0; const a = o.targetEl; const r = o.packedEvent; const s = o.model; const l = o.view; if (!s || !l) return !0; const u = e.cptQuery; const h = e.dataQuery; return n(u, s, "mainType") && n(u, s, "subType") && n(u, s, "index", "componentIndex") && n(u, s, "name") && n(u, s, "id") && n(h, r, "name") && n(h, r, "dataIndex") && n(h, r, "dataType") && (!l.filterForExposedEvent || l.filterForExposedEvent(t, e.otherQuery, a, r)); }, afterTrigger() { this.eventInfo = null; },
  }; var jT = {}; var YT = {}; var qT = []; var KT = []; var $T = []; var JT = []; var QT = {}; var tA = {}; var eA = {}; var iA = {}; let nA = new Date() - 0; let oA = new Date() - 0; var aA = "_echarts_instance_"; const rA = Cs; zs(2e3, rT), Ps(VI), Ns(5e3, (t) => {
    const e = R(); t.eachSeries((t) => {
      const i = t.get("stack"); if (i) {
        const n = e.get(i) || e.set(i, []); const o = t.getData(); const a = {
          stackResultDimension: o.getCalculationInfo("stackResultDimension"), stackedOverDimension: o.getCalculationInfo("stackedOverDimension"), stackedDimension: o.getCalculationInfo("stackedDimension"), stackedByDimension: o.getCalculationInfo("stackedByDimension"), isStackedByIndex: o.getCalculationInfo("isStackedByIndex"), data: o, seriesModel: t,
        }; if (!a.stackedDimension || !a.isStackedByIndex && !a.stackedByDimension) return; n.length && o.setCalculationInfo("stackedOnSeries", n[n.length - 1].seriesModel), n.push(a);
      }
    }), e.each(or);
  }), Vs("default", (t, e) => {
    r(e = e || {}, {
      text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0,
    }); const i = new yM({ style: { fill: e.maskColor }, zlevel: e.zlevel, z: 1e4 }); const n = new SM({
      shape: { startAngle: -uT / 2, endAngle: -uT / 2 + 0.1, r: 10 }, style: { stroke: e.color, lineCap: "round", lineWidth: 5 }, zlevel: e.zlevel, z: 10001,
    }); const o = new yM({
      style: {
        fill: "none", text: e.text, textPosition: "right", textDistance: 10, textFill: e.textColor,
      },
      zlevel: e.zlevel,
      z: 10001,
    }); n.animateShape(!0).when(1e3, { endAngle: 3 * uT / 2 }).start("circularInOut"), n.animateShape(!0).when(1e3, { startAngle: 3 * uT / 2 }).delay(300).start("circularInOut"); const a = new tb(); return a.add(n), a.add(o), a.add(i), a.resize = function () {
      const e = t.getWidth() / 2; const a = t.getHeight() / 2; n.setShape({ cx: e, cy: a }); const { r } = n.shape; o.setShape({
        x: e - r, y: a - r, width: 2 * r, height: 2 * r,
      }), i.setShape({
        x: 0, y: 0, width: t.getWidth(), height: t.getHeight(),
      });
    }, a.resize(), a;
  }), Os({ type: "highlight", event: "highlight", update: "highlight" }, B), Os({ type: "downplay", event: "downplay", update: "downplay" }, B), ks("light", vT), ks("dark", xT); const sA = {}; Us.prototype = {
    constructor: Us, add(t) { return this._add = t, this; }, update(t) { return this._update = t, this; }, remove(t) { return this._remove = t, this; }, execute() { const t = this._old; const e = this._new; const i = {}; const n = []; const o = []; for (Xs(t, {}, n, "_oldKeyGetter", this), Xs(e, i, o, "_newKeyGetter", this), a = 0; a < t.length; a++)(s = i[r = n[a]]) != null ? ((u = s.length) ? (u === 1 && (i[r] = null), s = s.unshift()) : i[r] = null, this._update && this._update(s, a)) : this._remove && this._remove(a); for (var a = 0; a < o.length; a++) { var r = o[a]; if (i.hasOwnProperty(r)) { var s = i[r]; if (s == null) continue; if (s.length) for (var l = 0, u = s.length; l < u; l++) this._add && this._add(s[l]); else this._add && this._add(s); } } },
  }; var lA = R(["tooltip", "label", "itemName", "itemId", "seriesName"]); const uA = w; var hA = -1; var cA = "e\0\0"; var dA = {
    float: typeof Float64Array === "undefined" ? Array : Float64Array, int: typeof Int32Array === "undefined" ? Array : Int32Array, ordinal: Array, number: Array, time: Array,
  }; var fA = typeof Uint32Array === "undefined" ? Array : Uint32Array; var pA = typeof Int32Array === "undefined" ? Array : Int32Array; var gA = typeof Uint16Array === "undefined" ? Array : Uint16Array; var mA = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"]; var vA = ["_extent", "_approximateExtent", "_rawExtent"]; var yA = function (t, e) { t = t || ["x", "y"]; for (var i = {}, n = [], o = {}, a = 0; a < t.length; a++) { let r = t[a]; _(r) && (r = { name: r }); const s = r.name; r.type = r.type || "float", r.coordDim || (r.coordDim = s, r.coordDimIndex = 0), r.otherDims = r.otherDims || {}, n.push(s), i[s] = r, r.index = a, r.createInvertedIndices && (o[s] = []); } this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], this._graphicEls = [], this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, this._rawExtent = {}, this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = js(this), this._invertedIndicesMap = o, this._calculationInfo = {}; }; const xA = yA.prototype; xA.type = "list", xA.hasItemOption = !0, xA.getDimension = function (t) { return isNaN(t) || (t = this.dimensions[t] || t), t; }, xA.getDimensionInfo = function (t) { return this._dimensionInfos[this.getDimension(t)]; }, xA.getDimensionsOnCoord = function () { return this._dimensionsSummary.dataDimsOnCoord.slice(); }, xA.mapDimension = function (t, e) { const i = this._dimensionsSummary; if (e == null) return i.encodeFirstDimNotExtra[t]; const n = i.encode[t]; return !0 === e ? (n || []).slice() : n && n[e]; }, xA.initData = function (t, e, i) { (xa.isInstance(t) || c(t)) && (t = new ar(t, this.dimensions.length)), this._rawData = t, this._storage = {}, this._indices = null, this._nameList = e || [], this._idList = [], this._nameRepeatCount = {}, i || (this.hasItemOption = !1), this.defaultDimValueGetter = HI[this._rawData.getSource().sourceFormat], this._dimValueGetter = i = i || this.defaultDimValueGetter, this._dimValueGetterArrayRows = HI.arrayRows, this._rawExtent = {}, this._initDataFromProvider(0, t.count()), t.pure && (this.hasItemOption = !1); }, xA.getProvider = function () { return this._rawData; }, xA.appendData = function (t) { const e = this._rawData; const i = this.count(); e.appendData(t); let n = e.count(); e.persistent || (n += i), this._initDataFromProvider(i, n); }, xA.appendValues = function (t, e) { for (var i = this._chunkSize, n = this._storage, o = this.dimensions, a = o.length, r = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e ? e.length : 0), u = this._chunkCount, h = 0; h < a; h++)r[v = o[h]] || (r[v] = [1 / 0, -1 / 0]), n[v] || (n[v] = []), Qs(n, this._dimensionInfos[v], i, u, l), this._chunkCount = n[v].length; for (let c = new Array(a), d = s; d < l; d++) { for (var f = d - s, p = Math.floor(d / i), g = d % i, m = 0; m < a; m++) { var v = o[m]; const y = this._dimValueGetterArrayRows(t[f] || c, v, f, m); n[v][p][g] = y; const x = r[v]; y < x[0] && (x[0] = y), y > x[1] && (x[1] = y); }e && (this._nameList[d] = e[f]); } this._rawCount = this._count = l, this._extent = {}, tl(this); }, xA._initDataFromProvider = function (t, e) { if (!(t >= e)) { for (var i, n = this._chunkSize, o = this._rawData, a = this._storage, r = this.dimensions, s = r.length, l = this._dimensionInfos, u = this._nameList, h = this._idList, c = this._rawExtent, d = this._nameRepeatCount = {}, f = this._chunkCount, p = 0; p < s; p++) { c[w = r[p]] || (c[w] = [1 / 0, -1 / 0]); const g = l[w]; g.otherDims.itemName === 0 && (i = this._nameDimIdx = p), g.otherDims.itemId === 0 && (this._idDimIdx = p), a[w] || (a[w] = []), Qs(a, g, n, f, e), this._chunkCount = a[w].length; } for (let m = new Array(s), v = t; v < e; v++) { m = o.getItem(v, m); for (var y = Math.floor(v / n), x = v % n, _ = 0; _ < s; _++) { var w = r[_]; const b = a[w][y]; const S = this._dimValueGetter(m, w, v, _); b[x] = S; const M = c[w]; S < M[0] && (M[0] = S), S > M[1] && (M[1] = S); } if (!o.pure) { let I = u[v]; if (m && I == null) if (m.name != null)u[v] = I = m.name; else if (i != null) { const T = r[i]; const A = a[T][y]; if (A) { I = A[x]; const D = l[T].ordinalMeta; D && D.categories.length && (I = D.categories[I]); } } let C = m == null ? null : m.id; C == null && I != null && (d[I] = d[I] || 0, C = I, d[I] > 0 && (C += `__ec__${d[I]}`), d[I]++), C != null && (h[v] = C); } }!o.persistent && o.clean && o.clean(), this._rawCount = this._count = e, this._extent = {}, tl(this); } }, xA.count = function () { return this._count; }, xA.getIndices = function () { const t = this._indices; if (t) { var e = t.constructor; const i = this._count; if (e === Array) { n = new e(i); for (o = 0; o < i; o++)n[o] = t[o]; } else n = new e(t.buffer, 0, i); } else for (var n = new (e = Ks(this))(this.count()), o = 0; o < n.length; o++)n[o] = o; return n; }, xA.get = function (t, e) { if (!(e >= 0 && e < this._count)) return NaN; const i = this._storage; if (!i[t]) return NaN; e = this.getRawIndex(e); const n = Math.floor(e / this._chunkSize); const o = e % this._chunkSize; return i[t][n][o]; }, xA.getByRawIndex = function (t, e) { if (!(e >= 0 && e < this._rawCount)) return NaN; const i = this._storage[t]; if (!i) return NaN; const n = Math.floor(e / this._chunkSize); const o = e % this._chunkSize; return i[n][o]; }, xA._getFast = function (t, e) { const i = Math.floor(e / this._chunkSize); const n = e % this._chunkSize; return this._storage[t][i][n]; }, xA.getValues = function (t, e) { const i = []; y(t) || (e = t, t = this.dimensions); for (let n = 0, o = t.length; n < o; n++)i.push(this.get(t[n], e)); return i; }, xA.hasValue = function (t) { for (let e = this._dimensionsSummary.dataDimsOnCoord, i = this._dimensionInfos, n = 0, o = e.length; n < o; n++) if (i[e[n]].type !== "ordinal" && isNaN(this.get(e[n], t))) return !1; return !0; }, xA.getDataExtent = function (t) { t = this.getDimension(t); const e = [1 / 0, -1 / 0]; if (!this._storage[t]) return e; let i; const n = this.count(); if (!this._indices) return this._rawExtent[t].slice(); if (i = this._extent[t]) return i.slice(); for (var o = (i = e)[0], a = i[1], r = 0; r < n; r++) { const s = this._getFast(t, this.getRawIndex(r)); s < o && (o = s), s > a && (a = s); } return i = [o, a], this._extent[t] = i, i; }, xA.getApproximateExtent = function (t) { return t = this.getDimension(t), this._approximateExtent[t] || this.getDataExtent(t); }, xA.setApproximateExtent = function (t, e) { e = this.getDimension(e), this._approximateExtent[e] = t.slice(); }, xA.getCalculationInfo = function (t) { return this._calculationInfo[t]; }, xA.setCalculationInfo = function (t, e) { uA(t) ? a(this._calculationInfo, t) : this._calculationInfo[t] = e; }, xA.getSum = function (t) { let e = 0; if (this._storage[t]) for (let i = 0, n = this.count(); i < n; i++) { const o = this.get(t, i); isNaN(o) || (e += o); } return e; }, xA.getMedian = function (t) { const e = []; this.each(t, (t, i) => { isNaN(t) || e.push(t); }); const i = [].concat(e).sort((t, e) => t - e); const n = this.count(); return n === 0 ? 0 : n % 2 == 1 ? i[(n - 1) / 2] : (i[n / 2] + i[n / 2 - 1]) / 2; }, xA.rawIndexOf = function (t, e) { const i = (t && this._invertedIndicesMap[t])[e]; return i == null || isNaN(i) ? hA : i; }, xA.indexOfName = function (t) { for (let e = 0, i = this.count(); e < i; e++) if (this.getName(e) === t) return e; return -1; }, xA.indexOfRawIndex = function (t) { if (!this._indices) return t; if (t >= this._rawCount || t < 0) return -1; const e = this._indices; const i = e[t]; if (i != null && i < this._count && i === t) return t; for (let n = 0, o = this._count - 1; n <= o;) { const a = (n + o) / 2 | 0; if (e[a] < t)n = a + 1; else { if (!(e[a] > t)) return a; o = a - 1; } } return -1; }, xA.indicesOfNearest = function (t, e, i) { const n = []; if (!this._storage[t]) return n; i == null && (i = 1 / 0); for (let o = Number.MAX_VALUE, a = -1, r = 0, s = this.count(); r < s; r++) { const l = e - this.get(t, r); const u = Math.abs(l); l <= i && u <= o && ((u < o || l >= 0 && a < 0) && (o = u, a = l, n.length = 0), n.push(r)); } return n; }, xA.getRawIndex = il, xA.getRawDataItem = function (t) { if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(t)); for (var e = [], i = 0; i < this.dimensions.length; i++) { const n = this.dimensions[i]; e.push(this.get(n, t)); } return e; }, xA.getName = function (t) { const e = this.getRawIndex(t); return this._nameList[e] || el(this, this._nameDimIdx, e) || ""; }, xA.getId = function (t) { return ol(this, this.getRawIndex(t)); }, xA.each = function (t, e, i, n) { if (this._count) { typeof t === "function" && (n = i, i = e, e = t, t = []), i = i || n || this; for (let o = (t = f(al(t), this.getDimension, this)).length, a = 0; a < this.count(); a++) switch (o) { case 0: e.call(i, a); break; case 1: e.call(i, this.get(t[0], a), a); break; case 2: e.call(i, this.get(t[0], a), this.get(t[1], a), a); break; default: for (var r = 0, s = []; r < o; r++)s[r] = this.get(t[r], a); s[r] = a, e.apply(i, s); } } }, xA.filterSelf = function (t, e, i, n) { if (this._count) { typeof t === "function" && (n = i, i = e, e = t, t = []), i = i || n || this, t = f(al(t), this.getDimension, this); for (var o = this.count(), a = new (Ks(this))(o), r = [], s = t.length, l = 0, u = t[0], h = 0; h < o; h++) { var c; const d = this.getRawIndex(h); if (s === 0)c = e.call(i, h); else if (s === 1) { const p = this._getFast(u, d); c = e.call(i, p, h); } else { for (var g = 0; g < s; g++)r[g] = this._getFast(u, d); r[g] = h, c = e.apply(i, r); }c && (a[l++] = d); } return l < o && (this._indices = a), this._count = l, this._extent = {}, this.getRawIndex = this._indices ? nl : il, this; } }, xA.selectRange = function (t) { if (this._count) { const e = []; for (var i in t)t.hasOwnProperty(i) && e.push(i); const n = e.length; if (n) { const o = this.count(); const a = new (Ks(this))(o); let r = 0; const s = e[0]; const l = t[s][0]; const u = t[s][1]; let h = !1; if (!this._indices) { let c = 0; if (n === 1) { for (var d = this._storage[e[0]], f = 0; f < this._chunkCount; f++) for (var p = d[f], g = Math.min(this._count - f * this._chunkSize, this._chunkSize), m = 0; m < g; m++)((w = p[m]) >= l && w <= u || isNaN(w)) && (a[r++] = c), c++; h = !0; } else if (n === 2) { for (var d = this._storage[s], v = this._storage[e[1]], y = t[e[1]][0], x = t[e[1]][1], f = 0; f < this._chunkCount; f++) for (var p = d[f], _ = v[f], g = Math.min(this._count - f * this._chunkSize, this._chunkSize), m = 0; m < g; m++) { var w = p[m]; const b = _[m]; (w >= l && w <= u || isNaN(w)) && (b >= y && b <= x || isNaN(b)) && (a[r++] = c), c++; }h = !0; } } if (!h) if (n === 1) for (m = 0; m < o; m++) { M = this.getRawIndex(m); ((w = this._getFast(s, M)) >= l && w <= u || isNaN(w)) && (a[r++] = M); } else for (m = 0; m < o; m++) { for (var S = !0, M = this.getRawIndex(m), f = 0; f < n; f++) { const I = e[f]; ((w = this._getFast(i, M)) < t[I][0] || w > t[I][1]) && (S = !1); }S && (a[r++] = this.getRawIndex(m)); } return r < o && (this._indices = a), this._count = r, this._extent = {}, this.getRawIndex = this._indices ? nl : il, this; } } }, xA.mapArray = function (t, e, i, n) { typeof t === "function" && (n = i, i = e, e = t, t = []), i = i || n || this; const o = []; return this.each(t, function () { o.push(e && e.apply(this, arguments)); }, i), o; }, xA.map = function (t, e, i, n) { i = i || n || this; const o = rl(this, t = f(al(t), this.getDimension, this)); o._indices = this._indices, o.getRawIndex = o._indices ? nl : il; for (let a = o._storage, r = [], s = this._chunkSize, l = t.length, u = this.count(), h = [], c = o._rawExtent, d = 0; d < u; d++) { for (let p = 0; p < l; p++)h[p] = this.get(t[p], d); h[l] = d; let g = e && e.apply(i, h); if (g != null) { typeof g !== "object" && (r[0] = g, g = r); for (let m = this.getRawIndex(d), v = Math.floor(m / s), y = m % s, x = 0; x < g.length; x++) { const _ = t[x]; const w = g[x]; const b = c[_]; const S = a[_]; S && (S[v][y] = w), w < b[0] && (b[0] = w), w > b[1] && (b[1] = w); } } } return o; }, xA.downSample = function (t, e, i, n) { for (var o = rl(this, [t]), a = o._storage, r = [], s = Math.floor(1 / e), l = a[t], u = this.count(), h = this._chunkSize, c = o._rawExtent[t], d = new (Ks(this))(u), f = 0, p = 0; p < u; p += s) { s > u - p && (s = u - p, r.length = s); for (let g = 0; g < s; g++) { const m = this.getRawIndex(p + g); const v = Math.floor(m / h); const y = m % h; r[g] = l[v][y]; } const x = i(r); const _ = this.getRawIndex(Math.min(p + n(r, x) || 0, u - 1)); const w = _ % h; l[Math.floor(_ / h)][w] = x, x < c[0] && (c[0] = x), x > c[1] && (c[1] = x), d[f++] = _; } return o._count = f, o._indices = d, o.getRawIndex = nl, o; }, xA.getItemModel = function (t) { const e = this.hostModel; return new Po(this.getRawDataItem(t), e, e && e.ecModel); }, xA.diff = function (t) { const e = this; return new Us(t ? t.getIndices() : [], this.getIndices(), (e => ol(t, e)), (t => ol(e, t))); }, xA.getVisual = function (t) { const e = this._visual; return e && e[t]; }, xA.setVisual = function (t, e) { if (uA(t)) for (const i in t)t.hasOwnProperty(i) && this.setVisual(i, t[i]); else this._visual = this._visual || {}, this._visual[t] = e; }, xA.setLayout = function (t, e) { if (uA(t)) for (const i in t)t.hasOwnProperty(i) && this.setLayout(i, t[i]); else this._layout[t] = e; }, xA.getLayout = function (t) { return this._layout[t]; }, xA.getItemLayout = function (t) { return this._itemLayouts[t]; }, xA.setItemLayout = function (t, e, i) { this._itemLayouts[t] = i ? a(this._itemLayouts[t] || {}, e) : e; }, xA.clearItemLayouts = function () { this._itemLayouts.length = 0; }, xA.getItemVisual = function (t, e, i) { const n = this._itemVisuals[t]; const o = n && n[e]; return o != null || i ? o : this.getVisual(e); }, xA.setItemVisual = function (t, e, i) { const n = this._itemVisuals[t] || {}; const o = this.hasItemVisual; if (this._itemVisuals[t] = n, uA(e)) for (const a in e)e.hasOwnProperty(a) && (n[a] = e[a], o[a] = !0); else n[e] = i, o[e] = !0; }, xA.clearAllVisual = function () { this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {}; }; const _A = function (t) { t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType; }; xA.setItemGraphicEl = function (t, e) { const i = this.hostModel; e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, e.type === "group" && e.traverse(_A, e)), this._graphicEls[t] = e; }, xA.getItemGraphicEl = function (t) { return this._graphicEls[t]; }, xA.eachItemGraphicEl = function (t, e) { d(this._graphicEls, (i, n) => { i && t && t.call(e, i, n); }); }, xA.cloneShallow = function (t) { if (!t) { const e = f(this.dimensions, this.getDimensionInfo, this); t = new yA(e, this.hostModel); } if (t._storage = this._storage, Js(t, this), this._indices) { const i = this._indices.constructor; t._indices = new i(this._indices); } else t._indices = null; return t.getRawIndex = t._indices ? nl : il, t; }, xA.wrapMethod = function (t, e) { const i = this[t]; typeof i === "function" && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () { const t = i.apply(this, arguments); return e.apply(this, [t].concat(C(arguments))); }); }, xA.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], xA.CHANGABLE_METHODS = ["filterSelf", "selectRange"]; var wA = function (t, e) {
    return e = e || {}, ul(e.coordDimensions || [], t, {
      dimsDef: e.dimensionsDefine || t.dimensionsDefine, encodeDef: e.encodeDefine || t.encodeDefine, dimCount: e.dimensionsCount, generateCoord: e.generateCoord, generateCoordCount: e.generateCoordCount,
    });
  }; yl.prototype.parse = function (t) { return t; }, yl.prototype.getSetting = function (t) { return this._setting[t]; }, yl.prototype.contain = function (t) { const e = this._extent; return t >= e[0] && t <= e[1]; }, yl.prototype.normalize = function (t) { const e = this._extent; return e[1] === e[0] ? 0.5 : (t - e[0]) / (e[1] - e[0]); }, yl.prototype.scale = function (t) { const e = this._extent; return t * (e[1] - e[0]) + e[0]; }, yl.prototype.unionExtent = function (t) { const e = this._extent; t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]); }, yl.prototype.unionExtentFromData = function (t, e) { this.unionExtent(t.getApproximateExtent(e)); }, yl.prototype.getExtent = function () { return this._extent.slice(); }, yl.prototype.setExtent = function (t, e) { const i = this._extent; isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e); }, yl.prototype.isBlank = function () { return this._isBlank; }, yl.prototype.setBlank = function (t) { this._isBlank = t; }, yl.prototype.getLabel = null, Xi(yl), Ki(yl, { registerWhenExtend: !0 }), xl.createByAxisModel = function (t) { const e = t.option; const i = e.data; const n = i && f(i, wl); return new xl({ categories: n, needCollect: !n, deduplication: !1 !== e.dedplication }); }; const bA = xl.prototype; bA.getOrdinal = function (t) { return _l(this).get(t); }, bA.parseAndCollect = function (t) { let e; const i = this._needCollect; if (typeof t !== "string" && !i) return t; if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e; const n = _l(this); return (e = n.get(t)) == null && (i ? (e = this.categories.length, this.categories[e] = t, n.set(t, e)) : e = NaN), e; }; const SA = yl.prototype; var MA = yl.extend({
    type: "ordinal", init(t, e) { t && !y(t) || (t = new xl({ categories: t })), this._ordinalMeta = t, this._extent = e || [0, t.categories.length - 1]; }, parse(t) { return typeof t === "string" ? this._ordinalMeta.getOrdinal(t) : Math.round(t); }, contain(t) { return t = this.parse(t), SA.contain.call(this, t) && this._ordinalMeta.categories[t] != null; }, normalize(t) { return SA.normalize.call(this, this.parse(t)); }, scale(t) { return Math.round(SA.scale.call(this, t)); }, getTicks() { for (var t = [], e = this._extent, i = e[0]; i <= e[1];)t.push(i), i++; return t; }, getLabel(t) { if (!this.isBlank()) return this._ordinalMeta.categories[t]; }, count() { return this._extent[1] - this._extent[0] + 1; }, unionExtentFromData(t, e) { this.unionExtent(t.getApproximateExtent(e)); }, getOrdinalMeta() { return this._ordinalMeta; }, niceTicks: B, niceExtent: B,
  }); MA.create = function () { return new MA(); }; var IA = Vo; const TA = Vo; var AA = yl.extend({
    type: "interval", _interval: 0, _intervalPrecision: 2, setExtent(t, e) { const i = this._extent; isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e)); }, unionExtent(t) { const e = this._extent; t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), AA.prototype.setExtent.call(this, e[0], e[1]); }, getInterval() { return this._interval; }, setInterval(t) { this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = Sl(t); }, getTicks() { return Tl(this._interval, this._extent, this._niceExtent, this._intervalPrecision); }, getLabel(t, e) { if (t == null) return ""; let i = e && e.precision; return i == null ? i = Wo(t) || 0 : i === "auto" && (i = this._intervalPrecision), t = TA(t, i, !0), Qo(t); }, niceTicks(t, e, i) { t = t || 5; const n = this._extent; let o = n[1] - n[0]; if (isFinite(o)) { o < 0 && (o = -o, n.reverse()); const a = bl(n, t, e, i); this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent; } }, niceExtent(t) { const e = this._extent; if (e[0] === e[1]) if (e[0] !== 0) { const i = e[0]; t.fixMax ? e[0] -= i / 2 : (e[1] += i / 2, e[0] -= i / 2); } else e[1] = 1; const n = e[1] - e[0]; isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval); const o = this._interval; t.fixMin || (e[0] = TA(Math.floor(e[0] / o) * o)), t.fixMax || (e[1] = TA(Math.ceil(e[1] / o) * o)); },
  }); AA.create = function () { return new AA(); }; var DA = "__ec_stack_"; const CA = typeof Float32Array !== "undefined" ? Float32Array : Array; const LA = {
    seriesType: "bar",
    plan: JI(),
    reset(t) {
      if (El(t) && Rl(t)) {
        const e = t.getData(); const i = t.coordinateSystem; const n = i.getBaseAxis(); const o = i.getOtherAxis(n); const a = e.mapDimension(o.dim); const r = e.mapDimension(n.dim); const s = o.isHorizontal(); const l = s ? 0 : 1; let u = Nl(kl([t]), n, t).width; return u > 0.5 || (u = 0.5), {
          progress(t, e) {
            for (var n, h = new CA(2 * t.count), c = [], d = [], f = 0; (n = t.next()) != null;)d[l] = e.get(a, n), d[1 - l] = e.get(r, n), c = i.dataToPoint(d, null, c), h[f++] = c[0], h[f++] = c[1]; e.setLayout({
              largePoints: h, barWidth: u, valueAxisStart: zl(0, o), valueAxisHorizontal: s,
            });
          },
        };
      }
    },
  }; const kA = AA.prototype; const PA = Math.ceil; const NA = Math.floor; const OA = function (t, e, i, n) { for (;i < n;) { const o = i + n >>> 1; t[o][1] < e ? i = o + 1 : n = o; } return i; }; const EA = AA.extend({
    type: "time", getLabel(t) { const e = this._stepLvl; const i = new Date(t); return ra(e[0], i, this.getSetting("useUTC")); }, niceExtent(t) { const e = this._extent; if (e[0] === e[1] && (e[0] -= 864e5, e[1] += 864e5), e[1] === -1 / 0 && e[0] === 1 / 0) { const i = new Date(); e[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - 864e5; } this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval); const n = this._interval; t.fixMin || (e[0] = Vo(NA(e[0] / n) * n)), t.fixMax || (e[1] = Vo(PA(e[1] / n) * n)); }, niceTicks(t, e, i) { t = t || 10; const n = this._extent; const o = n[1] - n[0]; let a = o / t; e != null && a < e && (a = e), i != null && a > i && (a = i); const r = RA.length; const s = OA(RA, a, 0, r); const l = RA[Math.min(s, r - 1)]; let u = l[1]; l[0] === "year" && (u *= Ko(o / u / t, !0)); const h = this.getSetting("useUTC") ? 0 : 60 * new Date(+n[0] || +n[1]).getTimezoneOffset() * 1e3; const c = [Math.round(PA((n[0] - h) / u) * u + h), Math.round(NA((n[1] - h) / u) * u + h)]; Il(c, n), this._stepLvl = l, this._interval = u, this._niceExtent = c; }, parse(t) { return +jo(t); },
  }); d(["contain", "normalize"], (t) => { EA.prototype[t] = function (e) { return kA[t].call(this, this.parse(e)); }; }); var RA = [["hh:mm:ss", 1e3], ["hh:mm:ss", 5e3], ["hh:mm:ss", 1e4], ["hh:mm:ss", 15e3], ["hh:mm:ss", 3e4], ["hh:mm\nMM-dd", 6e4], ["hh:mm\nMM-dd", 3e5], ["hh:mm\nMM-dd", 6e5], ["hh:mm\nMM-dd", 9e5], ["hh:mm\nMM-dd", 18e5], ["hh:mm\nMM-dd", 36e5], ["hh:mm\nMM-dd", 72e5], ["hh:mm\nMM-dd", 216e5], ["hh:mm\nMM-dd", 432e5], ["MM-dd\nyyyy", 864e5], ["MM-dd\nyyyy", 1728e5], ["MM-dd\nyyyy", 2592e5], ["MM-dd\nyyyy", 3456e5], ["MM-dd\nyyyy", 432e6], ["MM-dd\nyyyy", 5184e5], ["week", 6048e5], ["MM-dd\nyyyy", 864e6], ["week", 12096e5], ["week", 18144e5], ["month", 26784e5], ["week", 36288e5], ["month", 53568e5], ["week", 6048e6], ["quarter", 8208e6], ["month", 107136e5], ["month", 13392e6], ["half-year", 16416e6], ["month", 214272e5], ["month", 26784e6], ["year", 32832e6]]; EA.create = function (t) { return new EA({ useUTC: t.ecModel.get("useUTC") }); }; const zA = yl.prototype; const BA = AA.prototype; var VA = Wo; var GA = Vo; const FA = Math.floor; const WA = Math.ceil; const HA = Math.pow; const ZA = Math.log; const UA = yl.extend({
    type: "log", base: 10, $constructor() { yl.apply(this, arguments), this._originalScale = new AA(); }, getTicks() { const t = this._originalScale; const e = this._extent; const i = t.getExtent(); return f(BA.getTicks.call(this), function (n) { let o = Vo(HA(this.base, n)); return o = n === e[0] && t.__fixMin ? Bl(o, i[0]) : o, o = n === e[1] && t.__fixMax ? Bl(o, i[1]) : o; }, this); }, getLabel: BA.getLabel, scale(t) { return t = zA.scale.call(this, t), HA(this.base, t); }, setExtent(t, e) { const i = this.base; t = ZA(t) / ZA(i), e = ZA(e) / ZA(i), BA.setExtent.call(this, t, e); }, getExtent() { const t = this.base; const e = zA.getExtent.call(this); e[0] = HA(t, e[0]), e[1] = HA(t, e[1]); const i = this._originalScale; const n = i.getExtent(); return i.__fixMin && (e[0] = Bl(e[0], n[0])), i.__fixMax && (e[1] = Bl(e[1], n[1])), e; }, unionExtent(t) { this._originalScale.unionExtent(t); const e = this.base; t[0] = ZA(t[0]) / ZA(e), t[1] = ZA(t[1]) / ZA(e), zA.unionExtent.call(this, t); }, unionExtentFromData(t, e) { this.unionExtent(t.getApproximateExtent(e)); }, niceTicks(t) { t = t || 10; const e = this._extent; const i = e[1] - e[0]; if (!(i === 1 / 0 || i <= 0)) { let n = Yo(i); for (t / i * n <= 0.5 && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && Math.abs(n) > 0;)n *= 10; const o = [Vo(WA(e[0] / n) * n), Vo(FA(e[1] / n) * n)]; this._interval = n, this._niceExtent = o; } }, niceExtent(t) { BA.niceExtent.call(this, t); const e = this._originalScale; e.__fixMin = t.fixMin, e.__fixMax = t.fixMax; },
  }); d(["contain", "normalize"], (t) => { UA.prototype[t] = function (e) { return e = ZA(e) / ZA(this.base), zA[t].call(this, e); }; }), UA.create = function () { return new UA(); }; const XA = {
    getMin(t) { const e = this.option; let i = t || e.rangeStart == null ? e.min : e.rangeStart; return this.axis && i != null && i !== "dataMin" && typeof i !== "function" && !I(i) && (i = this.axis.scale.parse(i)), i; }, getMax(t) { const e = this.option; let i = t || e.rangeEnd == null ? e.max : e.rangeEnd; return this.axis && i != null && i !== "dataMax" && typeof i !== "function" && !I(i) && (i = this.axis.scale.parse(i)), i; }, getNeedCrossZero() { const t = this.option; return t.rangeStart == null && t.rangeEnd == null && !t.scale; }, getCoordSysModel: B, setRange(t, e) { this.option.rangeStart = t, this.option.rangeEnd = e; }, resetRange() { this.option.rangeStart = this.option.rangeEnd = null; },
  }; const jA = Zn({
    type: "triangle",
    shape: {
      cx: 0, cy: 0, width: 0, height: 0,
    },
    buildPath(t, e) { const i = e.cx; const n = e.cy; const o = e.width / 2; const a = e.height / 2; t.moveTo(i, n - a), t.lineTo(i + o, n + a), t.lineTo(i - o, n + a), t.closePath(); },
  }); const YA = Zn({
    type: "diamond",
    shape: {
      cx: 0, cy: 0, width: 0, height: 0,
    },
    buildPath(t, e) { const i = e.cx; const n = e.cy; const o = e.width / 2; const a = e.height / 2; t.moveTo(i, n - a), t.lineTo(i + o, n), t.lineTo(i, n + a), t.lineTo(i - o, n), t.closePath(); },
  }); const qA = Zn({
    type: "pin",
    shape: {
      x: 0, y: 0, width: 0, height: 0,
    },
    buildPath(t, e) { const i = e.x; const n = e.y; const o = e.width / 5 * 3; const a = Math.max(o, e.height); const r = o / 2; const s = r * r / (a - r); const l = n - a + r + s; const u = Math.asin(s / r); const h = Math.cos(u) * r; const c = Math.sin(u); const d = Math.cos(u); const f = 0.6 * r; const p = 0.7 * r; t.moveTo(i - h, l + s), t.arc(i, l, r, Math.PI - u, 2 * Math.PI + u), t.bezierCurveTo(i + h - c * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - h + c * f, l + s + d * f, i - h, l + s), t.closePath(); },
  }); const KA = Zn({
    type: "arrow",
    shape: {
      x: 0, y: 0, width: 0, height: 0,
    },
    buildPath(t, e) { const i = e.height; const n = e.width; const o = e.x; const a = e.y; const r = n / 3 * 2; t.moveTo(o, a), t.lineTo(o + r, a + i), t.lineTo(o, a + i / 4 * 3), t.lineTo(o - r, a + i), t.lineTo(o, a), t.closePath(); },
  }); const $A = {
    line(t, e, i, n, o) { o.x1 = t, o.y1 = e + n / 2, o.x2 = t + i, o.y2 = e + n / 2; }, rect(t, e, i, n, o) { o.x = t, o.y = e, o.width = i, o.height = n; }, roundRect(t, e, i, n, o) { o.x = t, o.y = e, o.width = i, o.height = n, o.r = Math.min(i, n) / 4; }, square(t, e, i, n, o) { const a = Math.min(i, n); o.x = t, o.y = e, o.width = a, o.height = a; }, circle(t, e, i, n, o) { o.cx = t + i / 2, o.cy = e + n / 2, o.r = Math.min(i, n) / 2; }, diamond(t, e, i, n, o) { o.cx = t + i / 2, o.cy = e + n / 2, o.width = i, o.height = n; }, pin(t, e, i, n, o) { o.x = t + i / 2, o.y = e + n / 2, o.width = i, o.height = n; }, arrow(t, e, i, n, o) { o.x = t + i / 2, o.y = e + n / 2, o.width = i, o.height = n; }, triangle(t, e, i, n, o) { o.cx = t + i / 2, o.cy = e + n / 2, o.width = i, o.height = n; },
  }; const JA = {}; d({
    line: _M, rect: yM, roundRect: yM, square: yM, circle: sM, diamond: YA, pin: qA, arrow: KA, triangle: jA,
  }, (t, e) => { JA[e] = new t(); }); var QA = Zn({
    type: "symbol",
    shape: {
      symbolType: "", x: 0, y: 0, width: 0, height: 0,
    },
    beforeBrush() { const t = this.style; this.shape.symbolType === "pin" && t.textPosition === "inside" && (t.textPosition = ["50%", "40%"], t.textAlign = "center", t.textVerticalAlign = "middle"); },
    buildPath(t, e, i) { let n = e.symbolType; let o = JA[n]; e.symbolType !== "none" && (o || (o = JA[n = "rect"]), $A[n](e.x, e.y, e.width, e.height, o.shape), o.buildPath(t, o.shape, i)); },
  }); const tD = { isDimensionStacked: fl, enableDataStack: dl, getStackedDimension: pl }; const eD = (Object.freeze || Object)({
    createList(t) { return gl(t.getSource(), t); }, getLayoutRect: ha, dataStack: tD, createScale(t, e) { let i = e; Po.isInstance(e) || h(i = new Po(e), XA); const n = Wl(i); return n.setExtent(t[0], t[1]), Fl(n, i), n; }, mixinAxisModelCommonMethods(t) { h(t, XA); }, completeDimensions: ul, createDimensions: wA, createSymbol: $l,
  }); var iD = 1e-8; tu.prototype = {
    constructor: tu, properties: null, getBoundingRect() { const t = this._rect; if (t) return t; for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], o = [], a = [], r = this.geometries, s = 0; s < r.length; s++)r[s].type === "polygon" && (dn(r[s].exterior, o, a), tt(i, i, o), et(n, n, a)); return s === 0 && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new de(i[0], i[1], n[0] - i[0], n[1] - i[1]); }, contain(t) { const e = this.getBoundingRect(); const i = this.geometries; if (!e.contain(t[0], t[1])) return !1; t:for (let n = 0, o = i.length; n < o; n++) if (i[n].type === "polygon") { const a = i[n].exterior; const r = i[n].interiors; if (Ql(a, t[0], t[1])) { for (let s = 0; s < (r ? r.length : 0); s++) if (Ql(r[s])) continue t; return !0; } } return !1; }, transformTo(t, e, i, n) { let o = this.getBoundingRect(); const a = o.width / o.height; i ? n || (n = i / a) : i = a * n; for (var r = new de(t, e, i, n), s = o.calculateTransform(r), l = this.geometries, u = 0; u < l.length; u++) if (l[u].type === "polygon") { for (var h = l[u].exterior, c = l[u].interiors, d = 0; d < h.length; d++)Q(h[d], h[d], s); for (let f = 0; f < (c ? c.length : 0); f++) for (d = 0; d < c[f].length; d++)Q(c[f][d], c[f][d], s); }(o = this._rect).copy(r), this.center = [o.x + o.width / 2, o.y + o.height / 2]; }, cloneShallow(t) { t == null && (t = this.name); const e = new tu(t, this.geometries, this.center); return e._rect = this._rect, e.transformTo = null, e; },
  }; const nD = function (t) { return eu(t), f(g(t.features, t => t.geometry && t.properties && t.geometry.coordinates.length > 0), (t) => { const e = t.properties; const i = t.geometry; const n = i.coordinates; const o = []; i.type === "Polygon" && o.push({ type: "polygon", exterior: n[0], interiors: n.slice(1) }), i.type === "MultiPolygon" && d(n, (t) => { t[0] && o.push({ type: "polygon", exterior: t[0], interiors: t.slice(1) }); }); const a = new tu(e.name, o, e.cp); return a.properties = e, a; }); }; var oD = Bi(); const aD = [0, 1]; var rD = function (t, e, i) { this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1; }; rD.prototype = {
    constructor: rD, contain(t) { const e = this._extent; const i = Math.min(e[0], e[1]); const n = Math.max(e[0], e[1]); return t >= i && t <= n; }, containData(t) { return this.contain(this.dataToCoord(t)); }, getExtent() { return this._extent.slice(); }, getPixelPrecision(t) { return Ho(t || this.scale.getExtent(), this._extent); }, setExtent(t, e) { const i = this._extent; i[0] = t, i[1] = e; }, dataToCoord(t, e) { let i = this._extent; const n = this.scale; return t = n.normalize(t), this.onBand && n.type === "ordinal" && vu(i = i.slice(), n.count()), zo(t, aD, i, e); }, coordToData(t, e) { let i = this._extent; const n = this.scale; this.onBand && n.type === "ordinal" && vu(i = i.slice(), n.count()); const o = zo(t, i, aD, e); return this.scale.scale(o); }, pointToData(t, e) {}, getTicksCoords(t) { const e = (t = t || {}).tickModel || this.getTickModel(); const i = ou(this, e); const n = f(i.ticks, function (t) { return { coord: this.dataToCoord(t), tickValue: t }; }, this); const o = e.get("alignWithLabel"); return yu(this, n, i.tickCategoryInterval, o, t.clamp), n; }, getViewLabels() { return nu(this).labels; }, getLabelModel() { return this.model.getModel("axisLabel"); }, getTickModel() { return this.model.getModel("axisTick"); }, getBandWidth() { const t = this._extent; const e = this.scale.getExtent(); let i = e[1] - e[0] + (this.onBand ? 1 : 0); i === 0 && (i = 1); const n = Math.abs(t[1] - t[0]); return Math.abs(n) / i; }, isHorizontal: null, getRotate: null, calculateCategoryInterval() { return fu(this); },
  }; const sD = nD; const lD = {}; d(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], (t) => { lD[t] = aw[t]; }); const uD = {}; d(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], (t) => { uD[t] = zM[t]; }), qI.extend({
    type: "series.line",
    dependencies: ["grid", "polar"],
    getInitialData(t, e) { return gl(this.getSource(), this); },
    defaultOption: {
      zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, clipOverflow: !0, label: { position: "top" }, lineStyle: { width: 2, type: "solid" }, step: !1, smooth: !1, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: !0, showAllSymbol: "auto", connectNulls: !1, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0,
    },
  }); const hD = _u.prototype; const cD = _u.getSymbolSize = function (t, e) { const i = t.getItemVisual(e, "symbolSize"); return i instanceof Array ? i.slice() : [+i, +i]; }; hD._createSymbol = function (t, e, i, n, o) { this.removeAll(); const a = $l(t, -1, -1, 2, 2, e.getItemVisual(i, "color"), o); a.attr({ z2: 100, culling: !0, scale: wu(n) }), a.drift = bu, this._symbolType = t, this.add(a); }, hD.stopSymbolAnimation = function (t) { this.childAt(0).stopAnimation(t); }, hD.getSymbolPath = function () { return this.childAt(0); }, hD.getScale = function () { return this.childAt(0).scale; }, hD.highlight = function () { this.childAt(0).trigger("emphasis"); }, hD.downplay = function () { this.childAt(0).trigger("normal"); }, hD.setZ = function (t, e) { const i = this.childAt(0); i.zlevel = t, i.z = e; }, hD.setDraggable = function (t) { const e = this.childAt(0); e.draggable = t, e.cursor = t ? "move" : "pointer"; }, hD.updateData = function (t, e, i) { this.silent = !1; const n = t.getItemVisual(e, "symbol") || "circle"; const o = t.hostModel; const a = cD(t, e); const r = n !== this._symbolType; if (r) { const s = t.getItemVisual(e, "symbolKeepAspect"); this._createSymbol(n, t, e, a, s); } else (l = this.childAt(0)).silent = !1, Mo(l, { scale: wu(a) }, o, e); if (this._updateCommon(t, e, a, i), r) { var l = this.childAt(0); const u = i && i.fadeIn; const h = { scale: l.scale.slice() }; u && (h.style = { opacity: l.style.opacity }), l.scale = [0, 0], u && (l.style.opacity = 0), Io(l, h, o, e); } this._seriesModel = o; }; const dD = ["itemStyle"]; const fD = ["emphasis", "itemStyle"]; const pD = ["label"]; const gD = ["emphasis", "label"]; hD._updateCommon = function (t, e, i, n) {
    const o = this.childAt(0); const r = t.hostModel; const s = t.getItemVisual(e, "color"); o.type !== "image" && o.useStyle({ strokeNoScale: !0 }); let l = n && n.itemStyle; let u = n && n.hoverItemStyle; let h = n && n.symbolRotate; let c = n && n.symbolOffset; let d = n && n.labelModel; let f = n && n.hoverLabelModel; let p = n && n.hoverAnimation; let g = n && n.cursorStyle; if (!n || t.hasItemOption) { const m = n && n.itemModel ? n.itemModel : t.getItemModel(e); l = m.getModel(dD).getItemStyle(["color"]), u = m.getModel(fD).getItemStyle(), h = m.getShallow("symbolRotate"), c = m.getShallow("symbolOffset"), d = m.getModel(pD), f = m.getModel(gD), p = m.getShallow("hoverAnimation"), g = m.getShallow("cursor"); } else u = a({}, u); const v = o.style; o.attr("rotation", (h || 0) * Math.PI / 180 || 0), c && o.attr("position", [Bo(c[0], i[0]), Bo(c[1], i[1])]), g && o.attr("cursor", g), o.setColor(s, n && n.symbolInnerColor), o.setStyle(l); const y = t.getItemVisual(e, "opacity"); y != null && (v.opacity = y); const x = t.getItemVisual(e, "liftZ"); const _ = o.__z2Origin; x != null ? _ == null && (o.__z2Origin = o.z2, o.z2 += x) : _ != null && (o.z2 = _, o.__z2Origin = null); const w = n && n.useNameLabel; po(v, u, d, f, {
      labelFetcher: r, labelDataIndex: e, defaultText(e, i) { return w ? t.getName(e) : xu(t, e); }, isRectText: !0, autoColor: s,
    }), o.off("mouseover").off("mouseout").off("emphasis").off("normal"), o.hoverStyle = u, co(o), o.__symbolOriginalScale = wu(i), p && r.isAnimationEnabled() && o.on("mouseover", Su).on("mouseout", Mu).on("emphasis", Iu).on("normal", Tu);
  }, hD.fadeOut = function (t, e) { const i = this.childAt(0); this.silent = i.silent = !0, !(e && e.keepLabel) && (i.style.text = null), Mo(i, { style: { opacity: 0 }, scale: [0, 0] }, this._seriesModel, this.dataIndex, t); }, u(_u, tb); const mD = Au.prototype; mD.updateData = function (t, e) {
    e = Cu(e); const i = this.group; const n = t.hostModel; const o = this._data; const a = this._symbolCtor; const r = Lu(t); o || i.removeAll(), t.diff(o).add((n) => { const o = t.getItemLayout(n); if (Du(t, o, n, e)) { const s = new a(t, n, r); s.attr("position", o), t.setItemGraphicEl(n, s), i.add(s); } }).update((s, l) => { let u = o.getItemGraphicEl(l); const h = t.getItemLayout(s); Du(t, h, s, e) ? (u ? (u.updateData(t, s, r), Mo(u, { position: h }, n)) : (u = new a(t, s)).attr("position", h), i.add(u), t.setItemGraphicEl(s, u)) : i.remove(u); }).remove((t) => { const e = o.getItemGraphicEl(t); e && e.fadeOut(() => { i.remove(e); }); })
      .execute(), this._data = t;
  }, mD.isPersistent = function () { return !0; }, mD.updateLayout = function () { const t = this._data; t && t.eachItemGraphicEl((e, i) => { const n = t.getItemLayout(i); e.attr("position", n); }); }, mD.incrementalPrepareUpdate = function (t) { this._seriesScope = Lu(t), this._data = null, this.group.removeAll(); }, mD.incrementalUpdate = function (t, e, i) { i = Cu(i); for (let n = t.start; n < t.end; n++) { const o = e.getItemLayout(n); if (Du(e, o, n, i)) { const a = new this._symbolCtor(e, n, this._seriesScope); a.traverse((t) => { t.isGroup || (t.incremental = t.useHoverLayer = !0); }), a.attr("position", o), this.group.add(a), e.setItemGraphicEl(n, a); } } }, mD.remove = function (t) { const e = this.group; const i = this._data; i && t ? i.eachItemGraphicEl((t) => { t.fadeOut(() => { e.remove(t); }); }) : e.removeAll(); }; const vD = function (t, e, i, n, o, a, r, s) {
    for (var l = Ou(t, e), u = [], h = [], c = [], d = [], f = [], p = [], g = [], m = ku(o, e, r), v = ku(a, t, s), y = 0; y < l.length; y++) { const x = l[y]; let _ = !0; switch (x.cmd) { case "=": var w = t.getItemLayout(x.idx); var b = e.getItemLayout(x.idx1); (isNaN(w[0]) || isNaN(w[1])) && (w = b.slice()), u.push(w), h.push(b), c.push(i[x.idx]), d.push(n[x.idx1]), g.push(e.getRawIndex(x.idx1)); break; case "+": S = x.idx; u.push(o.dataToPoint([e.get(m.dataDimsForPoint[0], S), e.get(m.dataDimsForPoint[1], S)])), h.push(e.getItemLayout(S).slice()), c.push(Nu(m, o, e, S)), d.push(n[S]), g.push(e.getRawIndex(S)); break; case "-": var S = x.idx; var M = t.getRawIndex(S); M !== S ? (u.push(t.getItemLayout(S)), h.push(a.dataToPoint([t.get(v.dataDimsForPoint[0], S), t.get(v.dataDimsForPoint[1], S)])), c.push(i[S]), d.push(Nu(v, a, t, S)), g.push(M)) : _ = !1; }_ && (f.push(x), p.push(p.length)); }p.sort((t, e) => g[t] - g[e]); for (var I = [], T = [], A = [], D = [], C = [], y = 0; y < p.length; y++) { S = p[y]; I[y] = u[S], T[y] = h[S], A[y] = c[S], D[y] = d[S], C[y] = f[S]; } return {
      current: I, next: T, stackedOnCurrent: A, stackedOnNext: D, status: C,
    };
  }; var yD = tt; var xD = et; var _D = Z; var wD = G; var bD = []; var SD = []; var MD = []; const ID = kn.extend({
    type: "ec-polyline",
    shape: {
      points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1,
    },
    style: { fill: null, stroke: "#000" },
    brush: uM(kn.prototype.brush),
    buildPath(t, e) { const i = e.points; let n = 0; let o = i.length; const a = Vu(i, e.smoothConstraint); if (e.connectNulls) { for (;o > 0 && Eu(i[o - 1]); o--);for (;n < o && Eu(i[n]); n++); } for (;n < o;)n += Ru(t, i, n, o, o, 1, a.min, a.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1; },
  }); const TD = kn.extend({
    type: "ec-polygon",
    shape: {
      points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1,
    },
    brush: uM(kn.prototype.brush),
    buildPath(t, e) { const i = e.points; const n = e.stackedOnPoints; let o = 0; let a = i.length; const r = e.smoothMonotone; const s = Vu(i, e.smoothConstraint); const l = Vu(n, e.smoothConstraint); if (e.connectNulls) { for (;a > 0 && Eu(i[a - 1]); a--);for (;o < a && Eu(i[o]); o++); } for (;o < a;) { const u = Ru(t, i, o, a, a, 1, s.min, s.max, e.smooth, r, e.connectNulls); Ru(t, n, o + u - 1, u, a, -1, l.min, l.max, e.stackedOnSmooth, r, e.connectNulls), o += u + 1, t.closePath(); } },
  }); Tr.extend({
    type: "line",
    init() {
      const t = new tb(); const
        e = new Au(); this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t;
    },
    render(t, e, i) {
      const n = t.coordinateSystem; const o = this.group; const a = t.getData(); const s = t.getModel("lineStyle"); const l = t.getModel("areaStyle"); let u = a.mapArray(a.getItemLayout); const h = n.type === "polar"; const c = this._coordSys; const d = this._symbolDraw; let f = this._polyline; let p = this._polygon; const g = this._lineGroup; const m = t.get("animation"); const v = !l.isEmpty(); const y = l.get("origin"); let x = Hu(n, a, ku(n, a, y)); const _ = t.get("showSymbol"); const w = _ && !h && qu(t, a, n); const b = this._data; b && b.eachItemGraphicEl((t, e) => { t.__temp && (o.remove(t), b.setItemGraphicEl(e, null)); }), _ || d.remove(), o.add(g); const S = !h && t.get("step"); f && c.type === n.type && S === this._step ? (v && !p ? p = this._newPolygon(u, x, n, m) : p && !v && (g.remove(p), p = this._polygon = null), g.setClipPath(Xu(n, !1, !1, t)), _ && d.updateData(a, { isIgnore: w, clipShape: Xu(n, !1, !0, t) }), a.eachItemGraphicEl((t) => { t.stopAnimation(!0); }), Gu(this._stackedOnPoints, x) && Gu(this._points, u) || (m ? this._updateAnimation(a, x, n, i, S, y) : (S && (u = ju(u, n, S), x = ju(x, n, S)), f.setShape({ points: u }), p && p.setShape({ points: u, stackedOnPoints: x })))) : (_ && d.updateData(a, { isIgnore: w, clipShape: Xu(n, !1, !0, t) }), S && (u = ju(u, n, S), x = ju(x, n, S)), f = this._newPolyline(u, n, m), v && (p = this._newPolygon(u, x, n, m)), g.setClipPath(Xu(n, !0, !1, t))); const M = Yu(a, n) || a.getVisual("color"); f.useStyle(r(s.getLineStyle(), { fill: "none", stroke: M, lineJoin: "bevel" })); let I = t.get("smooth"); if (I = Fu(t.get("smooth")), f.setShape({ smooth: I, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") }), p) {
        const T = a.getCalculationInfo("stackedOnSeries"); let A = 0; p.useStyle(r(l.getAreaStyle(), { fill: M, opacity: 0.7, lineJoin: "bevel" })), T && (A = Fu(T.get("smooth"))), p.setShape({
          smooth: I, stackedOnSmooth: A, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls"),
        });
      } this._data = a, this._coordSys = n, this._stackedOnPoints = x, this._points = u, this._step = S, this._valueOrigin = y;
    },
    dispose() {},
    highlight(t, e, i, n) { const o = t.getData(); const a = zi(o, n); if (!(a instanceof Array) && a != null && a >= 0) { let r = o.getItemGraphicEl(a); if (!r) { const s = o.getItemLayout(a); if (!s) return; (r = new _u(o, a)).position = s, r.setZ(t.get("zlevel"), t.get("z")), r.ignore = isNaN(s[0]) || isNaN(s[1]), r.__temp = !0, o.setItemGraphicEl(a, r), r.stopSymbolAnimation(!0), this.group.add(r); }r.highlight(); } else Tr.prototype.highlight.call(this, t, e, i, n); },
    downplay(t, e, i, n) { const o = t.getData(); const a = zi(o, n); if (a != null && a >= 0) { const r = o.getItemGraphicEl(a); r && (r.__temp ? (o.setItemGraphicEl(a, null), this.group.remove(r)) : r.downplay()); } else Tr.prototype.downplay.call(this, t, e, i, n); },
    _newPolyline(t) { let e = this._polyline; return e && this._lineGroup.remove(e), e = new ID({ shape: { points: t }, silent: !0, z2: 10 }), this._lineGroup.add(e), this._polyline = e, e; },
    _newPolygon(t, e) { let i = this._polygon; return i && this._lineGroup.remove(i), i = new TD({ shape: { points: t, stackedOnPoints: e }, silent: !0 }), this._lineGroup.add(i), this._polygon = i, i; },
    _updateAnimation(t, e, i, n, o, a) { const r = this._polyline; const s = this._polygon; const l = t.hostModel; const u = vD(this._data, t, this._stackedOnPoints, e, this._coordSys, i, this._valueOrigin, a); let h = u.current; let c = u.stackedOnCurrent; let d = u.next; let f = u.stackedOnNext; o && (h = ju(u.current, i, o), c = ju(u.stackedOnCurrent, i, o), d = ju(u.next, i, o), f = ju(u.stackedOnNext, i, o)), r.shape.__points = u.current, r.shape.points = h, Mo(r, { shape: { points: d } }, l), s && (s.setShape({ points: h, stackedOnPoints: c }), Mo(s, { shape: { points: d, stackedOnPoints: f } }, l)); for (var p = [], g = u.status, m = 0; m < g.length; m++) if (g[m].cmd === "=") { const v = t.getItemGraphicEl(g[m].idx1); v && p.push({ el: v, ptIdx: m }); }r.animators && r.animators.length && r.animators[0].during(() => { for (let t = 0; t < p.length; t++)p[t].el.attr("position", r.shape.__points[p[t].ptIdx]); }); },
    remove(t) { const e = this.group; const i = this._data; this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl((t, n) => { t.__temp && (e.remove(t), i.setItemGraphicEl(n, null)); }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null; },
  }); const AD = function (t, e, i) {
    return {
      seriesType: t,
      performRawSeries: !0,
      reset(t, n, o) {
        const a = t.getData(); const r = t.get("symbol") || e; const s = t.get("symbolSize"); const l = t.get("symbolKeepAspect"); if (a.setVisual({
          legendSymbol: i || r, symbol: r, symbolSize: s, symbolKeepAspect: l,
        }), !n.isSeriesFiltered(t)) { const u = typeof s === "function"; return { dataEach: a.hasItemOption || u ? function (e, i) { if (typeof s === "function") { const n = t.getRawValue(i); const o = t.getDataParams(i); e.setItemVisual(i, "symbolSize", s(n, o)); } if (e.hasItemOption) { const a = e.getItemModel(i); const r = a.getShallow("symbol", !0); const l = a.getShallow("symbolSize", !0); const u = a.getShallow("symbolKeepAspect", !0); r != null && e.setItemVisual(i, "symbol", r), l != null && e.setItemVisual(i, "symbolSize", l), u != null && e.setItemVisual(i, "symbolKeepAspect", u); } } : null }; }
      },
    };
  }; const DD = function (t) { return { seriesType: t, plan: JI(), reset(t) { const e = t.getData(); const i = t.coordinateSystem; const n = t.pipelineContext.large; if (i) { const o = f(i.dimensions, t => e.mapDimension(t)).slice(0, 2); const a = o.length; const r = e.getCalculationInfo("stackResultDimension"); return fl(e, o[0]) && (o[0] = r), fl(e, o[1]) && (o[1] = r), a && { progress(t, e) { for (var r = t.end - t.start, s = n && new Float32Array(r * a), l = t.start, u = 0, h = [], c = []; l < t.end; l++) { var d; if (a === 1)f = e.get(o[0], l), d = !isNaN(f) && i.dataToPoint(f, null, c); else { var f = h[0] = e.get(o[0], l); const p = h[1] = e.get(o[1], l); d = !isNaN(f) && !isNaN(p) && i.dataToPoint(h, null, c); }n ? (s[u++] = d ? d[0] : NaN, s[u++] = d ? d[1] : NaN) : e.setItemLayout(l, d && d.slice() || [NaN, NaN]); }n && e.setLayout("symbolPoints", s); } }; } } }; }; const CD = {
    average(t) { for (var e = 0, i = 0, n = 0; n < t.length; n++)isNaN(t[n]) || (e += t[n], i++); return i === 0 ? NaN : e / i; }, sum(t) { for (var e = 0, i = 0; i < t.length; i++)e += t[i] || 0; return e; }, max(t) { for (var e = -1 / 0, i = 0; i < t.length; i++)t[i] > e && (e = t[i]); return isFinite(e) ? e : NaN; }, min(t) { for (var e = 1 / 0, i = 0; i < t.length; i++)t[i] < e && (e = t[i]); return isFinite(e) ? e : NaN; }, nearest(t) { return t[0]; },
  }; const LD = function (t, e) { return Math.round(t.length / 2); }; var kD = function (t) { this._axes = {}, this._dimList = [], this.name = t || ""; }; kD.prototype = {
    constructor: kD, type: "cartesian", getAxis(t) { return this._axes[t]; }, getAxes() { return f(this._dimList, $u, this); }, getAxesByScale(t) { return t = t.toLowerCase(), g(this.getAxes(), e => e.scale.type === t); }, addAxis(t) { const e = t.dim; this._axes[e] = t, this._dimList.push(e); }, dataToCoord(t) { return this._dataCoordConvert(t, "dataToCoord"); }, coordToData(t) { return this._dataCoordConvert(t, "coordToData"); }, _dataCoordConvert(t, e) { for (var i = this._dimList, n = t instanceof Array ? [] : {}, o = 0; o < i.length; o++) { const a = i[o]; const r = this._axes[a]; n[a] = r[e](t[a]); } return n; },
  }, Ju.prototype = {
    constructor: Ju, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis() { return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x"); }, containPoint(t) { const e = this.getAxis("x"); const i = this.getAxis("y"); return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1])); }, containData(t) { return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]); }, dataToPoint(t, e, i) { const n = this.getAxis("x"); const o = this.getAxis("y"); return i = i || [], i[0] = n.toGlobalCoord(n.dataToCoord(t[0])), i[1] = o.toGlobalCoord(o.dataToCoord(t[1])), i; }, clampData(t, e) { const i = this.getAxis("x").scale; const n = this.getAxis("y").scale; const o = i.getExtent(); const a = n.getExtent(); const r = i.parse(t[0]); const s = n.parse(t[1]); return e = e || [], e[0] = Math.min(Math.max(Math.min(o[0], o[1]), r), Math.max(o[0], o[1])), e[1] = Math.min(Math.max(Math.min(a[0], a[1]), s), Math.max(a[0], a[1])), e; }, pointToData(t, e) { const i = this.getAxis("x"); const n = this.getAxis("y"); return e = e || [], e[0] = i.coordToData(i.toLocalCoord(t[0])), e[1] = n.coordToData(n.toLocalCoord(t[1])), e; }, getOtherAxis(t) { return this.getAxis(t.dim === "x" ? "y" : "x"); },
  }, u(Ju, kD); const PD = function (t, e, i, n, o) { rD.call(this, t, e, i), this.type = n || "value", this.position = o || "bottom"; }; PD.prototype = {
    constructor: PD, index: 0, getAxesOnZeroOf: null, model: null, isHorizontal() { const t = this.position; return t === "top" || t === "bottom"; }, getGlobalExtent(t) { const e = this.getExtent(); return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e; }, getOtherAxis() { this.grid.getOtherAxis(); }, pointToData(t, e) { return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), e); }, toLocalCoord: null, toGlobalCoord: null,
  }, u(PD, rD); const ND = {
    show: !0,
    zlevel: 0,
    z: 0,
    inverse: !1,
    name: "",
    nameLocation: "end",
    nameRotate: null,
    nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." },
    nameTextStyle: {},
    nameGap: 15,
    silent: !1,
    triggerEvent: !1,
    tooltip: { show: !1 },
    axisPointer: {},
    axisLine: {
      show: !0, onZero: !0, onZeroAxisIndex: null, lineStyle: { color: "#333", width: 1, type: "solid" }, symbol: ["none", "none"], symbolSize: [10, 15],
    },
    axisTick: {
      show: !0, inside: !1, length: 5, lineStyle: { width: 1 },
    },
    axisLabel: {
      show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12,
    },
    splitLine: { show: !0, lineStyle: { color: ["#ccc"], width: 1, type: "solid" } },
    splitArea: { show: !1, areaStyle: { color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"] } },
  }; const OD = {}; OD.categoryAxis = n({
    boundaryGap: !0, deduplication: null, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: "auto" }, axisLabel: { interval: "auto" },
  }, ND), OD.valueAxis = n({ boundaryGap: [0, 0], splitNumber: 5 }, ND), OD.timeAxis = r({ scale: !0, min: "dataMin", max: "dataMax" }, OD.valueAxis), OD.logAxis = r({ scale: !0, logBase: 10 }, OD.valueAxis); const ED = ["value", "category", "time", "log"]; const RD = function (t, e, i, a) {
    d(ED, (r) => {
      e.extend({
        type: `${t}Axis.${r}`, mergeDefaultAndTheme(e, o) { const a = this.layoutMode; const s = a ? pa(e) : {}; n(e, o.getTheme().get(`${r}Axis`)), n(e, this.getDefaultOption()), e.type = i(t, e), a && fa(e, s, a); }, optionUpdated() { this.option.type === "category" && (this.__ordinalMeta = xl.createByAxisModel(this)); }, getCategories(t) { const e = this.option; if (e.type === "category") return t ? e.data : this.__ordinalMeta.categories; }, getOrdinalMeta() { return this.__ordinalMeta; }, defaultOption: o([{}, OD[`${r}Axis`], a], !0),
      });
    }), uI.registerSubTypeDefaulter(`${t}Axis`, v(i, t));
  }; var zD = uI.extend({
    type: "cartesian2dAxis", axis: null, init() { zD.superApply(this, "init", arguments), this.resetRange(); }, mergeOption() { zD.superApply(this, "mergeOption", arguments), this.resetRange(); }, restoreData() { zD.superApply(this, "restoreData", arguments), this.resetRange(); }, getCoordSysModel() { return this.ecModel.queryComponents({ mainType: "grid", index: this.option.gridIndex, id: this.option.gridId })[0]; },
  }); n(zD.prototype, XA); const BD = { offset: 0 }; RD("x", zD, Qu, BD), RD("y", zD, Qu, BD), uI.extend({
    type: "grid",
    dependencies: ["xAxis", "yAxis"],
    layoutMode: "box",
    coordinateSystem: null,
    defaultOption: {
      show: !1, zlevel: 0, z: 0, left: "10%", top: 60, right: "10%", bottom: 60, containLabel: !1, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc",
    },
  }); const VD = eh.prototype; VD.type = "grid", VD.axisPointerEnabled = !0, VD.getRect = function () { return this._rect; }, VD.update = function (t, e) { const i = this._axesMap; this._updateScale(t, this.model), d(i.x, (t) => { Fl(t.scale, t.model); }), d(i.y, (t) => { Fl(t.scale, t.model); }); const n = {}; d(i.x, (t) => { ih(i, "y", t, n); }), d(i.y, (t) => { ih(i, "x", t, n); }), this.resize(this.model, e); }, VD.resize = function (t, e, i) { function n() { d(a, (t) => { const e = t.isHorizontal(); const i = e ? [0, o.width] : [0, o.height]; const n = t.inverse ? 1 : 0; t.setExtent(i[n], i[1 - n]), oh(t, e ? o.x : o.y); }); } var o = ha(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }); this._rect = o; var a = this._axesList; n(), !i && t.get("containLabel") && (d(a, (t) => { if (!t.model.get("axisLabel.inside")) { const e = Xl(t); if (e) { const i = t.isHorizontal() ? "height" : "width"; const n = t.model.get("axisLabel.margin"); o[i] -= e[i] + n, t.position === "top" ? o.y += e.height + n : t.position === "left" && (o.x += e.width + n); } } }), n()); }, VD.getAxis = function (t, e) { const i = this._axesMap[t]; if (i != null) { if (e == null) for (const n in i) if (i.hasOwnProperty(n)) return i[n]; return i[e]; } }, VD.getAxes = function () { return this._axesList.slice(); }, VD.getCartesian = function (t, e) { if (t != null && e != null) { const i = `x${t}y${e}`; return this._coordsMap[i]; }w(t) && (e = t.yAxisIndex, t = t.xAxisIndex); for (let n = 0, o = this._coordsList; n < o.length; n++) if (o[n].getAxis("x").index === t || o[n].getAxis("y").index === e) return o[n]; }, VD.getCartesians = function () { return this._coordsList.slice(); }, VD.convertToPixel = function (t, e, i) { const n = this._findConvertTarget(t, e); return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null; }, VD.convertFromPixel = function (t, e, i) { const n = this._findConvertTarget(t, e); return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null; }, VD._findConvertTarget = function (t, e) { let i; let n; const o = e.seriesModel; const a = e.xAxisModel || o && o.getReferringComponents("xAxis")[0]; const r = e.yAxisModel || o && o.getReferringComponents("yAxis")[0]; const s = e.gridModel; const u = this._coordsList; return o ? l(u, i = o.coordinateSystem) < 0 && (i = null) : a && r ? i = this.getCartesian(a.componentIndex, r.componentIndex) : a ? n = this.getAxis("x", a.componentIndex) : r ? n = this.getAxis("y", r.componentIndex) : s && s.coordinateSystem === this && (i = this._coordsList[0]), { cartesian: i, axis: n }; }, VD.containPoint = function (t) { const e = this._coordsList[0]; if (e) return e.containPoint(t); }, VD._initCartesian = function (t, e, i) {
    function n(i) { return function (n, s) { if (th(n, t, e)) { let l = n.get("position"); i === "x" ? l !== "top" && l !== "bottom" && o[l = "bottom"] && (l = l === "top" ? "bottom" : "top") : l !== "left" && l !== "right" && o[l = "left"] && (l = l === "left" ? "right" : "left"), o[l] = !0; const u = new PD(i, Wl(n), [0, 0], n.get("type"), l); const h = u.type === "category"; u.onBand = h && n.get("boundaryGap"), u.inverse = n.get("inverse"), n.axis = u, u.model = n, u.grid = this, u.index = s, this._axesList.push(u), a[i][s] = u, r[i]++; } }; } var o = {
      left: !1, right: !1, top: !1, bottom: !1,
    }; var a = { x: {}, y: {} }; var r = { x: 0, y: 0 }; if (e.eachComponent("xAxis", n("x"), this), e.eachComponent("yAxis", n("y"), this), !r.x || !r.y) return this._axesMap = {}, void (this._axesList = []); this._axesMap = a, d(a.x, function (e, i) { d(a.y, function (n, o) { const a = `x${i}y${o}`; const r = new Ju(a); r.grid = this, r.model = t, this._coordsMap[a] = r, this._coordsList.push(r), r.addAxis(e), r.addAxis(n); }, this); }, this);
  }, VD._updateScale = function (t, e) { function i(t, e, i) { d(t.mapDimension(e.dim, !0), (i) => { e.scale.unionExtentFromData(t, pl(t, i)); }); }d(this._axesList, (t) => { t.scale.setExtent(1 / 0, -1 / 0); }), t.eachSeries(function (n) { if (rh(n)) { const o = ah(n); const a = o[0]; const r = o[1]; if (!th(a, e, t) || !th(r, e, t)) return; const s = this.getCartesian(a.componentIndex, r.componentIndex); const l = n.getData(); const u = s.getAxis("x"); const h = s.getAxis("y"); l.type === "list" && (i(l, u), i(l, h)); } }, this); }, VD.getTooltipAxes = function (t) { const e = []; const i = []; return d(this.getCartesians(), (n) => { const o = t != null && t !== "auto" ? n.getAxis(t) : n.getBaseAxis(); const a = n.getOtherAxis(o); l(e, o) < 0 && e.push(o), l(i, a) < 0 && i.push(a); }), { baseAxes: e, otherAxes: i }; }; var GD = ["xAxis", "yAxis"]; eh.create = function (t, e) { const i = []; return t.eachComponent("grid", (n, o) => { const a = new eh(n, t, e); a.name = `grid_${o}`, a.resize(n, e, !0), n.coordinateSystem = a, i.push(a); }), t.eachSeries((t) => { if (rh(t)) { const e = ah(t); const i = e[0]; const n = e[1]; const o = i.getCoordSysModel().coordinateSystem; t.coordinateSystem = o.getCartesian(i.componentIndex, n.componentIndex); } }), i; }, eh.dimensions = eh.prototype.dimensions = Ju.prototype.dimensions, Ga.register("cartesian2d", eh); var FD = Math.PI; var WD = function (t, e) {
    this.opt = e, this.axisModel = t, r(e, {
      labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0,
    }), this.group = new tb(); const i = new tb({ position: e.position.slice(), rotation: e.rotation }); i.updateTransform(), this._transform = i.transform, this._dumbGroup = i;
  }; WD.prototype = {
    constructor: WD, hasBuilder(t) { return !!HD[t]; }, add(t) { HD[t].call(this); }, getGroup() { return this.group; },
  }; var HD = {
    axisLine() {
      const t = this.opt; const e = this.axisModel; if (e.get("axisLine.show")) {
        const i = this.axisModel.axis.getExtent(); const n = this._transform; const o = [i[0], 0]; const r = [i[1], 0]; n && (Q(o, o, n), Q(r, r, n)); const s = a({ lineCap: "round" }, e.getModel("axisLine.lineStyle").getLineStyle()); this.group.add(new _M(qn({
          anid: "line",
          shape: {
            x1: o[0], y1: o[1], x2: r[0], y2: r[1],
          },
          style: s,
          strokeContainThreshold: t.strokeContainThreshold || 5,
          silent: !0,
          z2: 1,
        }))); let l = e.get("axisLine.symbol"); let u = e.get("axisLine.symbolSize"); let h = e.get("axisLine.symbolOffset") || 0; if (typeof h === "number" && (h = [h, h]), l != null) {
          typeof l === "string" && (l = [l, l]), typeof u !== "string" && typeof u !== "number" || (u = [u, u]); const c = u[0]; const f = u[1]; d([{ rotate: t.rotation + Math.PI / 2, offset: h[0], r: 0 }, { rotate: t.rotation - Math.PI / 2, offset: h[1], r: Math.sqrt((o[0] - r[0]) * (o[0] - r[0]) + (o[1] - r[1]) * (o[1] - r[1])) }], function (e, i) {
            if (l[i] !== "none" && l[i] != null) {
              const n = $l(l[i], -c / 2, -f / 2, c, f, s.stroke, !0); const a = e.r + e.offset; const r = [o[0] + a * Math.cos(t.rotation), o[1] - a * Math.sin(t.rotation)]; n.attr({
                rotation: e.rotate, position: r, silent: !0, z2: 11,
              }), this.group.add(n);
            }
          }, this);
        }
      }
    },
    axisTickLabel() { const t = this.axisModel; const e = this.opt; const i = ph(this, t, e); hh(t, gh(this, t, e), i); },
    axisName() {
      const t = this.opt; const e = this.axisModel; const i = T(t.axisName, e.get("name")); if (i) {
        let n; const o = e.get("nameLocation"); const r = t.nameDirection; const s = e.getModel("nameTextStyle"); const l = e.get("nameGap") || 0; const u = this.axisModel.axis.getExtent(); const h = u[0] > u[1] ? -1 : 1; const c = [o === "start" ? u[0] - h * l : o === "end" ? u[1] + h * l : (u[0] + u[1]) / 2, fh(o) ? t.labelOffset + r * l : 0]; let d = e.get("nameRotate"); d != null && (d = d * FD / 180); let f; fh(o) ? n = ZD(t.rotation, d != null ? d : t.rotation, r) : (n = lh(t, o, d || 0, u), (f = t.axisNameAvailableWidth) != null && (f = Math.abs(f / Math.sin(n.rotation)), !isFinite(f) && (f = null))); const p = s.getFont(); const g = e.get("nameTruncate", !0) || {}; const m = g.ellipsis; const v = T(t.nameTruncateMaxWidth, g.maxWidth, f); const y = m != null && v != null ? tI(i, v, p, m, { minChar: 2, placeholder: g.placeholder }) : i; const x = e.get("tooltip", !0); const _ = e.mainType; const w = { componentType: _, name: i, $vars: ["name"] }; w[`${_}Index`] = e.componentIndex; const b = new rM({
          anid: "name", __fullText: i, __truncatedText: y, position: c, rotation: n.rotation, silent: uh(e), z2: 1, tooltip: x && x.show ? a({ content: i, formatter() { return i; }, formatterParams: w }, x) : null,
        }); go(b.style, s, {
          text: y, textFont: p, textFill: s.getTextColor() || e.get("axisLine.lineStyle.color"), textAlign: n.textAlign, textVerticalAlign: n.textVerticalAlign,
        }), e.get("triggerEvent") && (b.eventData = sh(e), b.eventData.targetType = "axisName", b.eventData.name = i), this._dumbGroup.add(b), b.updateTransform(), this.group.add(b), b.decomposeTransform();
      }
    },
  }; var ZD = WD.innerTextLayout = function (t, e, i) { let n; let o; const a = Uo(e - t); return Xo(a) ? (o = i > 0 ? "top" : "bottom", n = "center") : Xo(a - FD) ? (o = i > 0 ? "bottom" : "top", n = "center") : (o = "middle", n = a > 0 && a < FD ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), { rotation: a, textAlign: n, textVerticalAlign: o }; }; var UD = d; var XD = v; var jD = Fs({
    type: "axis", _axisPointer: null, axisPointerClass: null, render(t, e, i, n) { this.axisPointerClass && bh(t), jD.superApply(this, "render", arguments), Ah(this, t, 0, i, 0, !0); }, updateAxisPointer(t, e, i, n, o) { Ah(this, t, 0, i, 0, !1); }, remove(t, e) { const i = this._axisPointer; i && i.remove(e), jD.superApply(this, "remove", arguments); }, dispose(t, e) { Dh(this, e), jD.superApply(this, "dispose", arguments); },
  }); const YD = []; jD.registerAxisPointerClass = function (t, e) { YD[t] = e; }, jD.getAxisPointerClass = function (t) { return t && YD[t]; }; const qD = ["axisLine", "axisTickLabel", "axisName"]; const KD = ["splitArea", "splitLine"]; var $D = jD.extend({
    type: "cartesianAxis",
    axisPointerClass: "CartesianAxisPointer",
    render(t, e, i, n) { this.group.removeAll(); const o = this._axisGroup; if (this._axisGroup = new tb(), this.group.add(this._axisGroup), t.get("show")) { const a = t.getCoordSysModel(); const r = Ch(a, t); const s = new WD(t, r); d(qD, s.add, s), this._axisGroup.add(s.getGroup()), d(KD, function (e) { t.get(`${e}.show`) && this[`_${e}`](t, a); }, this), Co(o, this._axisGroup, t), $D.superCall(this, "render", t, e, i, n); } },
    remove() { this._splitAreaColors = null; },
    _splitLine(t, e) {
      const i = t.axis; if (!i.scale.isBlank()) {
        const n = t.getModel("splitLine"); const o = n.getModel("lineStyle"); let a = o.get("color"); a = y(a) ? a : [a]; for (let s = e.coordinateSystem.getRect(), l = i.isHorizontal(), u = 0, h = i.getTicksCoords({ tickModel: n }), c = [], d = [], f = o.getLineStyle(), p = 0; p < h.length; p++) {
          const g = i.toGlobalCoord(h[p].coord); l ? (c[0] = g, c[1] = s.y, d[0] = g, d[1] = s.y + s.height) : (c[0] = s.x, c[1] = g, d[0] = s.x + s.width, d[1] = g); const m = u++ % a.length; const v = h[p].tickValue; this._axisGroup.add(new _M(qn({
            anid: v != null ? `line_${h[p].tickValue}` : null,
            shape: {
              x1: c[0], y1: c[1], x2: d[0], y2: d[1],
            },
            style: r({ stroke: a[m] }, f),
            silent: !0,
          })));
        }
      }
    },
    _splitArea(t, e) {
      const i = t.axis; if (!i.scale.isBlank()) {
        const n = t.getModel("splitArea"); const o = n.getModel("areaStyle"); let a = o.get("color"); const s = e.coordinateSystem.getRect(); const l = i.getTicksCoords({ tickModel: n, clamp: !0 }); if (l.length) {
          const u = a.length; const h = this._splitAreaColors; const c = R(); let d = 0; if (h) for (m = 0; m < l.length; m++) { const f = h.get(l[m].tickValue); if (f != null) { d = (f + (u - 1) * m) % u; break; } } let p = i.toGlobalCoord(l[0].coord); const g = o.getAreaStyle(); a = y(a) ? a : [a]; for (var m = 1; m < l.length; m++) {
            var v; var x; var _; var w; const b = i.toGlobalCoord(l[m].coord); i.isHorizontal() ? (v = p, x = s.y, _ = b - v, w = s.height, p = v + _) : (v = s.x, x = p, _ = s.width, p = x + (w = b - x)); const S = l[m - 1].tickValue; S != null && c.set(S, d), this._axisGroup.add(new yM({
              anid: S != null ? `area_${S}` : null,
              shape: {
                x: v, y: x, width: _, height: w,
              },
              style: r({ fill: a[d] }, g),
              silent: !0,
            })), d = (d + 1) % u;
          } this._splitAreaColors = c;
        }
      }
    },
  }); $D.extend({ type: "xAxis" }), $D.extend({ type: "yAxis" }), Fs({
    type: "grid",
    render(t, e) {
      this.group.removeAll(), t.get("show") && this.group.add(new yM({
        shape: t.coordinateSystem.getRect(), style: r({ fill: t.get("backgroundColor") }, t.getItemStyle()), silent: !0, z2: -1,
      }));
    },
  }), Ps((t) => { t.xAxis && t.yAxis && !t.grid && (t.grid = {}); }), zs(AD("line", "circle", "line")), Rs(DD("line")), Ns(GT.PROCESSOR.STATISTIC, (function (t) { return { seriesType: t, modifyOutputEnd: !0, reset(t, e, i) { const n = t.getData(); const o = t.get("sampling"); const a = t.coordinateSystem; if (a.type === "cartesian2d" && o) { const r = a.getBaseAxis(); const s = a.getOtherAxis(r); const l = r.getExtent(); const u = l[1] - l[0]; const h = Math.round(n.count() / u); if (h > 1) { let c; typeof o === "string" ? c = CD[o] : typeof o === "function" && (c = o), c && t.setData(n.downSample(n.mapDimension(s.dim), 1 / h, c, LD)); } } } }; }("line"))); const JD = qI.extend({
    type: "series.__base_bar__",
    getInitialData(t, e) { return gl(this.getSource(), this); },
    getMarkerPosition(t) { const e = this.coordinateSystem; if (e) { const i = e.dataToPoint(e.clampData(t)); const n = this.getData(); const o = n.getLayout("offset"); const a = n.getLayout("size"); return i[e.getBaseAxis().isHorizontal() ? 0 : 1] += o + a / 2, i; } return [NaN, NaN]; },
    defaultOption: {
      zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, barMinHeight: 0, barMinAngle: 0, large: !1, largeThreshold: 400, progressive: 3e3, progressiveChunkMode: "mod", itemStyle: {}, emphasis: {},
    },
  }); JD.extend({
    type: "series.bar", dependencies: ["grid", "polar"], brushSelector: "rect", getProgressive() { return !!this.get("large") && this.get("progressive"); }, getProgressiveThreshold() { let t = this.get("progressiveThreshold"); const e = this.get("largeThreshold"); return e > t && (t = e), t; },
  }); const QD = Qb([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]); const tC = { getBarItemStyle(t) { const e = QD(this, t); if (this.getBorderLineDash) { const i = this.getBorderLineDash(); i && (e.lineDash = i); } return e; } }; var eC = ["itemStyle", "barBorderWidth"]; a(Po.prototype, tC), Hs({
    type: "bar",
    render(t, e, i) { this._updateDrawMode(t); const n = t.get("coordinateSystem"); return n !== "cartesian2d" && n !== "polar" || (this._isLargeDraw ? this._renderLarge(t, e, i) : this._renderNormal(t, e, i)), this.group; },
    incrementalPrepareRender(t, e, i) { this._clear(), this._updateDrawMode(t); },
    incrementalRender(t, e, i, n) { this._incrementalRenderLarge(t, e); },
    _updateDrawMode(t) { const e = t.pipelineContext.large; (this._isLargeDraw == null || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear()); },
    _renderNormal(t, e, i) {
      let n; const o = this.group; const a = t.getData(); const r = this._data; const s = t.coordinateSystem; const l = s.getBaseAxis(); s.type === "cartesian2d" ? n = l.isHorizontal() : s.type === "polar" && (n = l.dim === "angle"); const u = t.isAnimationEnabled() ? t : null; a.diff(r).add((e) => { if (a.hasValue(e)) { const i = a.getItemModel(e); const r = nC[s.type](a, e, i); const l = iC[s.type](a, e, i, r, n, u); a.setItemGraphicEl(e, l), o.add(l), Oh(l, a, e, i, r, t, n, s.type === "polar"); } }).update((e, i) => { let l = r.getItemGraphicEl(i); if (a.hasValue(e)) { const h = a.getItemModel(e); const c = nC[s.type](a, e, h); l ? Mo(l, { shape: c }, u, e) : l = iC[s.type](a, e, h, c, n, u, !0), a.setItemGraphicEl(e, l), o.add(l), Oh(l, a, e, h, c, t, n, s.type === "polar"); } else o.remove(l); }).remove((t) => { const e = r.getItemGraphicEl(t); s.type === "cartesian2d" ? e && Ph(t, u, e) : e && Nh(t, u, e); })
        .execute(), this._data = a;
    },
    _renderLarge(t, e, i) { this._clear(), Rh(t, this.group); },
    _incrementalRenderLarge(t, e) { Rh(e, this.group, !0); },
    dispose: B,
    remove(t) { this._clear(t); },
    _clear(t) { const e = this.group; const i = this._data; t && t.get("animation") && i && !this._isLargeDraw ? i.eachItemGraphicEl((e) => { e.type === "sector" ? Nh(e.dataIndex, t, e) : Ph(e.dataIndex, t, e); }) : e.removeAll(), this._data = null; },
  }); var iC = { cartesian2d(t, e, i, n, o, r, s) { const l = new yM({ shape: a({}, n) }); if (r) { const u = l.shape; const h = o ? "height" : "width"; const c = {}; u[h] = 0, c[h] = n[h], zM[s ? "updateProps" : "initProps"](l, { shape: c }, r, e); } return l; }, polar(t, e, i, n, o, a, s) { const l = n.startAngle < n.endAngle; const u = new hM({ shape: r({ clockwise: l }, n) }); if (a) { const h = u.shape; const c = o ? "r" : "endAngle"; const d = {}; h[c] = o ? 0 : n.startAngle, d[c] = n[c], zM[s ? "updateProps" : "initProps"](u, { shape: d }, a, e); } return u; } }; var nC = {
    cartesian2d(t, e, i) {
      const n = t.getItemLayout(e); const o = Eh(i, n); const a = n.width > 0 ? 1 : -1; const r = n.height > 0 ? 1 : -1; return {
        x: n.x + a * o / 2, y: n.y + r * o / 2, width: n.width - a * o, height: n.height - r * o,
      };
    },
    polar(t, e, i) {
      const n = t.getItemLayout(e); return {
        cx: n.cx, cy: n.cy, r0: n.r0, r: n.r, startAngle: n.startAngle, endAngle: n.endAngle,
      };
    },
  }; var oC = kn.extend({ type: "largeBar", shape: { points: [] }, buildPath(t, e) { for (let i = e.points, n = this.__startPoint, o = this.__valueIdx, a = 0; a < i.length; a += 2)n[this.__valueIdx] = i[a + o], t.moveTo(n[0], n[1]), t.lineTo(i[a], i[a + 1]); } }); Rs(v(Ol, "bar")), Rs(LA), zs({ seriesType: "bar", reset(t) { t.getData().setVisual("legendSymbol", "roundRect"); } }); const aC = function (t, e, i) { e = y(e) && { coordDimensions: e } || a({}, e); const n = t.getSource(); const o = wA(n, e); const r = new yA(o, t); return r.initData(n, i), r; }; const rC = {
    updateSelectedMap(t) { this._targetList = y(t) ? t.slice() : [], this._selectTargetMap = p(t || [], (t, e) => t.set(e.name, e), t, R()); }, select(t, e) { const i = e != null ? this._targetList[e] : this._selectTargetMap.get(t); this.get("selectedMode") === "single" && this._selectTargetMap.each((t) => { t.selected = !1; }), i && (i.selected = !0); }, unSelect(t, e) { const i = e != null ? this._targetList[e] : this._selectTargetMap.get(t); i && (i.selected = !1); }, toggleSelected(t, e) { const i = e != null ? this._targetList[e] : this._selectTargetMap.get(t); if (i != null) return this[i.selected ? "unSelect" : "select"](t, e), i.selected; }, isSelected(t, e) { const i = e != null ? this._targetList[e] : this._selectTargetMap.get(t); return i && i.selected; },
  }; var sC = Ws({
    type: "series.pie",
    init(t) { sC.superApply(this, "init", arguments), this.legendDataProvider = function () { return this.getRawData(); }, this.updateSelectedMap(this._createSelectableList()), this._defaultLabelLine(t); },
    mergeOption(t) { sC.superCall(this, "mergeOption", t), this.updateSelectedMap(this._createSelectableList()); },
    getInitialData(t, e) { return aC(this, ["value"]); },
    _createSelectableList() { for (var t = this.getRawData(), e = t.mapDimension("value"), i = [], n = 0, o = t.count(); n < o; n++)i.push({ name: t.getName(n), value: t.get(e, n), selected: fr(t, n, "selected") }); return i; },
    getDataParams(t) { const e = this.getData(); const i = sC.superCall(this, "getDataParams", t); const n = []; return e.each(e.mapDimension("value"), (t) => { n.push(t); }), i.percent = Zo(n, t, e.hostModel.get("percentPrecision")), i.$vars.push("percent"), i; },
    _defaultLabelLine(t) { Ci(t, "labelLine", ["show"]); const e = t.labelLine; const i = t.emphasis.labelLine; e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show; },
    defaultOption: {
      zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      hoverAnimation: !0,
      center: ["50%", "50%"],
      radius: [0, "75%"],
      clockwise: !0,
      startAngle: 90,
      minAngle: 0,
      selectedOffset: 10,
      hoverOffset: 10,
      avoidLabelOverlap: !0,
      percentPrecision: 2,
      stillShowZeroSum: !0,
      label: { rotate: !1, show: !0, position: "outer" },
      labelLine: {
        show: !0, length: 15, length2: 15, smooth: !1, lineStyle: { width: 1, type: "solid" },
      },
      itemStyle: { borderWidth: 1 },
      animationType: "expansion",
      animationEasing: "cubicOut",
    },
  }); h(sC, rC); const lC = Gh.prototype; lC.updateData = function (t, e, i) { function n() { s.stopAnimation(!0), s.animateTo({ shape: { r: h.r + l.get("hoverOffset") } }, 300, "elasticOut"); } function o() { s.stopAnimation(!0), s.animateTo({ shape: { r: h.r } }, 300, "elasticOut"); } var s = this.childAt(0); var l = t.hostModel; const u = t.getItemModel(e); var h = t.getItemLayout(e); const c = a({}, h); c.label = null, i ? (s.setShape(c), l.getShallow("animationType") === "scale" ? (s.shape.r = h.r0, Io(s, { shape: { r: h.r } }, l, e)) : (s.shape.endAngle = h.startAngle, Mo(s, { shape: { endAngle: h.endAngle } }, l, e))) : Mo(s, { shape: c }, l, e); const d = t.getItemVisual(e, "color"); s.useStyle(r({ lineJoin: "bevel", fill: d }, u.getModel("itemStyle").getItemStyle())), s.hoverStyle = u.getModel("emphasis.itemStyle").getItemStyle(); const f = u.getShallow("cursor"); f && s.attr("cursor", f), Vh(this, t.getItemLayout(e), l.isSelected(null, e), l.get("selectedOffset"), l.get("animation")), s.off("mouseover").off("mouseout").off("emphasis").off("normal"), u.get("hoverAnimation") && l.isAnimationEnabled() && s.on("mouseover", n).on("mouseout", o).on("emphasis", n).on("normal", o), this._updateLabel(t, e), co(this); }, lC._updateLabel = function (t, e) {
    const i = this.childAt(1); const n = this.childAt(2); const o = t.hostModel; const a = t.getItemModel(e); const r = t.getItemLayout(e).label; var s = t.getItemVisual(e, "color"); Mo(i, { shape: { points: r.linePoints || [[r.x, r.y], [r.x, r.y], [r.x, r.y]] } }, o, e), Mo(n, { style: { x: r.x, y: r.y } }, o, e), n.attr({ rotation: r.rotation, origin: [r.x, r.y], z2: 10 }); const l = a.getModel("label"); const u = a.getModel("emphasis.label"); const h = a.getModel("labelLine"); const c = a.getModel("emphasis.labelLine"); var s = t.getItemVisual(e, "color"); po(n.style, n.hoverStyle = {}, l, u, {
      labelFetcher: t.hostModel, labelDataIndex: e, defaultText: t.getName(e), autoColor: s, useInsideStyle: !!r.inside,
    }, { textAlign: r.textAlign, textVerticalAlign: r.verticalAlign, opacity: t.getItemVisual(e, "opacity") }), n.ignore = n.normalIgnore = !l.get("show"), n.hoverIgnore = !u.get("show"), i.ignore = i.normalIgnore = !h.get("show"), i.hoverIgnore = !c.get("show"), i.setStyle({ stroke: s, opacity: t.getItemVisual(e, "opacity") }), i.setStyle(h.getModel("lineStyle").getLineStyle()), i.hoverStyle = c.getModel("lineStyle").getLineStyle(); let d = h.get("smooth"); d && !0 === d && (d = 0.4), i.setShape({ smooth: d });
  }, u(Gh, tb); Tr.extend({
    type: "pie",
    init() { const t = new tb(); this._sectorGroup = t; },
    render(t, e, i, n) {
      if (!n || n.from !== this.uid) {
        const o = t.getData(); const a = this._data; const r = this.group; const s = e.get("animation"); const l = !a; const u = t.get("animationType"); const h = v(Bh, this.uid, t, s, i); const c = t.get("selectedMode"); if (o.diff(a).add((t) => { const e = new Gh(o, t); l && u !== "scale" && e.eachChild((t) => { t.stopAnimation(!0); }), c && e.on("click", h), o.setItemGraphicEl(t, e), r.add(e); }).update((t, e) => { const i = a.getItemGraphicEl(e); i.updateData(o, t), i.off("click"), c && i.on("click", h), r.add(i), o.setItemGraphicEl(t, i); }).remove((t) => { const e = a.getItemGraphicEl(t); r.remove(e); })
          .execute(), s && l && o.count() > 0 && u !== "scale") { const d = o.getItemLayout(0); const f = Math.max(i.getWidth(), i.getHeight()) / 2; const p = m(r.removeClipPath, r); r.setClipPath(this._createClipPath(d.cx, d.cy, f, d.startAngle, d.clockwise, p, t)); } else r.removeClipPath(); this._data = o;
      }
    },
    dispose() {},
    _createClipPath(t, e, i, n, o, a, r) {
      const s = new hM({
        shape: {
          cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: o,
        },
      }); return Io(s, { shape: { endAngle: n + (o ? 1 : -1) * Math.PI * 2 } }, r, a), s;
    },
    containPoint(t, e) { const i = e.getData().getItemLayout(0); if (i) { const n = t[0] - i.cx; const o = t[1] - i.cy; const a = Math.sqrt(n * n + o * o); return a <= i.r && a >= i.r0; } },
  }); const uC = function (t, e) { d(e, (e) => { e.update = "updateView", Os(e, (i, n) => { const o = {}; return n.eachComponent({ mainType: "series", subType: t, query: i }, (t) => { t[e.method] && t[e.method](i.name, i.dataIndex); const n = t.getData(); n.each((e) => { const i = n.getName(e); o[i] = t.isSelected(i) || !1; }); }), { name: i.name, selected: o }; }); }); }; const hC = function (t) { return { getTargetSeries(e) { const i = {}; const n = R(); return e.eachSeriesByType(t, (t) => { t.__paletteScope = i, n.set(t.uid, t); }), n; }, reset(t, e) { const i = t.getRawData(); const n = {}; const o = t.getData(); o.each((t) => { const e = o.getRawIndex(t); n[e] = t; }), i.each((e) => { const a = n[e]; const r = a != null && o.getItemVisual(a, "color", !0); if (r)i.setItemVisual(e, "color", r); else { const s = i.getItemModel(e).get("itemStyle.color") || t.getColorFromPalette(i.getName(e) || `${e}`, t.__paletteScope, i.count()); i.setItemVisual(e, "color", s), a != null && o.setItemVisual(a, "color", s); } }); } }; }; const cC = function (t, e, i, n) {
    let o; let a; const r = t.getData(); const s = []; let l = !1; r.each((i) => {
      let n; let u; let h; let c; const d = r.getItemLayout(i); const f = r.getItemModel(i); const p = f.getModel("label"); const g = p.get("position") || f.get("emphasis.label.position"); const m = f.getModel("labelLine"); const v = m.get("length"); const y = m.get("length2"); const x = (d.startAngle + d.endAngle) / 2; const _ = Math.cos(x); const w = Math.sin(x); o = d.cx, a = d.cy; const b = g === "inside" || g === "inner"; if (g === "center")n = d.cx, u = d.cy, c = "center"; else { const S = (b ? (d.r + d.r0) / 2 * _ : d.r * _) + o; const M = (b ? (d.r + d.r0) / 2 * w : d.r * w) + a; if (n = S + 3 * _, u = M + 3 * w, !b) { const I = S + _ * (v + e - d.r); const T = M + w * (v + e - d.r); const A = I + (_ < 0 ? -1 : 1) * y; const D = T; n = A + (_ < 0 ? -5 : 5), u = D, h = [[S, M], [I, T], [A, D]]; }c = b ? "center" : _ > 0 ? "left" : "right"; } const C = p.getFont(); const L = p.get("rotate") ? _ < 0 ? -x + Math.PI : -x : 0; const k = ke(t.getFormattedLabel(i, "normal") || r.getName(i), C, c, "top"); l = !!L, d.label = {
        x: n, y: u, position: g, height: k.height, len: v, len2: y, linePoints: h, textAlign: c, verticalAlign: "middle", rotation: L, inside: b,
      }, b || s.push(d.label);
    }), !l && t.get("avoidLabelOverlap") && Wh(s, o, a, e, i, n);
  }; const dC = 2 * Math.PI; const fC = Math.PI / 180; const pC = function (t) { return { seriesType: t, reset(t, e) { const i = e.findComponents({ mainType: "legend" }); if (i && i.length) { const n = t.getData(); n.filterSelf((t) => { for (let e = n.getName(t), o = 0; o < i.length; o++) if (!i[o].isSelected(e)) return !1; return !0; }); } } }; }; uC("pie", [{ type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected" }, { type: "pieSelect", event: "pieselected", method: "select" }, { type: "pieUnSelect", event: "pieunselected", method: "unSelect" }]), zs(hC("pie")), Rs(v((t, e, i, n) => {
    e.eachSeriesByType(t, (t) => {
      const e = t.getData(); const n = e.mapDimension("value"); let o = t.get("center"); let a = t.get("radius"); y(a) || (a = [0, a]), y(o) || (o = [o, o]); const r = i.getWidth(); const s = i.getHeight(); const l = Math.min(r, s); const u = Bo(o[0], r); const h = Bo(o[1], s); const c = Bo(a[0], l / 2); const d = Bo(a[1], l / 2); const f = -t.get("startAngle") * fC; const p = t.get("minAngle") * fC; let g = 0; e.each(n, (t) => { !isNaN(t) && g++; }); const m = e.getSum(n); let v = Math.PI / (m || g) * 2; const x = t.get("clockwise"); const _ = t.get("roseType"); const w = t.get("stillShowZeroSum"); const b = e.getDataExtent(n); b[0] = 0; let S = dC; let M = 0; let I = f; const T = x ? 1 : -1; if (e.each(n, (t, i) => {
        let n; if (isNaN(t)) {
 e.setItemLayout(i, {
          angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: x, cx: u, cy: h, r0: c, r: _ ? NaN : d,
        }); 
} else {
          (n = _ !== "area" ? m === 0 && w ? v : t * v : dC / g) < p ? (n = p, S -= p) : M += t; const o = I + T * n; e.setItemLayout(i, {
            angle: n, startAngle: I, endAngle: o, clockwise: x, cx: u, cy: h, r0: c, r: _ ? zo(t, b, [c, d]) : d,
          }), I = o;
        }
      }), S < dC && g) if (S <= 0.001) { const A = dC / g; e.each(n, (t, i) => { if (!isNaN(t)) { const n = e.getItemLayout(i); n.angle = A, n.startAngle = f + T * i * A, n.endAngle = f + T * (i + 1) * A; } }); } else v = S / M, I = f, e.each(n, (t, i) => { if (!isNaN(t)) { const n = e.getItemLayout(i); const o = n.angle === p ? p : t * v; n.startAngle = I, n.endAngle = I + T * o, I += T * o; } }); cC(t, d, r, s);
    });
  }, "pie")), Ns(pC("pie")), qI.extend({
    type: "series.scatter",
    dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
    getInitialData(t, e) { return gl(this.getSource(), this); },
    brushSelector: "point",
    getProgressive() { const t = this.option.progressive; return t == null ? this.option.large ? 5e3 : this.get("progressive") : t; },
    getProgressiveThreshold() { const t = this.option.progressiveThreshold; return t == null ? this.option.large ? 1e4 : this.get("progressiveThreshold") : t; },
    defaultOption: {
      coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, symbolSize: 10, large: !1, largeThreshold: 2e3, itemStyle: { opacity: 0.8 },
    },
  }); const gC = Zn({
    shape: { points: null }, symbolProxy: null, buildPath(t, e) { const i = e.points; const n = e.size; const o = this.symbolProxy; const a = o.shape; if (!((t.getContext ? t.getContext() : t) && n[0] < 4)) for (let r = 0; r < i.length;) { const s = i[r++]; const l = i[r++]; isNaN(s) || isNaN(l) || (a.x = s - n[0] / 2, a.y = l - n[1] / 2, a.width = n[0], a.height = n[1], o.buildPath(t, a, !0)); } }, afterBrush(t) { const e = this.shape; const i = e.points; const n = e.size; if (n[0] < 4) { this.setTransform(t); for (let o = 0; o < i.length;) { const a = i[o++]; const r = i[o++]; isNaN(a) || isNaN(r) || t.fillRect(a - n[0] / 2, r - n[1] / 2, n[0], n[1]); } this.restoreTransform(t); } }, findDataIndex(t, e) { for (let i = this.shape, n = i.points, o = i.size, a = Math.max(o[0], 4), r = Math.max(o[1], 4), s = n.length / 2 - 1; s >= 0; s--) { const l = 2 * s; const u = n[l] - a / 2; const h = n[l + 1] - r / 2; if (t >= u && e >= h && t <= u + a && e <= h + r) return s; } return -1; },
  }); const mC = Zh.prototype; mC.isPersistent = function () { return !this._incremental; }, mC.updateData = function (t) { this.group.removeAll(); const e = new gC({ rectHover: !0, cursor: "default" }); e.setShape({ points: t.getLayout("symbolPoints") }), this._setCommon(e, t), this.group.add(e), this._incremental = null; }, mC.updateLayout = function (t) { if (!this._incremental) { let e = t.getLayout("symbolPoints"); this.group.eachChild((t) => { if (t.startIndex != null) { const i = 2 * (t.endIndex - t.startIndex); const n = 4 * t.startIndex * 2; e = new Float32Array(e.buffer, n, i); }t.setShape("points", e); }); } }, mC.incrementalPrepareUpdate = function (t) { this.group.removeAll(), this._clearIncremental(), t.count() > 2e6 ? (this._incremental || (this._incremental = new Hn({ silent: !0 })), this.group.add(this._incremental)) : this._incremental = null; }, mC.incrementalUpdate = function (t, e) {
    let i; this._incremental ? (i = new gC(), this._incremental.addDisplayable(i, !0)) : ((i = new gC({
      rectHover: !0, cursor: "default", startIndex: t.start, endIndex: t.end,
    })).incremental = !0, this.group.add(i)), i.setShape({ points: e.getLayout("symbolPoints") }), this._setCommon(i, e, !!this._incremental);
  }, mC._setCommon = function (t, e, i) { const n = e.hostModel; const o = e.getVisual("symbolSize"); t.setShape("size", o instanceof Array ? o : [o, o]), t.symbolProxy = $l(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor; const a = t.shape.size[0] < 4; t.useStyle(n.getModel("itemStyle").getItemStyle(a ? ["color", "shadowBlur", "shadowColor"] : ["color"])); const r = e.getVisual("color"); r && t.setColor(r), i || (t.seriesIndex = n.seriesIndex, t.on("mousemove", (e) => { t.dataIndex = null; const i = t.findDataIndex(e.offsetX, e.offsetY); i >= 0 && (t.dataIndex = i + (t.startIndex || 0)); })); }, mC.remove = function () { this._clearIncremental(), this._incremental = null, this.group.removeAll(); }, mC._clearIncremental = function () { const t = this._incremental; t && t.clearDisplaybles(); }, Hs({
    type: "scatter", render(t, e, i) { const n = t.getData(); this._updateSymbolDraw(n, t).updateData(n), this._finished = !0; }, incrementalPrepareRender(t, e, i) { const n = t.getData(); this._updateSymbolDraw(n, t).incrementalPrepareUpdate(n), this._finished = !1; }, incrementalRender(t, e, i) { this._symbolDraw.incrementalUpdate(t, e.getData()), this._finished = t.end === e.getData().count(); }, updateTransform(t, e, i) { const n = t.getData(); if (this.group.dirty(), !this._finished || n.count() > 1e4 || !this._symbolDraw.isPersistent()) return { update: !0 }; const o = DD().reset(t); o.progress && o.progress({ start: 0, end: n.count() }, n), this._symbolDraw.updateLayout(n); }, _updateSymbolDraw(t, e) { let i = this._symbolDraw; const n = e.pipelineContext.large; return i && n === this._isLargeDraw || (i && i.remove(), i = this._symbolDraw = n ? new Zh() : new Au(), this._isLargeDraw = n, this.group.removeAll()), this.group.add(i.group), i; }, remove(t, e) { this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null; }, dispose() {},
  }), zs(AD("scatter", "circle")), Rs(DD("scatter")), u(Uh, rD), Xh.prototype.getIndicatorAxes = function () { return this._indicatorAxes; }, Xh.prototype.dataToPoint = function (t, e) { const i = this._indicatorAxes[e]; return this.coordToPoint(i.dataToCoord(t), e); }, Xh.prototype.coordToPoint = function (t, e) { const i = this._indicatorAxes[e].angle; return [this.cx + t * Math.cos(i), this.cy - t * Math.sin(i)]; }, Xh.prototype.pointToData = function (t) { let e = t[0] - this.cx; let i = t[1] - this.cy; const n = Math.sqrt(e * e + i * i); e /= n, i /= n; for (var o, a = Math.atan2(-i, e), r = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) { const u = this._indicatorAxes[l]; const h = Math.abs(a - u.angle); h < r && (o = u, s = l, r = h); } return [s, +(o && o.coodToData(n))]; }, Xh.prototype.resize = function (t, e) { const i = t.get("center"); const n = e.getWidth(); const o = e.getHeight(); const a = Math.min(n, o) / 2; this.cx = Bo(i[0], n), this.cy = Bo(i[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180; let r = t.get("radius"); typeof r !== "string" && typeof r !== "number" || (r = [0, r]), this.r0 = Bo(r[0], a), this.r = Bo(r[1], a), d(this._indicatorAxes, function (t, e) { t.setExtent(this.r0, this.r); let i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length; i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i; }, this); }, Xh.prototype.update = function (t, e) { function i(t) { const e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)); let i = t / e; return i === 2 ? i = 5 : i *= 2, i * e; } const n = this._indicatorAxes; const o = this._model; d(n, (t) => { t.scale.setExtent(1 / 0, -1 / 0); }), t.eachSeriesByType("radar", (e, i) => { if (e.get("coordinateSystem") === "radar" && t.getComponent("radar", e.get("radarIndex")) === o) { const a = e.getData(); d(n, (t) => { t.scale.unionExtentFromData(a, a.mapDimension(t.dim)); }); } }, this); const a = o.get("splitNumber"); d(n, (t, e) => { const n = Vl(t.scale, t.model); Fl(t.scale, t.model); const o = t.model; const r = t.scale; const s = o.getMin(); const l = o.getMax(); let u = r.getInterval(); if (s != null && l != null)r.setExtent(+s, +l), r.setInterval((l - s) / a); else if (s != null) { let h; do { h = s + u * a, r.setExtent(+s, h), r.setInterval(u), u = i(u); } while (h < n[1] && isFinite(h) && isFinite(n[1])); } else if (l != null) { let c; do { c = l - u * a, r.setExtent(c, +l), r.setInterval(u), u = i(u); } while (c > n[0] && isFinite(c) && isFinite(n[0])); } else { r.getTicks().length - 1 > a && (u = i(u)); const d = Math.round((n[0] + n[1]) / 2 / u) * u; const f = Math.round(a / 2); r.setExtent(Vo(d - f * u), Vo(d + (a - f) * u)), r.setInterval(u); } }); }, Xh.dimensions = [], Xh.create = function (t, e) { const i = []; return t.eachComponent("radar", (n) => { const o = new Xh(n, t, e); i.push(o), n.coordinateSystem = o; }), t.eachSeriesByType("radar", (t) => { t.get("coordinateSystem") === "radar" && (t.coordinateSystem = i[t.get("radarIndex") || 0]); }), i; }, Ga.register("radar", Xh); const vC = OD.valueAxis; const yC = (Gs({
    type: "radar",
    optionUpdated() {
      const t = this.get("boundaryGap"); const e = this.get("splitNumber"); const o = this.get("scale"); const s = this.get("axisLine"); const l = this.get("axisTick"); const u = this.get("axisLabel"); const h = this.get("name"); const c = this.get("name.show"); const d = this.get("name.formatter"); const p = this.get("nameGap"); const g = this.get("triggerEvent"); const m = f(this.get("indicator") || [], function (f) {
        f.max != null && f.max > 0 && !f.min ? f.min = 0 : f.min != null && f.min < 0 && !f.max && (f.max = 0); let m = h; if (f.color != null && (m = r({ color: f.color }, h)), f = n(i(f), {
          boundaryGap: t, splitNumber: e, scale: o, axisLine: s, axisTick: l, axisLabel: u, name: f.text, nameLocation: "end", nameGap: p, nameTextStyle: m, triggerEvent: g,
        }, !1), c || (f.name = ""), typeof d === "string") { const v = f.name; f.name = d.replace("{value}", v != null ? v : ""); } else typeof d === "function" && (f.name = d(f.name, f)); const y = a(new Po(f, null, this.ecModel), XA); return y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this); this.getIndicatorModels = function () { return m; };
    },
    defaultOption: {
      zlevel: 0, z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, name: { show: !0 }, boundaryGap: [0, 0], splitNumber: 5, nameGap: 15, scale: !1, shape: "polygon", axisLine: n({ lineStyle: { color: "#bbb" } }, vC.axisLine), axisLabel: jh(vC.axisLabel, !1), axisTick: jh(vC.axisTick, !1), splitLine: jh(vC.splitLine, !0), splitArea: jh(vC.splitArea, !0), indicator: [],
    },
  }), ["axisLine", "axisTickLabel", "axisName"]); Fs({
    type: "radar",
    render(t, e, i) { this.group.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t); },
    _buildAxes(t) {
      const e = t.coordinateSystem; d(f(e.getIndicatorAxes(), t => new WD(t.model, {
        position: [e.cx, e.cy], rotation: t.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1,
      })), function (t) { d(yC, t.add, t), this.group.add(t.getGroup()); }, this);
    },
    _buildSplitLineAndArea(t) {
      function e(t, e, i) { const n = i % e.length; return t[n] = t[n] || [], n; } const i = t.coordinateSystem; const n = i.getIndicatorAxes(); if (n.length) {
        const o = t.get("shape"); const a = t.getModel("splitLine"); const s = t.getModel("splitArea"); const l = a.getModel("lineStyle"); const u = s.getModel("areaStyle"); const h = a.get("show"); const c = s.get("show"); let p = l.get("color"); let g = u.get("color"); p = y(p) ? p : [p], g = y(g) ? g : [g]; const m = []; const v = []; if (o === "circle") {
          for (var x = n[0].getTicksCoords(), _ = i.cx, w = i.cy, b = 0; b < x.length; b++) {
            h && m[D = e(m, p, b)].push(new sM({ shape: { cx: _, cy: w, r: x[b].coord } })), c && b < x.length - 1 && v[D = e(v, g, b)].push(new cM({
              shape: {
                cx: _, cy: w, r0: x[b].coord, r: x[b + 1].coord,
              },
            }));
          }
        } else for (var S, M = f(n, (t, e) => { const n = t.getTicksCoords(); return S = S == null ? n.length - 1 : Math.min(n.length - 1, S), f(n, t => i.coordToPoint(t.coord, e)); }), I = [], b = 0; b <= S; b++) { for (var T = [], A = 0; A < n.length; A++)T.push(M[A][b]); if (T[0] && T.push(T[0].slice()), h && m[D = e(m, p, b)].push(new gM({ shape: { points: T } })), c && I) { var D = e(v, g, b - 1); v[D].push(new pM({ shape: { points: T.concat(I) } })); }I = T.slice().reverse(); } const C = l.getLineStyle(); const L = u.getAreaStyle(); d(v, function (t, e) { this.group.add(OM(t, { style: r({ stroke: "none", fill: g[e % g.length] }, L), silent: !0 })); }, this), d(m, function (t, e) { this.group.add(OM(t, { style: r({ fill: "none", stroke: p[e % p.length] }, C), silent: !0 })); }, this);
      }
    },
  }); var xC = qI.extend({
    type: "series.radar",
    dependencies: ["radar"],
    init(t) { xC.superApply(this, "init", arguments), this.legendDataProvider = function () { return this.getRawData(); }; },
    getInitialData(t, e) { return aC(this, { generateCoord: "indicator_", generateCoordCount: 1 / 0 }); },
    formatTooltip(t) { const e = this.getData(); const i = this.coordinateSystem.getIndicatorAxes(); const n = this.getData().getName(t); return `${ea(n === "" ? this.name : n)}<br/>${f(i, (i, n) => { const o = e.get(e.mapDimension(i.dim), t); return ea(`${i.name} : ${o}`); }).join("<br />")}`; },
    defaultOption: {
      zlevel: 0, z: 2, coordinateSystem: "radar", legendHoverLink: !0, radarIndex: 0, lineStyle: { width: 2, type: "solid" }, label: { position: "top" }, symbol: "emptyCircle", symbolSize: 4,
    },
  }); Hs({
    type: "radar",
    render(t, e, n) {
      function o(t, e) { const i = t.getItemVisual(e, "symbol") || "circle"; const n = t.getItemVisual(e, "color"); if (i !== "none") { const o = Yh(t.getItemVisual(e, "symbolSize")); const a = $l(i, -1, -1, 2, 2, n); return a.attr({ style: { strokeNoScale: !0 }, z2: 100, scale: [o[0] / 2, o[1] / 2] }), a; } } function a(e, i, n, a, r, s) { n.removeAll(); for (let l = 0; l < i.length - 1; l++) { const u = o(a, r); u && (u.__dimIdx = l, e[l] ? (u.attr("position", e[l]), zM[s ? "initProps" : "updateProps"](u, { position: i[l] }, t, r)) : u.attr("position", i[l]), n.add(u)); } } function s(t) { return f(t, t => [l.cx, l.cy]); } var l = t.coordinateSystem; const u = this.group; const h = t.getData(); const c = this._data; h.diff(c).add((e) => {
        const i = h.getItemLayout(e); if (i) {
          const n = new pM(); const o = new gM(); const
            r = { shape: { points: i } }; n.shape.points = s(i), o.shape.points = s(i), Io(n, r, t, e), Io(o, r, t, e); const l = new tb(); const
            u = new tb(); l.add(o), l.add(n), l.add(u), a(o.shape.points, i, u, h, e, !0), h.setItemGraphicEl(e, l);
        }
      }).update((e, i) => { const n = c.getItemGraphicEl(i); const o = n.childAt(0); const r = n.childAt(1); const s = n.childAt(2); const l = { shape: { points: h.getItemLayout(e) } }; l.shape.points && (a(o.shape.points, l.shape.points, s, h, e, !1), Mo(o, l, t), Mo(r, l, t), h.setItemGraphicEl(e, n)); }).remove((t) => { u.remove(c.getItemGraphicEl(t)); })
        .execute(), h.eachItemGraphicEl((t, e) => {
        function n() { l.attr("ignore", m); } function o() { l.attr("ignore", g); } const a = h.getItemModel(e); const s = t.childAt(0); var l = t.childAt(1); const c = t.childAt(2); const d = h.getItemVisual(e, "color"); u.add(t), s.useStyle(r(a.getModel("lineStyle").getLineStyle(), { fill: "none", stroke: d })), s.hoverStyle = a.getModel("emphasis.lineStyle").getLineStyle(); const f = a.getModel("areaStyle"); const p = a.getModel("emphasis.areaStyle"); var g = f.isEmpty() && f.parentModel.isEmpty(); var m = p.isEmpty() && p.parentModel.isEmpty(); m = m && g, l.ignore = g, l.useStyle(r(f.getAreaStyle(), { fill: d, opacity: 0.7 })), l.hoverStyle = p.getAreaStyle(); const v = a.getModel("itemStyle").getItemStyle(["color"]); const y = a.getModel("emphasis.itemStyle").getItemStyle(); const x = a.getModel("label"); const _ = a.getModel("emphasis.label"); c.eachChild((t) => {
          t.setStyle(v), t.hoverStyle = i(y), po(t.style, t.hoverStyle, x, _, {
            labelFetcher: h.hostModel, labelDataIndex: e, labelDimIndex: t.__dimIdx, defaultText: h.get(h.dimensions[t.__dimIdx], e), autoColor: d, isRectText: !0,
          });
        }), t.off("mouseover").off("mouseout").off("normal").off("emphasis"), t.on("emphasis", n).on("mouseover", n).on("normal", o).on("mouseout", o), co(t);
      }), this._data = h;
    },
    remove() { this.group.removeAll(), this._data = null; },
    dispose() {},
  }); zs(hC("radar")), zs(AD("radar", "circle")), Rs((t) => { t.eachSeriesByType("radar", (t) => { const e = t.getData(); const i = []; const n = t.coordinateSystem; if (n) { for (var o = n.getIndicatorAxes(), a = 0; a < o.length; a++)e.each(e.mapDimension(o[a].dim), (t, e) => { i[e] = i[e] || [], i[e][a] = n.dataToPoint(t, a); }); e.each((t) => { i[t][0] && i[t].push(i[t][0].slice()), e.setItemLayout(t, i[t]); }); } }); }), Ns(pC("radar")), Ps((t) => { let e = t.polar; if (e) { y(e) || (e = [e]); const i = []; d(e, (e, n) => { e.indicator ? (e.type && !e.shape && (e.shape = e.type), t.radar = t.radar || [], y(t.radar) || (t.radar = [t.radar]), t.radar.push(e)) : i.push(e); }), t.polar = i; }d(t.series, (t) => { t && t.type === "radar" && t.polarIndex && (t.radarIndex = t.polarIndex); }); }); for (var _C = [126, 25], wC = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], bC = 0; bC < wC.length; bC++) for (let SC = 0; SC < wC[bC].length; SC++)wC[bC][SC][0] /= 10.5, wC[bC][SC][1] /= -14, wC[bC][SC][0] += _C[0], wC[bC][SC][1] += _C[1]; const MC = function (t, e) { t === "china" && e.push(new tu("南海诸岛", f(wC, t => ({ type: "polygon", exterior: t })), _C)); }; const IC = {
    南海诸岛: [32, 80], 广东: [0, -10], 香港: [10, 5], 澳门: [-10, 10], 天津: [5, 5],
  }; const TC = function (t, e) { if (t === "china") { const i = IC[e.name]; if (i) { const n = e.center; n[0] += i[0] / 10.5, n[1] += -i[1] / 14; } } }; const AC = { Russia: [100, 60], "United States": [-99, 38], "United States of America": [-99, 38] }; const DC = function (t, e) { if (t === "world") { const i = AC[e.name]; if (i) { const n = e.center; n[0] = i[0], n[1] = i[1]; } } }; const CC = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]]; const LC = function (t, e) { t === "china" && e.name === "台湾" && e.geometries.push({ type: "polygon", exterior: CC[0] }); }; const kC = Bi(); const PC = { load(t, e) { const i = kC(e).parsed; if (i) return i; let n; const o = e.specialAreas || {}; const a = e.geoJSON; try { n = a ? nD(a) : []; } catch (t) { throw new Error(`Invalid geoJson format\n${t.message}`); } return d(n, (e) => { const i = e.name; TC(t, e), DC(t, e), LC(t, e); const n = o[i]; n && e.transformTo(n.left, n.top, n.width, n.height); }), MC(t, n), kC(e).parsed = { regions: n, boundingRect: qh(n) }; } }; const NC = Bi(); var OC = { geoJSON: PC, svg: { load(t, e) { const i = NC(e).originRoot; if (i) return { root: i, boundingRect: NC(e).boundingRect }; const n = Kh(e); return NC(e).originRoot = n.root, NC(e).boundingRect = n.boundingRect, n; }, makeGraphic(t, e, i) { const n = NC(e); const o = n.rootMap || (n.rootMap = R()); let a = o.get(i); if (a) return a; const r = n.originRoot; const s = n.boundingRect; return n.originRootHostKey ? a = Kh(e, s).root : (n.originRootHostKey = i, a = r), o.set(i, a); }, removeGraphic(t, e, i) { const n = NC(e); const o = n.rootMap; o && o.removeKey(i), i === n.originRootHostKey && (n.originRootHostKey = null); } } }; var EC = {
    load(t, e) {
      let i; const n = []; const o = R(); const a = R(); return d(Jh(t), (r) => { const s = OC[r.type].load(t, r); d(s.regions, (t) => { let i = t.name; e && e.hasOwnProperty(i) && (t = t.cloneShallow(i = e[i])), n.push(t), o.set(i, t), a.set(i, t.center); }); const l = s.boundingRect; l && (i ? i.union(l) : i = l.clone()); }), {
        regions: n, regionsMap: o, nameCoordMap: a, boundingRect: i || new de(0, 0, 0, 0),
      };
    },
    makeGraphic: $h("makeGraphic"),
    removeGraphic: $h("removeGraphic"),
  }; h(qI.extend({
    type: "series.map",
    dependencies: ["geo"],
    layoutMode: "box",
    needsDrawMap: !1,
    seriesGroup: [],
    getInitialData(t) { for (var e = aC(this, ["value"]), i = e.mapDimension("value"), n = R(), o = [], a = [], r = 0, s = e.count(); r < s; r++) { const l = e.getName(r); n.set(l, !0), o.push({ name: l, value: e.get(i, r), selected: fr(e, r, "selected") }); } return d(EC.load(this.getMapType(), this.option.nameMap).regions, (t) => { const e = t.name; n.get(e) || (o.push({ name: e }), a.push(e)); }), this.updateSelectedMap(o), e.appendValues([], a), e; },
    getHostGeoModel() { const t = this.option.geoIndex; return t != null ? this.dependentModels.geo[t] : null; },
    getMapType() { return (this.getHostGeoModel() || this).option.map; },
    getRawValue(t) { const e = this.getData(); return e.get(e.mapDimension("value"), t); },
    getRegionModel(t) { const e = this.getData(); return e.getItemModel(e.indexOfName(t)); },
    formatTooltip(t) { for (var e = this.getData(), i = Qo(this.getRawValue(t)), n = e.getName(t), o = this.seriesGroup, a = [], r = 0; r < o.length; r++) { const s = o[r].originalData.indexOfName(n); const l = e.mapDimension("value"); isNaN(o[r].originalData.get(l, s)) || a.push(ea(o[r].name)); } return `${a.join(", ")}<br />${ea(`${n} : ${i}`)}`; },
    getTooltipPosition(t) { if (t != null) { const e = this.getData().getName(t); const i = this.coordinateSystem; const n = i.getRegion(e); return n && i.dataToPoint(n.center); } },
    setZoom(t) { this.option.zoom = t; },
    setCenter(t) { this.option.center = t; },
    defaultOption: {
      zlevel: 0, z: 2, coordinateSystem: "geo", map: "", left: "center", top: "center", aspectScale: 0.75, showLegendSymbol: !0, dataRangeHoverLink: !0, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: !1, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444", areaColor: "#eee" }, emphasis: { label: { show: !0, color: "rgb(100,0,0)" }, itemStyle: { areaColor: "rgba(255,215,0,0.8)" } },
    },
  }), rC); var RC = "\0_ec_interaction_mutex"; Os({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, () => {}), h(nc, fw); var zC = { axisPointer: 1, tooltip: 1, brush: 1 }; yc.prototype = {
    constructor: yc,
    draw(t, e, i, n, o) {
      const a = t.mainType === "geo"; let r = t.getData && t.getData(); a && e.eachComponent({ mainType: "series", subType: "map" }, (e) => { r || e.getHostGeoModel() !== t || (r = e.getData()); }); const s = t.coordinateSystem; this._updateBackground(s); const l = this._regionsGroup; const u = this.group; const h = s.scale; const c = { position: s.position, scale: h }; !l.childAt(0) || o ? u.attr(c) : Mo(u, c, t), l.removeAll(); const f = ["itemStyle"]; const p = ["emphasis", "itemStyle"]; const g = ["label"]; const m = ["emphasis", "label"]; const v = R(); d(s.regions, (e) => {
        const i = v.get(e.name) || v.set(e.name, new tb()); const n = new MM({ shape: { paths: [] } }); i.add(n); let o; const s = (C = t.getRegionModel(e.name) || t).getModel(f); const u = C.getModel(p); const c = gc(s); const y = gc(u); const x = C.getModel(g); const _ = C.getModel(m); if (r) { o = r.indexOfName(e.name); const w = r.getItemVisual(o, "color", !0); w && (c.fill = w); }d(e.geometries, (t) => { if (t.type === "polygon") { n.shape.paths.push(new pM({ shape: { points: t.exterior } })); for (let e = 0; e < (t.interiors ? t.interiors.length : 0); e++)n.shape.paths.push(new pM({ shape: { points: t.interiors[e] } })); } }), n.setStyle(c), n.style.strokeNoScale = !0, n.culling = !0; const b = x.get("show"); const S = _.get("show"); const M = r && isNaN(r.get(r.mapDimension("value"), o)); const I = r && r.getItemLayout(o); if (a || M && (b || S) || I && I.showLabel) {
          let T; const A = a ? e.name : o; (!r || o >= 0) && (T = t); const D = new rM({
            position: e.center.slice(), scale: [1 / h[0], 1 / h[1]], z2: 10, silent: !0,
          }); po(D.style, D.hoverStyle = {}, x, _, {
            labelFetcher: T, labelDataIndex: A, defaultText: e.name, useInsideStyle: !1,
          }, { textAlign: "center", textVerticalAlign: "middle" }), i.add(D);
        } if (r)r.setItemGraphicEl(o, i); else {
          var C = t.getRegionModel(e.name); n.eventData = {
            componentType: "geo", componentIndex: t.componentIndex, geoIndex: t.componentIndex, name: e.name, region: C && C.option || {},
          };
        }(i.__regions || (i.__regions = [])).push(e), co(i, y, { hoverSilentOnTouch: !!t.get("selectedMode") }), l.add(i);
      }), this._updateController(t, e, i), mc(this, t, l, i, n), vc(t, l);
    },
    remove() { this._regionsGroup.removeAll(), this._backgroundGroup.removeAll(), this._controller.dispose(), this._mapName && EC.removeGraphic(this._mapName, this.uid), this._mapName = null, this._controllerHost = {}; },
    _updateBackground(t) { const e = t.map; this._mapName !== e && d(EC.makeGraphic(e, this.uid), function (t) { this._backgroundGroup.add(t); }, this), this._mapName = e; },
    _updateController(t, e, i) { function n() { const e = { type: "geoRoam", componentType: l }; return e[`${l}Id`] = t.id, e; } const o = t.coordinateSystem; const r = this._controller; const s = this._controllerHost; s.zoomLimit = t.get("scaleLimit"), s.zoom = o.getZoom(), r.enable(t.get("roam") || !1); var l = t.mainType; r.off("pan").on("pan", function (t) { this._mouseDownFlag = !1, dc(s, t.dx, t.dy), i.dispatchAction(a(n(), { dx: t.dx, dy: t.dy })); }, this), r.off("zoom").on("zoom", function (t) { if (this._mouseDownFlag = !1, fc(s, t.scale, t.originX, t.originY), i.dispatchAction(a(n(), { zoom: t.scale, originX: t.originX, originY: t.originY })), this._updateGroup) { const e = this.group.scale; this._regionsGroup.traverse((t) => { t.type === "text" && t.attr("scale", [1 / e[0], 1 / e[1]]); }); } }, this), r.setPointerChecker((e, n, a) => o.getViewRectAfterRoam().contain(n, a) && !pc(e, i, t)); },
  }; var BC = "__seriesMapHighDown"; var VC = "__seriesMapCallKey"; Hs({
    type: "map",
    render(t, e, i, n) { if (!n || n.type !== "mapToggleSelect" || n.from !== this.uid) { const o = this.group; if (o.removeAll(), !t.getHostGeoModel()) { if (n && n.type === "geoRoam" && n.componentType === "series" && n.seriesId === t.id)(a = this._mapDraw) && o.add(a.group); else if (t.needsDrawMap) { var a = this._mapDraw || new yc(i, !0); o.add(a.group), a.draw(t, e, i, this, n), this._mapDraw = a; } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null; t.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(t, e, i); } } },
    remove() { this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll(); },
    dispose() { this._mapDraw && this._mapDraw.remove(), this._mapDraw = null; },
    _renderSymbols(t, e, i) {
      const n = t.originalData; const o = this.group; n.each(n.mapDimension("value"), (e, i) => {
        if (!isNaN(e)) {
          const r = n.getItemLayout(i); if (r && r.point) {
            const s = r.point; const l = r.offset; const u = new sM({
              style: { fill: t.getData().getVisual("color") }, shape: { cx: s[0] + 9 * l, cy: s[1], r: 3 }, silent: !0, z2: 8 + (l ? 0 : NM + 1),
            }); if (!l) {
              const h = t.mainSeries.getData(); const c = n.getName(i); const d = h.indexOfName(c); const f = n.getItemModel(i); const p = f.getModel("label"); const g = f.getModel("emphasis.label"); const m = h.getItemGraphicEl(d); const y = A(t.getFormattedLabel(d, "normal"), c); const x = A(t.getFormattedLabel(d, "emphasis"), y); let _ = m[BC]; const w = Math.random(); if (!_) { _ = m[BC] = {}; const b = v(xc, !0); const S = v(xc, !1); m.on("mouseover", b).on("mouseout", S).on("emphasis", b).on("normal", S); }m[VC] = w, a(_, {
                recordVersion: w, circle: u, labelModel: p, hoverLabelModel: g, emphasisText: x, normalText: y,
              }), _c(_, !1);
            }o.add(u);
          }
        }
      });
    },
  }), Os({ type: "geoRoam", event: "geoRoam", update: "updateTransform" }, (t, e) => { const i = t.componentType || "series"; e.eachComponent({ mainType: i, query: t }, (e) => { const n = e.coordinateSystem; if (n.type === "geo") { const o = wc(n, t, e.get("scaleLimit")); e.setCenter && e.setCenter(o.center), e.setZoom && e.setZoom(o.zoom), i === "series" && d(e.seriesGroup, (t) => { t.setCenter(o.center), t.setZoom(o.zoom); }); } }); }); const GC = Q; h(bc, Tw), Sc.prototype = {
    constructor: Sc, type: "view", dimensions: ["x", "y"], setBoundingRect(t, e, i, n) { return this._rect = new de(t, e, i, n), this._rect; }, getBoundingRect() { return this._rect; }, setViewRect(t, e, i, n) { this.transformTo(t, e, i, n), this._viewRect = new de(t, e, i, n); }, transformTo(t, e, i, n) { const o = this.getBoundingRect(); const a = this._rawTransformable; a.transform = o.calculateTransform(new de(t, e, i, n)), a.decomposeTransform(), this._updateTransform(); }, setCenter(t) { t && (this._center = t, this._updateCenterAndZoom()); }, setZoom(t) { t = t || 1; const e = this.zoomLimit; e && (e.max != null && (t = Math.min(e.max, t)), e.min != null && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom(); }, getDefaultCenter() { const t = this.getBoundingRect(); return [t.x + t.width / 2, t.y + t.height / 2]; }, getCenter() { return this._center || this.getDefaultCenter(); }, getZoom() { return this._zoom || 1; }, getRoamTransform() { return this._roamTransformable.getLocalTransform(); }, _updateCenterAndZoom() { const t = this._rawTransformable.getLocalTransform(); const e = this._roamTransformable; let i = this.getDefaultCenter(); let n = this.getCenter(); const o = this.getZoom(); n = Q([], n, t), i = Q([], i, t), e.origin = n, e.position = [i[0] - n[0], i[1] - n[1]], e.scale = [o, o], this._updateTransform(); }, _updateTransform() { const t = this._roamTransformable; const e = this._rawTransformable; e.parent = t, t.updateTransform(), e.updateTransform(), wt(this.transform || (this.transform = []), e.transform || xt()), this._rawTransform = e.getLocalTransform(), this.invTransform = this.invTransform || [], Tt(this.invTransform, this.transform), this.decomposeTransform(); }, getViewRect() { return this._viewRect; }, getViewRectAfterRoam() { const t = this.getBoundingRect().clone(); return t.applyTransform(this.transform), t; }, dataToPoint(t, e, i) { const n = e ? this._rawTransform : this.transform; return i = i || [], n ? GC(i, t, n) : G(i, t); }, pointToData(t) { const e = this.invTransform; return e ? GC([], t, e) : [t[0], t[1]]; }, convertToPixel: v(Mc, "dataToPoint"), convertFromPixel: v(Mc, "pointToData"), containPoint(t) { return this.getViewRectAfterRoam().contain(t[0], t[1]); },
  }, h(Sc, Tw), Ic.prototype = {
    constructor: Ic, type: "geo", dimensions: ["lng", "lat"], containCoord(t) { for (let e = this.regions, i = 0; i < e.length; i++) if (e[i].contain(t)) return !0; return !1; }, transformTo(t, e, i, n) { let o = this.getBoundingRect(); const a = this._invertLongitute; o = o.clone(), a && (o.y = -o.y - o.height); const r = this._rawTransformable; if (r.transform = o.calculateTransform(new de(t, e, i, n)), r.decomposeTransform(), a) { const s = r.scale; s[1] = -s[1]; }r.updateTransform(), this._updateTransform(); }, getRegion(t) { return this._regionsMap.get(t); }, getRegionByCoord(t) { for (let e = this.regions, i = 0; i < e.length; i++) if (e[i].contain(t)) return e[i]; }, addGeoCoord(t, e) { this._nameCoordMap.set(t, e); }, getGeoCoord(t) { return this._nameCoordMap.get(t); }, getBoundingRect() { return this._rect; }, dataToPoint(t, e, i) { if (typeof t === "string" && (t = this.getGeoCoord(t)), t) return Sc.prototype.dataToPoint.call(this, t, e, i); }, convertToPixel: v(Tc, "dataToPoint"), convertFromPixel: v(Tc, "pointToData"),
  }, h(Ic, Sc); const FC = { dimensions: Ic.prototype.dimensions, create(t, e) { const i = []; t.eachComponent("geo", (t, n) => { const o = t.get("map"); let a = t.get("aspectScale"); let r = !0; const s = CT.retrieveMap(o); s && s[0] && s[0].type === "svg" ? (a == null && (a = 1), r = !1) : a == null && (a = 0.75); const l = new Ic(o + n, o, t.get("nameMap"), r); l.aspectScale = a, l.zoomLimit = t.get("scaleLimit"), i.push(l), Dc(l, t), t.coordinateSystem = l, l.model = t, l.resize = Ac, l.resize(t, e); }), t.eachSeries((t) => { if (t.get("coordinateSystem") === "geo") { const e = t.get("geoIndex") || 0; t.coordinateSystem = i[e]; } }); const n = {}; return t.eachSeriesByType("map", (t) => { if (!t.getHostGeoModel()) { const e = t.getMapType(); n[e] = n[e] || [], n[e].push(t); } }), d(n, (t, n) => { const a = new Ic(n, n, o(f(t, t => t.get("nameMap")))); a.zoomLimit = T.apply(null, f(t, t => t.get("scaleLimit"))), i.push(a), a.resize = Ac, a.aspectScale = t[0].get("aspectScale"), a.resize(t[0], e), d(t, (t) => { t.coordinateSystem = a, Dc(a, t); }); }), i; }, getFilledRegions(t, e, i) { for (var n = (t || []).slice(), o = R(), a = 0; a < n.length; a++)o.set(n[a].name, n[a]); return d(EC.load(e, i).regions, (t) => { const e = t.name; !o.get(e) && n.push({ name: e }); }), n; } }; Es("geo", FC); Rs((t) => { const e = {}; t.eachSeriesByType("map", (i) => { const n = i.getMapType(); if (!i.getHostGeoModel() && !e[n]) { const o = {}; d(i.seriesGroup, (e) => { const i = e.coordinateSystem; const n = e.originalData; e.get("showLegendSymbol") && t.getComponent("legend") && n.each(n.mapDimension("value"), (t, e) => { const a = n.getName(e); const r = i.getRegion(a); if (r && !isNaN(t)) { const s = o[a] || 0; const l = i.dataToPoint(r.center); o[a] = s + 1, n.setItemLayout(e, { point: l, offset: s }); } }); }); const a = i.getData(); a.each((t) => { const e = a.getName(t); const i = a.getItemLayout(t) || {}; i.showLabel = !o[e], a.setItemLayout(t, i); }), e[n] = !0; } }); }), zs((t) => { t.eachSeriesByType("map", (t) => { const e = t.get("color"); const i = t.getModel("itemStyle"); const n = i.get("areaColor"); const o = i.get("color") || e[t.seriesIndex % e.length]; t.getData().setVisual({ areaColor: n, color: o }); }); }), Ns(GT.PROCESSOR.STATISTIC, (t) => { const e = {}; t.eachSeriesByType("map", (t) => { const i = t.getHostGeoModel(); const n = i ? `o${i.id}` : `i${t.getMapType()}`; (e[n] = e[n] || []).push(t); }), d(e, (t, e) => { for (var i = Cc(f(t, t => t.getData()), t[0].get("mapValueCalculation")), n = 0; n < t.length; n++)t[n].originalData = t[n].getData(); for (n = 0; n < t.length; n++)t[n].seriesGroup = t, t[n].needsDrawMap = n === 0 && !t[n].getHostGeoModel(), t[n].setData(i.cloneShallow()), t[n].mainSeries = t[0]; }); }), Ps((t) => { const e = []; d(t.series, (t) => { t && t.type === "map" && (e.push(t), t.map = t.map || t.mapType, r(t, t.mapLocation)); }); }), uC("map", [{ type: "mapToggleSelect", event: "mapselectchanged", method: "toggleSelected" }, { type: "mapSelect", event: "mapselected", method: "select" }, { type: "mapUnSelect", event: "mapunselected", method: "unSelect" }]); var WC = d; var HC = "\0__link_datas"; var ZC = "\0__link_mainData"; const UC = function (t, e) { this.name = t || "", this.depth = 0, this.height = 0, this.parentNode = null, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.hostTree = e; }; UC.prototype = {
    constructor: UC, isRemoved() { return this.dataIndex < 0; }, eachNode(t, e, i) { typeof t === "function" && (i = e, e = t, t = null), _(t = t || {}) && (t = { order: t }); let n; const o = t.order || "preorder"; const a = this[t.attr || "children"]; o === "preorder" && (n = e.call(i, this)); for (let r = 0; !n && r < a.length; r++)a[r].eachNode(t, e, i); o === "postorder" && e.call(i, this); }, updateDepthAndHeight(t) { let e = 0; this.depth = t; for (let i = 0; i < this.children.length; i++) { const n = this.children[i]; n.updateDepthAndHeight(t + 1), n.height > e && (e = n.height); } this.height = e + 1; }, getNodeById(t) { if (this.getId() === t) return this; for (let e = 0, i = this.children, n = i.length; e < n; e++) { const o = i[e].getNodeById(t); if (o) return o; } }, contains(t) { if (t === this) return !0; for (let e = 0, i = this.children, n = i.length; e < n; e++) { const o = i[e].contains(t); if (o) return o; } }, getAncestors(t) { for (var e = [], i = t ? this : this.parentNode; i;)e.push(i), i = i.parentNode; return e.reverse(), e; }, getValue(t) { const e = this.hostTree.data; return e.get(e.getDimension(t || "value"), this.dataIndex); }, setLayout(t, e) { this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e); }, getLayout() { return this.hostTree.data.getItemLayout(this.dataIndex); }, getModel(t) { if (!(this.dataIndex < 0)) { let e; const i = this.hostTree; const n = i.data.getItemModel(this.dataIndex); const o = this.getLevelModel(); return o || this.children.length !== 0 && (this.children.length === 0 || !1 !== this.isExpand) || (e = this.getLeavesModel()), n.getModel(t, (o || e || i.hostModel).getModel(t)); } }, getLevelModel() { return (this.hostTree.levelModels || [])[this.depth]; }, getLeavesModel() { return this.hostTree.leavesModel; }, setVisual(t, e) { this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e); }, getVisual(t, e) { return this.hostTree.data.getItemVisual(this.dataIndex, t, e); }, getRawIndex() { return this.hostTree.data.getRawIndex(this.dataIndex); }, getId() { return this.hostTree.data.getId(this.dataIndex); }, isAncestorOf(t) { for (let e = t.parentNode; e;) { if (e === this) return !0; e = e.parentNode; } return !1; }, isDescendantOf(t) { return t !== this && t.isAncestorOf(this); },
  }, Bc.prototype = {
    constructor: Bc, type: "tree", eachNode(t, e, i) { this.root.eachNode(t, e, i); }, getNodeByDataIndex(t) { const e = this.data.getRawIndex(t); return this._nodes[e]; }, getNodeByName(t) { return this.root.getNodeByName(t); }, update() { for (var t = this.data, e = this._nodes, i = 0, n = e.length; i < n; i++)e[i].dataIndex = -1; for (var i = 0, n = t.count(); i < n; i++)e[t.getRawIndex(i)].dataIndex = i; }, clearLayouts() { this.data.clearItemLayouts(); },
  }, Bc.createTree = function (t, e, i) { function n(t, e) { const i = t.value; r = Math.max(r, y(i) ? i.length : 1), a.push(t); const s = new UC(t.name, o); e ? Vc(s, e) : o.root = s, o._nodes.push(s); const l = t.children; if (l) for (let u = 0; u < l.length; u++)n(l[u], s); } var o = new Bc(e, i.levels, i.leaves); var a = []; var r = 1; n(t), o.root.updateDepthAndHeight(0); const s = wA(a, { coordDimensions: ["value"], dimensionsCount: r }); const l = new yA(s, e); return l.initData(a), Lc({ mainData: l, struct: o, structAttr: "tree" }), o.update(), o; }, qI.extend({
    type: "series.tree",
    layoutInfo: null,
    layoutMode: "box",
    getInitialData(t) { const e = { name: t.name, children: t.data }; const i = t.leaves || {}; const n = {}; n.leaves = i; const o = Bc.createTree(e, this, n); let a = 0; o.eachNode("preorder", (t) => { t.depth > a && (a = t.depth); }); const r = t.expandAndCollapse && t.initialTreeDepth >= 0 ? t.initialTreeDepth : a; return o.root.eachNode("preorder", (t) => { const e = t.hostTree.data.getRawDataItem(t.dataIndex); t.isExpand = e && e.collapsed != null ? !e.collapsed : t.depth <= r; }), o.data; },
    getOrient() { let t = this.get("orient"); return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t; },
    setZoom(t) { this.option.zoom = t; },
    setCenter(t) { this.option.center = t; },
    formatTooltip(t) { for (var e = this.getData().tree, i = e.root.children[0], n = e.getNodeByDataIndex(t), o = n.getValue(), a = n.name; n && n !== i;)a = `${n.parentNode.name}.${a}`, n = n.parentNode; return ea(a + (isNaN(o) || o == null ? "" : ` : ${o}`)); },
    defaultOption: {
      zlevel: 0, z: 2, coordinateSystem: "view", left: "12%", top: "12%", right: "12%", bottom: "12%", layout: "orthogonal", roam: !1, nodeScaleRatio: 0.4, center: null, zoom: 1, orient: "LR", symbol: "emptyCircle", symbolSize: 7, expandAndCollapse: !0, initialTreeDepth: 2, lineStyle: { color: "#ccc", width: 1.5, curveness: 0.5 }, itemStyle: { color: "lightsteelblue", borderColor: "#c23531", borderWidth: 1.5 }, label: { show: !0, color: "#555" }, leaves: { label: { show: !0 } }, animationEasing: "linear", animationDuration: 700, animationDurationUpdate: 1e3,
    },
  }), Hs({
    type: "tree",
    init(t, e) { this._oldTree, this._mainGroup = new tb(), this._controller = new nc(e.getZr()), this._controllerHost = { target: this.group }, this.group.add(this._mainGroup); },
    render(t, e, i, n) {
      const o = t.getData(); const a = t.layoutInfo; const r = this._mainGroup; const s = t.get("layout"); s === "radial" ? r.attr("position", [a.x + a.width / 2, a.y + a.height / 2]) : r.attr("position", [a.x, a.y]), this._updateViewCoordSys(t), this._updateController(t, e, i); const l = this._data; const u = {
        expandAndCollapse: t.get("expandAndCollapse"), layout: s, orient: t.getOrient(), curvature: t.get("lineStyle.curveness"), symbolRotate: t.get("symbolRotate"), symbolOffset: t.get("symbolOffset"), hoverAnimation: t.get("hoverAnimation"), useNameLabel: !0, fadeIn: !0,
      }; o.diff(l).add((e) => { Qc(o, e) && ed(o, e, null, r, t, u); }).update((e, i) => { const n = l.getItemGraphicEl(i); Qc(o, e) ? ed(o, e, n, r, t, u) : n && id(l, i, n, r, t, u); }).remove((e) => { const i = l.getItemGraphicEl(e); i && id(l, e, i, r, t, u); })
        .execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), !0 === u.expandAndCollapse && o.eachItemGraphicEl((e, n) => { e.off("click").on("click", () => { i.dispatchAction({ type: "treeExpandAndCollapse", seriesId: t.id, dataIndex: n }); }); }), this._data = o;
    },
    _updateViewCoordSys(t) { const e = t.getData(); const i = []; e.each((t) => { const n = e.getItemLayout(t); !n || isNaN(n.x) || isNaN(n.y) || i.push([+n.x, +n.y]); }); const n = []; const o = []; dn(i, n, o), o[0] - n[0] == 0 && (o[0] += 1, n[0] -= 1), o[1] - n[1] == 0 && (o[1] += 1, n[1] -= 1); const a = t.coordinateSystem = new Sc(); a.zoomLimit = t.get("scaleLimit"), a.setBoundingRect(n[0], n[1], o[0] - n[0], o[1] - n[1]), a.setCenter(t.get("center")), a.setZoom(t.get("zoom")), this.group.attr({ position: a.position, scale: a.scale }), this._viewCoordSys = a; },
    _updateController(t, e, i) {
      const n = this._controller; const o = this._controllerHost; const a = this.group; n.setPointerChecker((e, n, o) => { const r = a.getBoundingRect(); return r.applyTransform(a.transform), r.contain(n, o) && !pc(e, i, t); }), n.enable(t.get("roam")), o.zoomLimit = t.get("scaleLimit"), o.zoom = t.coordinateSystem.getZoom(), n.off("pan").off("zoom").on("pan", (e) => {
        dc(o, e.dx, e.dy), i.dispatchAction({
          seriesId: t.id, type: "treeRoam", dx: e.dx, dy: e.dy,
        });
      }, this).on("zoom", function (e) {
        fc(o, e.scale, e.originX, e.originY), i.dispatchAction({
          seriesId: t.id, type: "treeRoam", zoom: e.scale, originX: e.originX, originY: e.originY,
        }), this._updateNodeAndLinkScale(t);
      }, this);
    },
    _updateNodeAndLinkScale(t) { const e = t.getData(); const i = this._getNodeGlobalScale(t); const n = [i, i]; e.eachItemGraphicEl((t, e) => { t.attr("scale", n); }); },
    _getNodeGlobalScale(t) { const e = t.coordinateSystem; if (e.type !== "view") return 1; const i = this._nodeScaleRatio; const n = e.scale; const o = n && n[0] || 1; return ((e.getZoom() - 1) * i + 1) / o; },
    dispose() { this._controller && this._controller.dispose(), this._controllerHost = {}; },
    remove() { this._mainGroup.removeAll(), this._data = null; },
  }), Os({ type: "treeExpandAndCollapse", event: "treeExpandAndCollapse", update: "update" }, (t, e) => { e.eachComponent({ mainType: "series", subType: "tree", query: t }, (e) => { const i = t.dataIndex; const n = e.getData().tree.getNodeByDataIndex(i); n.isExpand = !n.isExpand; }); }), Os({ type: "treeRoam", event: "treeRoam", update: "none" }, (t, e) => { e.eachComponent({ mainType: "series", subType: "tree", query: t }, (e) => { const i = wc(e.coordinateSystem, t); e.setCenter && e.setCenter(i.center), e.setZoom && e.setZoom(i.zoom); }); }); zs(AD("tree", "circle")), Rs((t, e) => { t.eachSeriesByType("tree", (t) => { rd(t, e); }); }), qI.extend({
    type: "series.treemap",
    layoutMode: "box",
    dependencies: ["grid", "polar"],
    _viewRoot: null,
    defaultOption: {
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      left: "center",
      top: "middle",
      right: null,
      bottom: null,
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "▶",
      zoomToNodeRatio: 0.1024,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)", borderColor: "rgba(255,255,255,0.7)", borderWidth: 1, shadowColor: "rgba(150,150,150,1)", shadowBlur: 3, shadowOffsetX: 0, shadowOffsetY: 0, textStyle: { color: "#fff" },
        },
        emphasis: { textStyle: {} },
      },
      label: {
        show: !0, distance: 0, padding: 5, position: "inside", color: "#fff", ellipsis: !0,
      },
      upperLabel: {
        show: !1, position: [0, "50%"], height: 20, color: "#fff", ellipsis: !0, verticalAlign: "middle",
      },
      itemStyle: {
        color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: "#fff", borderColorSaturation: null,
      },
      emphasis: {
        upperLabel: {
          show: !0, position: [0, "50%"], color: "#fff", ellipsis: !0, verticalAlign: "middle",
        },
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: [],
    },
    getInitialData(t, e) { const i = { name: t.name, children: t.data }; cd(i); let n = t.levels || []; n = t.levels = dd(n, e); const o = {}; return o.levels = n, Bc.createTree(i, this, o).data; },
    optionUpdated() { this.resetViewRoot(); },
    formatTooltip(t) { const e = this.getData(); const i = this.getRawValue(t); const n = Qo(y(i) ? i[0] : i); return ea(`${e.getName(t)}: ${n}`); },
    getDataParams(t) { const e = qI.prototype.getDataParams.apply(this, arguments); const i = this.getData().tree.getNodeByDataIndex(t); return e.treePathInfo = hd(i, this), e; },
    setLayoutInfo(t) { this.layoutInfo = this.layoutInfo || {}, a(this.layoutInfo, t); },
    mapIdToIndex(t) { let e = this._idIndexMap; e || (e = this._idIndexMap = R(), this._idIndexMapCount = 0); let i = e.get(t); return i == null && e.set(t, i = this._idIndexMapCount++), i; },
    getViewRoot() { return this._viewRoot; },
    resetViewRoot(t) { t ? this._viewRoot = t : t = this._viewRoot; const e = this.getRawData().tree.root; t && (t === e || e.contains(t)) || (this._viewRoot = e); },
  }); var XC = 5; fd.prototype = {
    constructor: fd,
    render(t, e, i, n) {
      const o = t.getModel("breadcrumb"); const a = this.group; if (a.removeAll(), o.get("show") && i) {
        const r = o.getModel("itemStyle"); const s = r.getModel("textStyle"); const l = {
          pos: {
            left: o.get("left"), right: o.get("right"), top: o.get("top"), bottom: o.get("bottom"),
          },
          box: { width: e.getWidth(), height: e.getHeight() },
          emptyItemWidth: o.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: [],
        }; this._prepare(i, l, s), this._renderContent(t, l, r, s, n), ca(a, l.pos, l.box);
      }
    },
    _prepare(t, e, i) { for (let n = t; n; n = n.parentNode) { const o = n.getModel().get("name"); const a = i.getTextRect(o); const r = Math.max(a.width + 16, e.emptyItemWidth); e.totalWidth += r + 8, e.renderList.push({ node: n, text: o, width: r }); } },
    _renderContent(t, e, i, n, o) {
      for (let a = 0, s = e.emptyItemWidth, l = t.get("breadcrumb.height"), u = ua(e.pos, e.box), h = e.totalWidth, c = e.renderList, d = c.length - 1; d >= 0; d--) {
        const f = c[d]; const p = f.node; let g = f.width; let m = f.text; h > u.width && (h -= g - s, g = s, m = null); const y = new pM({
          shape: { points: pd(a, 0, g, l, d === c.length - 1, d === 0) },
          style: r(i.getItemStyle(), {
            lineJoin: "bevel", text: m, textFill: n.getTextColor(), textFont: n.getFont(),
          }),
          z: 10,
          onclick: v(o, p),
        }); this.group.add(y), gd(y, t, p), a += g + 8;
      }
    },
    remove() { this.group.removeAll(); },
  }; const jC = m; var YC = tb; var qC = yM; const KC = d; var $C = ["label"]; var JC = ["emphasis", "label"]; var QC = ["upperLabel"]; var tL = ["emphasis", "upperLabel"]; var eL = 10; var iL = 1; var nL = 2; var oL = Qb([["fill", "color"], ["stroke", "strokeColor"], ["lineWidth", "strokeWidth"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]); var aL = function (t) { const e = oL(t); return e.stroke = e.fill = e.lineWidth = null, e; }; Hs({
    type: "treemap",
    init(t, e) { this._containerGroup, this._storage = { nodeGroup: [], background: [], content: [] }, this._oldTree, this._breadcrumb, this._controller, this._state = "ready"; },
    render(t, e, i, n) { if (!(l(e.findComponents({ mainType: "series", subType: "treemap", query: n }), t) < 0)) { this.seriesModel = t, this.api = i, this.ecModel = e; const o = sd(n, ["treemapZoomToNode", "treemapRootToNode"], t); const a = n && n.type; const r = t.layoutInfo; const s = !this._oldTree; const u = this._storage; const h = a === "treemapRootToNode" && o && u ? { rootNodeGroup: u.nodeGroup[o.node.getRawIndex()], direction: n.direction } : null; const c = this._giveContainerGroup(r); const d = this._doRender(c, t, h); s || a && a !== "treemapZoomToNode" && a !== "treemapRootToNode" ? d.renderFinally() : this._doAnimation(c, d, t, h), this._resetController(i), this._renderBreadcrumb(t, i, o); } },
    _giveContainerGroup(t) { let e = this._containerGroup; return e || (e = this._containerGroup = new YC(), this._initEvents(e), this.group.add(e)), e.attr("position", [t.x, t.y]), e; },
    _doRender(t, e, i) {
      function n(t, e, i, o, a) {
        function r(t) { return t.getId(); } function s(r, s) { const l = r != null ? t[r] : null; const u = s != null ? e[s] : null; const c = h(l, u, i, a); c && n(l && l.viewChildren || [], u && u.viewChildren || [], c, o, a + 1); }o ? (e = t, KC(t, (t, e) => { !t.isRemoved() && s(e, e); })) : new Us(e, t, r, r).add(s).update(s).remove(v(s, null))
          .execute();
      } const o = e.getData().tree; const a = this._oldTree; const r = { nodeGroup: [], background: [], content: [] }; const s = { nodeGroup: [], background: [], content: [] }; const l = this._storage; const u = []; var h = v(vd, e, s, l, i, r, u); n(o.root ? [o.root] : [], a && a.root ? [a.root] : [], t, o === a || !a, 0); const c = (function (t) { const e = { nodeGroup: [], background: [], content: [] }; return t && KC(t, (t, i) => { const n = e[i]; KC(t, (t) => { t && (n.push(t), t.__tmWillDelete = 1); }); }), e; }(l)); return this._oldTree = o, this._storage = s, { lastsForAnimation: r, willDeleteEls: c, renderFinally() { KC(c, (t) => { KC(t, (t) => { t.parent && t.parent.remove(t); }); }), KC(u, (t) => { t.invisible = !0, t.dirty(); }); } };
    },
    _doAnimation(t, e, i, n) {
      if (i.get("animation")) {
        const o = i.get("animationDurationUpdate"); const r = i.get("animationEasing"); const s = md(); KC(e.willDeleteEls, (t, e) => {
          KC(t, (t, i) => {
            if (!t.invisible) {
              let a; const l = t.parent; if (n && n.direction === "drillDown") {
 a = l === n.rootNodeGroup ? {
                shape: {
                  x: 0, y: 0, width: l.__tmNodeWidth, height: l.__tmNodeHeight,
                },
                style: { opacity: 0 }, 
              } : { style: { opacity: 0 } }; 
} else {
                let u = 0; let h = 0; l.__tmWillDelete || (u = l.__tmNodeWidth / 2, h = l.__tmNodeHeight / 2), a = e === "nodeGroup" ? { position: [u, h], style: { opacity: 0 } } : {
                  shape: {
                    x: u, y: h, width: 0, height: 0,
                  },
                  style: { opacity: 0 },
                };
              }a && s.add(t, a, o, r);
            }
          });
        }), KC(this._storage, (t, i) => { KC(t, (t, n) => { const l = e.lastsForAnimation[i][n]; const u = {}; l && (i === "nodeGroup" ? l.old && (u.position = t.position.slice(), t.attr("position", l.old)) : (l.old && (u.shape = a({}, t.shape), t.setShape(l.old)), l.fadein ? (t.setStyle("opacity", 0), u.style = { opacity: 1 }) : t.style.opacity !== 1 && (u.style = { opacity: 1 })), s.add(t, u, o, r)); }); }, this), this._state = "animating", s.done(jC(function () { this._state = "ready", e.renderFinally(); }, this)).start();
      }
    },
    _resetController(t) { let e = this._controller; e || ((e = this._controller = new nc(t.getZr())).enable(this.seriesModel.get("roam")), e.on("pan", jC(this._onPan, this)), e.on("zoom", jC(this._onZoom, this))); const i = new de(0, 0, t.getWidth(), t.getHeight()); e.setPointerChecker((t, e, n) => i.contain(e, n)); },
    _clearController() { let t = this._controller; t && (t.dispose(), t = null); },
    _onPan(t) {
      if (this._state !== "animating" && (Math.abs(t.dx) > 3 || Math.abs(t.dy) > 3)) {
        const e = this.seriesModel.getData().tree.root; if (!e) return; const i = e.getLayout(); if (!i) return; this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + t.dx, y: i.y + t.dy, width: i.width, height: i.height,
          },
        });
      }
    },
    _onZoom(t) {
      let e = t.originX; let i = t.originY; if (this._state !== "animating") {
        const n = this.seriesModel.getData().tree.root; if (!n) return; const o = n.getLayout(); if (!o) return; const a = new de(o.x, o.y, o.width, o.height); const r = this.seriesModel.layoutInfo; e -= r.x, i -= r.y; const s = xt(); St(s, s, [-e, -i]), It(s, s, [t.scale, t.scale]), St(s, s, [e, i]), a.applyTransform(s), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: a.x, y: a.y, width: a.width, height: a.height,
          },
        });
      }
    },
    _initEvents(t) { t.on("click", function (t) { if (this._state === "ready") { const e = this.seriesModel.get("nodeClick", !0); if (e) { const i = this.findTarget(t.offsetX, t.offsetY); if (i) { const n = i.node; if (n.getLayout().isLeafRoot) this._rootToNode(i); else if (e === "zoomToNode") this._zoomToNode(i); else if (e === "link") { const o = n.hostTree.data.getItemModel(n.dataIndex); const a = o.get("link", !0); const r = o.get("target", !0) || "blank"; a && window.open(a, r); } } } } }, this); },
    _renderBreadcrumb(t, e, i) { i || (i = t.get("leafDepth", !0) != null ? { node: t.getViewRoot() } : this.findTarget(e.getWidth() / 2, e.getHeight() / 2)) || (i = { node: t.getData().tree.root }), (this._breadcrumb || (this._breadcrumb = new fd(this.group))).render(t, e, i.node, jC(function (e) { this._state !== "animating" && (ud(t.getViewRoot(), e) ? this._rootToNode({ node: e }) : this._zoomToNode({ node: e })); }, this)); },
    remove() { this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = { nodeGroup: [], background: [], content: [] }, this._state = "ready", this._breadcrumb && this._breadcrumb.remove(); },
    dispose() { this._clearController(); },
    _zoomToNode(t) {
      this.api.dispatchAction({
        type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node,
      });
    },
    _rootToNode(t) {
      this.api.dispatchAction({
        type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node,
      });
    },
    findTarget(t, e) { let i; return this.seriesModel.getViewRoot().eachNode({ attr: "viewChildren", order: "preorder" }, function (n) { const o = this._storage.background[n.getRawIndex()]; if (o) { const a = o.transformCoordToLocal(t, e); const r = o.shape; if (!(r.x <= a[0] && a[0] <= r.x + r.width && r.y <= a[1] && a[1] <= r.y + r.height)) return !1; i = { node: n, offsetX: a[0], offsetY: a[1] }; } }, this), i; },
  }); for (let rL = ["treemapZoomToNode", "treemapRender", "treemapMove"], sL = 0; sL < rL.length; sL++)Os({ type: rL[sL], update: "updateView" }, () => {}); Os({ type: "treemapRootToNode", update: "updateView" }, (t, e) => { e.eachComponent({ mainType: "series", subType: "treemap", query: t }, (e, i) => { const n = sd(t, ["treemapZoomToNode", "treemapRootToNode"], e); if (n) { const o = e.getViewRoot(); o && (t.direction = ud(o, n.node) ? "rollUp" : "drillDown"), e.resetViewRoot(n.node); } }); }); var lL = d; const uL = w; var hL = -1; var cL = function (t) { const e = t.mappingMethod; const n = t.type; const o = this.option = i(t); this.type = n, this.mappingMethod = e, this._normalizeData = fL[e]; const a = dL[n]; this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._doMap = a._doMap[e], e === "piecewise" ? (wd(o), xd(o)) : e === "category" ? o.categories ? _d(o) : wd(o, !0) : (k(e !== "linear" || o.dataExtent), wd(o)); }; cL.prototype = { constructor: cL, mapValueToVisual(t) { const e = this._normalizeData(t); return this._doMap(e, t); }, getNormalizer() { return m(this._normalizeData, this); } }; var dL = cL.visualHandlers = {
    color: {
      applyVisual: Md("color"),
      getColorMapper() { const t = this.option; return m(t.mappingMethod === "category" ? function (t, e) { return !e && (t = this._normalizeData(t)), Id.call(this, t); } : function (e, i, n) { const o = !!n; return !i && (e = this._normalizeData(e)), n = Ut(e, t.parsedVisual, n), o ? n : qt(n, "rgba"); }, this); },
      _doMap: {
        linear(t) { return qt(Ut(t, this.option.parsedVisual), "rgba"); }, category: Id, piecewise(t, e) { let i = Dd.call(this, e); return i == null && (i = qt(Ut(t, this.option.parsedVisual), "rgba")), i; }, fixed: Td,
      },
    },
    colorHue: bd((t, e) => jt(t, e)),
    colorSaturation: bd((t, e) => jt(t, null, e)),
    colorLightness: bd((t, e) => jt(t, null, null, e)),
    colorAlpha: bd((t, e) => Yt(t, e)),
    opacity: { applyVisual: Md("opacity"), _doMap: Ad([0, 1]) },
    liftZ: {
      applyVisual: Md("liftZ"),
      _doMap: {
        linear: Td, category: Td, piecewise: Td, fixed: Td,
      },
    },
    symbol: {
      applyVisual(t, e, i) { const n = this.mapValueToVisual(t); if (_(n))i("symbol", n); else if (uL(n)) for (const o in n)n.hasOwnProperty(o) && i(o, n[o]); },
      _doMap: {
        linear: Sd, category: Id, piecewise(t, e) { let i = Dd.call(this, e); return i == null && (i = Sd.call(this, t)), i; }, fixed: Td,
      },
    },
    symbolSize: { applyVisual: Md("symbolSize"), _doMap: Ad([0, 1]) },
  }; var fL = {
    linear(t) { return zo(t, this.option.dataExtent, [0, 1], !0); }, piecewise(t) { const e = this.option.pieceList; const i = cL.findPieceIndex(t, e, !0); if (i != null) return zo(i, [0, e.length - 1], [0, 1], !0); }, category(t) { const e = this.option.categories ? this.option.categoryMap[t] : t; return e == null ? hL : e; }, fixed: B,
  }; cL.listVisualTypes = function () { const t = []; return d(dL, (e, i) => { t.push(i); }), t; }, cL.addVisualHandler = function (t, e) { dL[t] = e; }, cL.isValidType = function (t) { return dL.hasOwnProperty(t); }, cL.eachVisual = function (t, e, i) { w(t) ? d(t, e, i) : e.call(i, t); }, cL.mapVisual = function (t, e, i) { let n; let o = y(t) ? [] : w(t) ? {} : (n = !0, null); return cL.eachVisual(t, (t, a) => { const r = e.call(i, t, a); n ? o = r : o[a] = r; }), o; }, cL.retrieveVisuals = function (t) { let e; const i = {}; return t && lL(dL, (n, o) => { t.hasOwnProperty(o) && (i[o] = t[o], e = !0); }), e ? i : null; }, cL.prepareVisualTypes = function (t) { if (uL(t)) { const e = []; lL(t, (t, i) => { e.push(i); }), t = e; } else { if (!y(t)) return []; t = t.slice(); } return t.sort((t, e) => (e === "color" && t !== "color" && t.indexOf("color") === 0 ? 1 : -1)), t; }, cL.dependsOn = function (t, e) { return e === "color" ? !(!t || t.indexOf(e) !== 0) : t === e; }, cL.findPieceIndex = function (t, e, i) { function n(e, i) { const n = Math.abs(e - t); n < a && (a = n, o = i); } for (var o, a = 1 / 0, r = 0, s = e.length; r < s; r++) { const l = e[r].value; if (l != null) { if (l === t || typeof l === "string" && l === `${t}`) return r; i && n(l, r); } } for (var r = 0, s = e.length; r < s; r++) { const u = e[r]; const h = u.interval; const c = u.close; if (h) { if (h[0] === -1 / 0) { if (Ld(c[1], t, h[1])) return r; } else if (h[1] === 1 / 0) { if (Ld(c[0], h[0], t)) return r; } else if (Ld(c[0], h[0], t) && Ld(c[1], t, h[1])) return r; i && n(h[0], r), i && n(h[1], r); } } if (i) return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : o; }; var pL = y; var gL = "itemStyle"; const mL = { seriesType: "treemap", reset(t, e, i, n) { const o = t.getData().tree; const a = o.root; const r = t.getModel(gL); a.isRemoved() || kd(a, {}, f(o.levelModels, t => (t ? t.get(gL) : null)), r, t.getViewRoot().getAncestors(), t); } }; var vL = Math.max; var yL = Math.min; const xL = T; var _L = d; var wL = ["itemStyle", "borderWidth"]; var bL = ["itemStyle", "gapWidth"]; var SL = ["upperLabel", "show"]; var ML = ["upperLabel", "height"]; const IL = {
    seriesType: "treemap",
    reset(t, e, i, n) {
      const o = i.getWidth(); const r = i.getHeight(); const s = t.option; const l = ha(t.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }); const u = s.size || []; const h = Bo(xL(l.width, u[0]), o); const c = Bo(xL(l.height, u[1]), r); const d = n && n.type; const f = sd(n, ["treemapZoomToNode", "treemapRootToNode"], t); const p = d === "treemapRender" || d === "treemapMove" ? n.rootRect : null; const g = t.getViewRoot(); const m = ld(g); if (d !== "treemapMove") {
        const v = d === "treemapZoomToNode" ? Xd(t, f, g, h, c) : p ? [p.width, p.height] : [h, c]; let y = s.sort; y && y !== "asc" && y !== "desc" && (y = "desc"); const x = { squareRatio: s.squareRatio, sort: y, leafDepth: s.leafDepth }; g.hostTree.clearLayouts(); _ = {
          x: 0, y: 0, width: v[0], height: v[1], area: v[0] * v[1],
        }; g.setLayout(_), Vd(g, x, !1, 0); var _ = g.getLayout(); _L(m, (t, e) => { const i = (m[e + 1] || g).getValue(); t.setLayout(a({ dataExtent: [i, i], borderWidth: 0, upperHeight: 0 }, _)); });
      } const w = t.getData().tree.root; w.setLayout(jd(l, p, f), !0), t.setLayoutInfo(l), Yd(w, new de(-l.x, -l.y, o, r), m, g, 0);
    },
  }; zs(mL), Rs(IL); const TL = function (t) { this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData; }; const AL = TL.prototype; AL.type = "graph", AL.isDirected = function () { return this._directed; }, AL.addNode = function (t, e) { t = t || `${e}`; const i = this._nodesMap; if (!i[Kd(t)]) { const n = new $d(t, e); return n.hostGraph = this, this.nodes.push(n), i[Kd(t)] = n, n; } }, AL.getNodeByIndex = function (t) { const e = this.data.getRawIndex(t); return this.nodes[e]; }, AL.getNodeById = function (t) { return this._nodesMap[Kd(t)]; }, AL.addEdge = function (t, e, i) { const n = this._nodesMap; const o = this._edgesMap; if (typeof t === "number" && (t = this.nodes[t]), typeof e === "number" && (e = this.nodes[e]), $d.isInstance(t) || (t = n[Kd(t)]), $d.isInstance(e) || (e = n[Kd(e)]), t && e) { const a = `${t.id}-${e.id}`; if (!o[a]) { const r = new Jd(t, e, i); return r.hostGraph = this, this._directed && (t.outEdges.push(r), e.inEdges.push(r)), t.edges.push(r), t !== e && e.edges.push(r), this.edges.push(r), o[a] = r, r; } } }, AL.getEdgeByIndex = function (t) { const e = this.edgeData.getRawIndex(t); return this.edges[e]; }, AL.getEdge = function (t, e) { $d.isInstance(t) && (t = t.id), $d.isInstance(e) && (e = e.id); const i = this._edgesMap; return this._directed ? i[`${t}-${e}`] : i[`${t}-${e}`] || i[`${e}-${t}`]; }, AL.eachNode = function (t, e) { for (let i = this.nodes, n = i.length, o = 0; o < n; o++)i[o].dataIndex >= 0 && t.call(e, i[o], o); }, AL.eachEdge = function (t, e) { for (let i = this.edges, n = i.length, o = 0; o < n; o++)i[o].dataIndex >= 0 && i[o].node1.dataIndex >= 0 && i[o].node2.dataIndex >= 0 && t.call(e, i[o], o); }, AL.breadthFirstTraverse = function (t, e, i, n) { if ($d.isInstance(e) || (e = this._nodesMap[Kd(e)]), e) { for (var o = i === "out" ? "outEdges" : i === "in" ? "inEdges" : "edges", a = 0; a < this.nodes.length; a++) this.nodes[a].__visited = !1; if (!t.call(n, e, null)) for (let r = [e]; r.length;) for (var s = r.shift(), l = s[o], a = 0; a < l.length; a++) { const u = l[a]; const h = u.node1 === s ? u.node2 : u.node1; if (!h.__visited) { if (t.call(n, h, s)) return; r.push(h), h.__visited = !0; } } } }, AL.update = function () { for (var t = this.data, e = this.edgeData, i = this.nodes, n = this.edges, o = 0, a = i.length; o < a; o++)i[o].dataIndex = -1; for (var o = 0, a = t.count(); o < a; o++)i[t.getRawIndex(o)].dataIndex = o; e.filterSelf((t) => { const i = n[e.getRawIndex(t)]; return i.node1.dataIndex >= 0 && i.node2.dataIndex >= 0; }); for (var o = 0, a = n.length; o < a; o++)n[o].dataIndex = -1; for (var o = 0, a = e.count(); o < a; o++)n[e.getRawIndex(o)].dataIndex = o; }, AL.clone = function () { for (var t = new TL(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++)t.addNode(e[n].id, e[n].dataIndex); for (n = 0; n < i.length; n++) { const o = i[n]; t.addEdge(o.node1.id, o.node2.id, o.dataIndex); } return t; }, $d.prototype = {
    constructor: $d, degree() { return this.edges.length; }, inDegree() { return this.inEdges.length; }, outDegree() { return this.outEdges.length; }, getModel(t) { if (!(this.dataIndex < 0)) return this.hostGraph.data.getItemModel(this.dataIndex).getModel(t); },
  }, Jd.prototype.getModel = function (t) { if (!(this.dataIndex < 0)) return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(t); }; const DL = function (t, e) {
    return {
      getValue(i) { const n = this[t][e]; return n.get(n.getDimension(i || "value"), this.dataIndex); }, setVisual(i, n) { this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, i, n); }, getVisual(i, n) { return this[t][e].getItemVisual(this.dataIndex, i, n); }, setLayout(i, n) { this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, i, n); }, getLayout() { return this[t][e].getItemLayout(this.dataIndex); }, getGraphicEl() { return this[t][e].getItemGraphicEl(this.dataIndex); }, getRawIndex() { return this[t][e].getRawIndex(this.dataIndex); },
    };
  }; h($d, DL("hostGraph", "data")), h(Jd, DL("hostGraph", "edgeData")), TL.Node = $d, TL.Edge = Jd, ji($d), ji(Jd); const CL = function (t, e, i, n, o) {
    for (var a = new TL(n), r = 0; r < t.length; r++)a.addNode(T(t[r].id, t[r].name, r), r); for (var s = [], u = [], h = 0, r = 0; r < e.length; r++) { const c = e[r]; const d = c.source; const f = c.target; a.addEdge(d, f, h) && (u.push(c), s.push(T(c.id, `${d} > ${f}`)), h++); } let p; const g = i.get("coordinateSystem"); if (g === "cartesian2d" || g === "polar")p = gl(t, i); else { const m = Ga.get(g); const v = m && m.type !== "view" ? m.dimensions || [] : []; l(v, "value") < 0 && v.concat(["value"]); const y = wA(t, { coordDimensions: v }); (p = new yA(y, i)).initData(t); } const x = new yA(["value"], i); return x.initData(u, s), o && o(p, x), Lc({
      mainData: p, struct: a, structAttr: "graph", datas: { node: p, edge: x }, datasAttr: { node: "data", edge: "edgeData" },
    }), a.update(), a;
  }; var LL = Ws({
    type: "series.graph",
    init(t) { LL.superApply(this, "init", arguments), this.legendDataProvider = function () { return this._categoriesData; }, this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData(); },
    mergeOption(t) { LL.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData(); },
    mergeDefaultAndTheme(t) { LL.superApply(this, "mergeDefaultAndTheme", arguments), Ci(t, ["edgeLabel"], ["show"]); },
    getInitialData(t, e) { const i = t.edges || t.links || []; const n = t.data || t.nodes || []; const o = this; if (n && i) return CL(n, i, this, !0, (t, i) => { function n(t) { return (t = this.parsePath(t)) && t[0] === "label" ? r : t && t[0] === "emphasis" && t[1] === "label" ? l : this.parentModel; }t.wrapMethod("getItemModel", (t) => { const e = o._categoriesModels[t.getShallow("category")]; return e && (e.parentModel = t.parentModel, t.parentModel = e), t; }); const a = o.getModel("edgeLabel"); var r = new Po({ label: a.option }, a.parentModel, e); const s = o.getModel("emphasis.edgeLabel"); var l = new Po({ emphasis: { label: s.option } }, s.parentModel, e); i.wrapMethod("getItemModel", t => t.customizeGetParent(n), t); }).data; },
    getGraph() { return this.getData().graph; },
    getEdgeData() { return this.getGraph().edgeData; },
    getCategoriesData() { return this._categoriesData; },
    formatTooltip(t, e, i) { if (i === "edge") { const n = this.getData(); const o = this.getDataParams(t, i); const a = n.graph.getEdgeByIndex(t); const r = n.getName(a.node1.dataIndex); const s = n.getName(a.node2.dataIndex); let l = []; return r != null && l.push(r), s != null && l.push(s), l = ea(l.join(" > ")), o.value && (l += ` : ${ea(o.value)}`), l; } return LL.superApply(this, "formatTooltip", arguments); },
    _updateCategoriesData() { const t = f(this.option.categories || [], t => (t.value != null ? t : a({ value: 0 }, t))); const e = new yA(["value"], this); e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(t => e.getItemModel(t, !0)); },
    setZoom(t) { this.option.zoom = t; },
    setCenter(t) { this.option.center = t; },
    isAnimationEnabled() { return LL.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation")); },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      legendHoverLink: !0,
      hoverAnimation: !0,
      layout: null,
      focusNodeAdjacency: !1,
      circular: { rotateLabel: !1 },
      force: {
        initLayout: null, repulsion: [0, 50], gravity: 0.1, edgeLength: 30, layoutAnimation: !0,
      },
      left: "center",
      top: "center",
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: { position: "middle" },
      draggable: !1,
      roam: !1,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: { show: !1, formatter: "{b}" },
      itemStyle: {},
      lineStyle: {
        color: "#aaa", width: 1, curveness: 0, opacity: 0.5,
      },
      emphasis: { label: { show: !0 } },
    },
  }); const kL = _M.prototype; const PL = bM.prototype; var NL = Zn({
    type: "ec-line",
    style: { stroke: "#000", fill: null },
    shape: {
      x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null,
    },
    buildPath(t, e) { (Qd(e) ? kL : PL).buildPath(t, e); },
    pointAt(t) { return Qd(this.shape) ? kL.pointAt.call(this, t) : PL.pointAt.call(this, t); },
    tangentAt(t) { const e = this.shape; const i = Qd(e) ? [e.x2 - e.x1, e.y2 - e.y1] : PL.tangentAt.call(this, t); return q(i, i); },
  }); const OL = ["fromSymbol", "toSymbol"]; const EL = af.prototype; EL.beforeUpdate = function () { const t = this; const e = t.childOfName("fromSymbol"); const i = t.childOfName("toSymbol"); const n = t.childOfName("label"); if (e || i || !n.ignore) { for (var o = 1, a = this.parent; a;)a.scale && (o /= a.scale[0]), a = a.parent; const r = t.childOfName("line"); if (this.__dirty || r.__dirty) { const s = r.shape.percent; const l = r.pointAt(0); const u = r.pointAt(s); const h = U([], u, l); if (q(h, h), e && (e.attr("position", l), c = r.tangentAt(0), e.attr("rotation", Math.PI / 2 - Math.atan2(c[1], c[0])), e.attr("scale", [o * s, o * s])), i) { i.attr("position", u); var c = r.tangentAt(1); i.attr("rotation", -Math.PI / 2 - Math.atan2(c[1], c[0])), i.attr("scale", [o * s, o * s]); } if (!n.ignore) { n.attr("position", u); let d; let f; let p; const g = 5 * o; if (n.__position === "end")d = [h[0] * g + u[0], h[1] * g + u[1]], f = h[0] > 0.8 ? "left" : h[0] < -0.8 ? "right" : "center", p = h[1] > 0.8 ? "top" : h[1] < -0.8 ? "bottom" : "middle"; else if (n.__position === "middle") { const m = s / 2; const v = [(c = r.tangentAt(m))[1], -c[0]]; const y = r.pointAt(m); v[1] > 0 && (v[0] = -v[0], v[1] = -v[1]), d = [y[0] + v[0] * g, y[1] + v[1] * g], f = "center", p = "bottom"; let x = -Math.atan2(c[1], c[0]); u[0] < l[0] && (x = Math.PI + x), n.attr("rotation", x); } else d = [-h[0] * g + l[0], -h[1] * g + l[1]], f = h[0] > 0.8 ? "right" : h[0] < -0.8 ? "left" : "center", p = h[1] > 0.8 ? "bottom" : h[1] < -0.8 ? "top" : "middle"; n.attr({ style: { textVerticalAlign: n.__verticalAlign || p, textAlign: n.__textAlign || f }, position: d, scale: [o, o] }); } } } }, EL._createLine = function (t, e, i) { const n = t.hostModel; const o = nf(t.getItemLayout(e)); o.shape.percent = 0, Io(o, { shape: { percent: 1 } }, n, e), this.add(o); const a = new rM({ name: "label", lineLabelOriginalOpacity: 1 }); this.add(a), d(OL, function (i) { const n = ef(i, t, e); this.add(n), this[tf(i)] = t.getItemVisual(e, i); }, this), this._updateCommonStl(t, e, i); }, EL.updateData = function (t, e, i) { const n = t.hostModel; const o = this.childOfName("line"); const a = t.getItemLayout(e); const r = { shape: {} }; of(r.shape, a), Mo(o, r, n, e), d(OL, function (i) { const n = t.getItemVisual(e, i); const o = tf(i); if (this[o] !== n) { this.remove(this.childOfName(i)); const a = ef(i, t, e); this.add(a); } this[o] = n; }, this), this._updateCommonStl(t, e, i); }, EL._updateCommonStl = function (t, e, i) {
    const n = t.hostModel; const o = this.childOfName("line"); let a = i && i.lineStyle; let s = i && i.hoverLineStyle; let l = i && i.labelModel; let u = i && i.hoverLabelModel; if (!i || t.hasItemOption) { const h = t.getItemModel(e); a = h.getModel("lineStyle").getLineStyle(), s = h.getModel("emphasis.lineStyle").getLineStyle(), l = h.getModel("label"), u = h.getModel("emphasis.label"); } const c = t.getItemVisual(e, "color"); const f = D(t.getItemVisual(e, "opacity"), a.opacity, 1); o.useStyle(r({
      strokeNoScale: !0, fill: "none", stroke: c, opacity: f,
    }, a)), o.hoverStyle = s, d(OL, function (t) { const e = this.childOfName(t); e && (e.setColor(c), e.setStyle({ opacity: f })); }, this); let p; let g; const m = l.getShallow("show"); const v = u.getShallow("show"); const y = this.childOfName("label"); if ((m || v) && (p = c || "#000", (g = n.getFormattedLabel(e, "normal", t.dataType)) == null)) { const x = n.getRawValue(e); g = x == null ? t.getName(e) : isFinite(x) ? Vo(x) : x; } const _ = m ? g : null; const w = v ? A(n.getFormattedLabel(e, "emphasis", t.dataType), g) : null; const b = y.style; _ == null && w == null || (go(y.style, l, { text: _ }, { autoColor: p }), y.__textAlign = b.textAlign, y.__verticalAlign = b.textVerticalAlign, y.__position = l.get("position") || "middle"), y.hoverStyle = w != null ? {
      text: w, textFill: u.getTextColor(!0), fontStyle: u.getShallow("fontStyle"), fontWeight: u.getShallow("fontWeight"), fontSize: u.getShallow("fontSize"), fontFamily: u.getShallow("fontFamily"),
    } : { text: null }, y.ignore = !m && !v, co(this);
  }, EL.highlight = function () { this.trigger("emphasis"); }, EL.downplay = function () { this.trigger("normal"); }, EL.updateLayout = function (t, e) { this.setLinePoints(t.getItemLayout(e)); }, EL.setLinePoints = function (t) { const e = this.childOfName("line"); of(e.shape, t), e.dirty(); }, u(af, tb); const RL = rf.prototype; RL.isPersistent = function () { return !0; }, RL.updateData = function (t) {
    const e = this; const i = e.group; const n = e._lineData; e._lineData = t, n || i.removeAll(); const o = uf(t); t.diff(n).add((i) => { sf(e, t, i, o); }).update((i, a) => { lf(e, n, t, a, i, o); }).remove((t) => { i.remove(n.getItemGraphicEl(t)); })
      .execute();
  }, RL.updateLayout = function () { const t = this._lineData; t && t.eachItemGraphicEl((e, i) => { e.updateLayout(t, i); }, this); }, RL.incrementalPrepareUpdate = function (t) { this._seriesScope = uf(t), this._lineData = null, this.group.removeAll(); }, RL.incrementalUpdate = function (t, e) { for (let i = t.start; i < t.end; i++) if (cf(e.getItemLayout(i))) { const n = new this._ctor(e, i, this._seriesScope); n.traverse((t) => { t.isGroup || (t.incremental = t.useHoverLayer = !0); }), this.group.add(n), e.setItemGraphicEl(i, n); } }, RL.remove = function () { this._clearIncremental(), this._incremental = null, this.group.removeAll(); }, RL._clearIncremental = function () { const t = this._incremental; t && t.clearDisplaybles(); }; var zL = []; var BL = []; var VL = []; var GL = rn; var FL = hw; var WL = Math.abs; const HL = function (t, e) { function i(t) { let e = t.getVisual("symbolSize"); return e instanceof Array && (e = (e[0] + e[1]) / 2), e; } const n = []; const o = hn; const a = [[], [], []]; const r = [[], []]; const s = []; e /= 2, t.eachEdge((t, l) => { const u = t.getLayout(); const h = t.getVisual("fromSymbol"); const c = t.getVisual("toSymbol"); u.__original || (u.__original = [F(u[0]), F(u[1])], u[2] && u.__original.push(F(u[2]))); const d = u.__original; if (u[2] != null) { if (G(a[0], d[0]), G(a[1], d[2]), G(a[2], d[1]), h && h !== "none") { var f = i(t.node1); var p = df(a, d[0], f * e); o(a[0][0], a[1][0], a[2][0], p, n), a[0][0] = n[3], a[1][0] = n[4], o(a[0][1], a[1][1], a[2][1], p, n), a[0][1] = n[3], a[1][1] = n[4]; } if (c && c !== "none") { var f = i(t.node2); var p = df(a, d[1], f * e); o(a[0][0], a[1][0], a[2][0], p, n), a[1][0] = n[1], a[2][0] = n[2], o(a[0][1], a[1][1], a[2][1], p, n), a[1][1] = n[1], a[2][1] = n[2]; }G(u[0], a[0]), G(u[1], a[2]), G(u[2], a[1]); } else { if (G(r[0], d[0]), G(r[1], d[1]), U(s, r[1], r[0]), q(s, s), h && h !== "none") { f = i(t.node1); Z(r[0], r[0], s, f * e); } if (c && c !== "none") { f = i(t.node2); Z(r[1], r[1], s, -f * e); }G(u[0], r[0]), G(u[1], r[1]); } }); }; const ZL = "__focusNodeAdjacency"; const UL = ["itemStyle", "opacity"]; const XL = ["lineStyle", "opacity"]; Hs({
    type: "graph",
    init(t, e) {
      const i = new Au(); const n = new rf(); const
        o = this.group; this._controller = new nc(e.getZr()), this._controllerHost = { target: o }, o.add(i.group), o.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0;
    },
    render(t, e, i) { const n = t.coordinateSystem; this._model = t, this._nodeScaleRatio = t.get("nodeScaleRatio"); const o = this._symbolDraw; const a = this._lineDraw; const r = this.group; if (n.type === "view") { const s = { position: n.position, scale: n.scale }; this._firstRender ? r.attr(s) : Mo(r, s, t); }HL(t.getGraph(), this._getNodeGlobalScale(t)); const l = t.getData(); o.updateData(l); const u = t.getEdgeData(); a.updateData(u), this._updateNodeAndLinkScale(), this._updateController(t, e, i), clearTimeout(this._layoutTimeout); const h = t.forceLayout; const c = t.get("force.layoutAnimation"); h && this._startForceLayoutIteration(h, c), l.eachItemGraphicEl(function (e, n) { const o = l.getItemModel(n); e.off("drag").off("dragend"); const a = o.get("draggable"); a && e.on("drag", function () { h && (h.warmUp(), !this._layouting && this._startForceLayoutIteration(h, c), h.setFixed(n), l.setItemLayout(n, e.position)); }, this).on("dragend", () => { h && h.setUnfixed(n); }, this), e.setDraggable(a && h), e[ZL] && e.off("mouseover", e[ZL]), e.__unfocusNodeAdjacency && e.off("mouseout", e.__unfocusNodeAdjacency), o.get("focusNodeAdjacency") && (e.on("mouseover", e[ZL] = function () { i.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, dataIndex: e.dataIndex }); }), e.on("mouseout", e.__unfocusNodeAdjacency = function () { i.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: t.id }); })); }, this), l.graph.eachEdge((e) => { const n = e.getGraphicEl(); n[ZL] && n.off("mouseover", n[ZL]), n.__unfocusNodeAdjacency && n.off("mouseout", n.__unfocusNodeAdjacency), e.getModel().get("focusNodeAdjacency") && (n.on("mouseover", n[ZL] = function () { i.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, edgeDataIndex: e.dataIndex }); }), n.on("mouseout", n.__unfocusNodeAdjacency = function () { i.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: t.id }); })); }); const d = t.get("layout") === "circular" && t.get("circular.rotateLabel"); const f = l.getLayout("cx"); const p = l.getLayout("cy"); l.eachItemGraphicEl((t, e) => { const i = t.getSymbolPath(); if (d) { const n = l.getItemLayout(e); let o = Math.atan2(n[1] - p, n[0] - f); o < 0 && (o = 2 * Math.PI + o); const a = n[0] < f; a && (o -= Math.PI); const r = a ? "left" : "right"; i.setStyle({ textRotation: -o, textPosition: r, textOrigin: "center" }), i.hoverStyle && (i.hoverStyle.textPosition = r); } else i.setStyle({ textRotation: 0 }); }), this._firstRender = !1; },
    dispose() { this._controller && this._controller.dispose(), this._controllerHost = {}; },
    focusNodeAdjacency(t, e, i, n) { const o = this._model.getData().graph; const a = n.dataIndex; const r = n.edgeDataIndex; const s = o.getNodeByIndex(a); const l = o.getEdgeByIndex(r); (s || l) && (o.eachNode((t) => { pf(t, UL, 0.1); }), o.eachEdge((t) => { pf(t, XL, 0.1); }), s && (gf(s, UL), d(s.edges, (t) => { t.dataIndex < 0 || (gf(t, XL), gf(t.node1, UL), gf(t.node2, UL)); })), l && (gf(l, XL), gf(l.node1, UL), gf(l.node2, UL))); },
    unfocusNodeAdjacency(t, e, i, n) { const o = this._model.getData().graph; o.eachNode((t) => { pf(t, UL); }), o.eachEdge((t) => { pf(t, XL); }); },
    _startForceLayoutIteration(t, e) { const i = this; !(function n() { t.step((t) => { i.updateLayout(i._model), (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n()); }); }()); },
    _updateController(t, e, i) {
      const n = this._controller; const o = this._controllerHost; const a = this.group; n.setPointerChecker((e, n, o) => { const r = a.getBoundingRect(); return r.applyTransform(a.transform), r.contain(n, o) && !pc(e, i, t); }), t.coordinateSystem.type === "view" ? (n.enable(t.get("roam")), o.zoomLimit = t.get("scaleLimit"), o.zoom = t.coordinateSystem.getZoom(), n.off("pan").off("zoom").on("pan", (e) => {
        dc(o, e.dx, e.dy), i.dispatchAction({
          seriesId: t.id, type: "graphRoam", dx: e.dx, dy: e.dy,
        });
      }).on("zoom", function (e) {
        fc(o, e.scale, e.originX, e.originY), i.dispatchAction({
          seriesId: t.id, type: "graphRoam", zoom: e.scale, originX: e.originX, originY: e.originY,
        }), this._updateNodeAndLinkScale(), HL(t.getGraph(), this._getNodeGlobalScale(t)), this._lineDraw.updateLayout();
      }, this)) : n.disable();
    },
    _updateNodeAndLinkScale() { const t = this._model; const e = t.getData(); const i = this._getNodeGlobalScale(t); const n = [i, i]; e.eachItemGraphicEl((t, e) => { t.attr("scale", n); }); },
    _getNodeGlobalScale(t) { const e = t.coordinateSystem; if (e.type !== "view") return 1; const i = this._nodeScaleRatio; const n = e.scale; const o = n && n[0] || 1; return ((e.getZoom() - 1) * i + 1) / o; },
    updateLayout(t) { HL(t.getGraph(), this._getNodeGlobalScale(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout(); },
    remove(t, e) { this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove(); },
  }), Os({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series:focusNodeAdjacency" }, () => {}), Os({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series:unfocusNodeAdjacency" }, () => {}), Os({ type: "graphRoam", event: "graphRoam", update: "none" }, (t, e) => { e.eachComponent({ mainType: "series", query: t }, (e) => { const i = wc(e.coordinateSystem, t); e.setCenter && e.setCenter(i.center), e.setZoom && e.setZoom(i.zoom); }); }); var jL = Z; Ns(function (t) { const e = t.findComponents({ mainType: "legend" }); e && e.length && t.eachSeriesByType("graph", (t) => { const i = t.getCategoriesData(); const n = t.getGraph().data; const o = i.mapArray(i.getName); n.filterSelf((t) => { let i = n.getItemModel(t).getShallow("category"); if (i != null) { typeof i === "number" && (i = o[i]); for (let a = 0; a < e.length; a++) if (!e[a].isSelected(i)) return !1; } return !0; }); }, this); }), zs(AD("graph", "circle", null)), zs((t) => { const e = {}; t.eachSeriesByType("graph", (t) => { const i = t.getCategoriesData(); const n = t.getData(); const o = {}; i.each((n) => { const a = i.getName(n); o[`ec-${a}`] = n; const r = i.getItemModel(n).get("itemStyle.color") || t.getColorFromPalette(a, e); i.setItemVisual(n, "color", r); }), i.count() && n.each((t) => { let e = n.getItemModel(t).getShallow("category"); e != null && (typeof e === "string" && (e = o[`ec-${e}`]), n.getItemVisual(t, "color", !0) || n.setItemVisual(t, "color", i.getItemVisual(e, "color"))); }); }); }), zs((t) => { t.eachSeriesByType("graph", (t) => { const e = t.getGraph(); const i = t.getEdgeData(); const n = mf(t.get("edgeSymbol")); const o = mf(t.get("edgeSymbolSize")); const a = "lineStyle.color".split("."); const r = "lineStyle.opacity".split("."); i.setVisual("fromSymbol", n && n[0]), i.setVisual("toSymbol", n && n[1]), i.setVisual("fromSymbolSize", o && o[0]), i.setVisual("toSymbolSize", o && o[1]), i.setVisual("color", t.get(a)), i.setVisual("opacity", t.get(r)), i.each((t) => { const n = i.getItemModel(t); const o = e.getEdgeByIndex(t); const s = mf(n.getShallow("symbol", !0)); const l = mf(n.getShallow("symbolSize", !0)); let u = n.get(a); const h = n.get(r); switch (u) { case "source": u = o.node1.getVisual("color"); break; case "target": u = o.node2.getVisual("color"); }s[0] && o.setVisual("fromSymbol", s[0]), s[1] && o.setVisual("toSymbol", s[1]), l[0] && o.setVisual("fromSymbolSize", l[0]), l[1] && o.setVisual("toSymbolSize", l[1]), o.setVisual("color", u), o.setVisual("opacity", h); }); }); }), Rs((t, e) => { t.eachSeriesByType("graph", (t) => { const e = t.get("layout"); const i = t.coordinateSystem; if (i && i.type !== "view") { const n = t.getData(); let o = []; d(i.dimensions, (t) => { o = o.concat(n.mapDimension(t, !0)); }); for (let a = 0; a < n.count(); a++) { for (var r = [], s = !1, l = 0; l < o.length; l++) { const u = n.get(o[l], a); isNaN(u) || (s = !0), r.push(u); }s ? n.setItemLayout(a, i.dataToPoint(r)) : n.setItemLayout(a, [NaN, NaN]); }yf(n.graph); } else e && e !== "none" || vf(t); }); }), Rs((t) => { t.eachSeriesByType("graph", (t) => { t.get("layout") === "circular" && xf(t); }); }), Rs((t) => {
    t.eachSeriesByType("graph", (t) => {
      let e = t.coordinateSystem; if (!e || e.type === "view") {
 if (t.get("layout") === "force") {
        const i = t.preservedPoints || {}; const n = t.getGraph(); const o = n.data; const a = n.edgeData; const r = t.getModel("force"); const s = r.get("initLayout"); t.preservedPoints ? o.each((t) => { const e = o.getId(t); o.setItemLayout(t, i[e] || [NaN, NaN]); }) : s && s !== "none" ? s === "circular" && xf(t) : vf(t); const l = o.getDataExtent("value"); const u = a.getDataExtent("value"); let h = r.get("repulsion"); let c = r.get("edgeLength"); y(h) || (h = [h, h]), y(c) || (c = [c, c]), c = [c[1], c[0]]; const d = o.mapArray("value", (t, e) => {
          const i = o.getItemLayout(e); let n = zo(t, l, h); return isNaN(n) && (n = (h[0] + h[1]) / 2), {
            w: n, rep: n, fixed: o.getItemModel(e).get("fixed"), p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i,
          };
        }); const f = a.mapArray("value", (t, e) => {
 const i = n.getEdgeByIndex(e); let o = zo(t, u, c); return isNaN(o) && (o = (c[0] + c[1]) / 2), {
          n1: d[i.node1.dataIndex], n2: d[i.node2.dataIndex], d: o, curveness: i.getModel().get("lineStyle.curveness") || 0, 
        }; 
}); const p = (e = t.coordinateSystem).getBoundingRect(); const g = _f(d, f, { rect: p, gravity: r.get("gravity") }); const m = g.step; g.step = function (t) { for (let e = 0, a = d.length; e < a; e++)d[e].fixed && G(d[e].p, n.getNodeByIndex(e).getLayout()); m((e, a, r) => { for (var s = 0, l = e.length; s < l; s++)e[s].fixed || n.getNodeByIndex(s).setLayout(e[s].p), i[o.getId(s)] = e[s].p; for (var s = 0, l = a.length; s < l; s++) { const u = a[s]; const h = n.getEdgeByIndex(s); const c = u.n1.p; const d = u.n2.p; let f = h.getLayout(); (f = f ? f.slice() : [])[0] = f[0] || [], f[1] = f[1] || [], G(f[0], c), G(f[1], d), +u.curveness && (f[2] = [(c[0] + d[0]) / 2 - (c[1] - d[1]) * u.curveness, (c[1] + d[1]) / 2 - (d[0] - c[0]) * u.curveness]), h.setLayout(f); }t && t(r); }); }, t.forceLayout = g, t.preservedPoints = i, g.step();
      } else t.forceLayout = null; 
}
    });
  }), Es("graphView", { create(t, e) { const i = []; return t.eachSeriesByType("graph", (t) => { const n = t.get("coordinateSystem"); if (!n || n === "view") { const o = t.getData(); let a = []; let r = []; dn(o.mapArray((t) => { const e = o.getItemModel(t); return [+e.get("x"), +e.get("y")]; }), a, r), r[0] - a[0] == 0 && (r[0] += 1, a[0] -= 1), r[1] - a[1] == 0 && (r[1] += 1, a[1] -= 1); const s = (r[0] - a[0]) / (r[1] - a[1]); const l = wf(t, e, s); isNaN(s) && (a = [l.x, l.y], r = [l.x + l.width, l.y + l.height]); const u = r[0] - a[0]; const h = r[1] - a[1]; const c = l.width; const d = l.height; const f = t.coordinateSystem = new Sc(); f.zoomLimit = t.get("scaleLimit"), f.setBoundingRect(a[0], a[1], u, h), f.setViewRect(l.x, l.y, c, d), f.setCenter(t.get("center")), f.setZoom(t.get("zoom")), i.push(f); } }), i; } }); qI.extend({
    type: "series.gauge",
    getInitialData(t, e) { let i = t.data || []; return y(i) || (i = [i]), t.data = i, aC(this, ["value"]); },
    defaultOption: {
      zlevel: 0,
      z: 2,
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: { show: !0, lineStyle: { color: [[0.2, "#91c7ae"], [0.8, "#63869e"], [1, "#c23531"]], width: 30 } },
      splitLine: { show: !0, length: 30, lineStyle: { color: "#eee", width: 2, type: "solid" } },
      axisTick: {
        show: !0, splitNumber: 5, length: 8, lineStyle: { color: "#eee", width: 1, type: "solid" },
      },
      axisLabel: { show: !0, distance: 5, color: "auto" },
      pointer: { show: !0, length: "80%", width: 8 },
      itemStyle: { color: "auto" },
      title: {
        show: !0, offsetCenter: [0, "-40%"], color: "#333", fontSize: 15,
      },
      detail: {
        show: !0, backgroundColor: "rgba(0,0,0,0)", borderWidth: 0, borderColor: "#ccc", width: 100, height: null, padding: [5, 10], offsetCenter: [0, "40%"], color: "auto", fontSize: 30,
      },
    },
  }); const YL = kn.extend({
    type: "echartsGaugePointer",
    shape: {
      angle: 0, width: 10, r: 10, x: 0, y: 0,
    },
    buildPath(t, e) { const i = Math.cos; const n = Math.sin; const o = e.r; const a = e.width; let r = e.angle; const s = e.x - i(r) * a * (a >= o / 3 ? 1 : 2); const l = e.y - n(r) * a * (a >= o / 3 ? 1 : 2); r = e.angle - Math.PI / 2, t.moveTo(s, l), t.lineTo(e.x + i(r) * a, e.y + n(r) * a), t.lineTo(e.x + i(e.angle) * o, e.y + n(e.angle) * o), t.lineTo(e.x - i(r) * a, e.y - n(r) * a), t.lineTo(s, l); },
  }); const qL = 2 * Math.PI; var KL = (Tr.extend({
    type: "gauge",
    render(t, e, i) { this.group.removeAll(); const n = t.get("axisLine.lineStyle.color"); const o = bf(t, i); this._renderMain(t, e, i, n, o); },
    dispose() {},
    _renderMain(t, e, i, n, o) {
      for (var a = this.group, r = t.getModel("axisLine").getModel("lineStyle"), s = t.get("clockwise"), l = -t.get("startAngle") / 180 * Math.PI, u = -t.get("endAngle") / 180 * Math.PI, h = (u - l) % qL, c = l, d = r.get("width"), f = 0; f < n.length; f++) {
        const p = Math.min(Math.max(n[f][0], 0), 1); const g = new hM({
          shape: {
            startAngle: c, endAngle: u = l + h * p, cx: o.cx, cy: o.cy, clockwise: s, r0: o.r - d, r: o.r,
          },
          silent: !0,
        }); g.setStyle({ fill: n[f][1] }), g.setStyle(r.getLineStyle(["color", "borderWidth", "borderColor"])), a.add(g), c = u;
      } const m = function (t) { if (t <= 0) return n[0][1]; for (var e = 0; e < n.length; e++) if (n[e][0] >= t && (e === 0 ? 0 : n[e - 1][0]) < t) return n[e][1]; return n[e - 1][1]; }; if (!s) { const v = l; l = u, u = v; } this._renderTicks(t, e, i, m, o, l, u, s), this._renderPointer(t, e, i, m, o, l, u, s), this._renderTitle(t, e, i, m, o), this._renderDetail(t, e, i, m, o);
    },
    _renderTicks(t, e, i, n, o, a, r, s) {
      for (let l = this.group, u = o.cx, h = o.cy, c = o.r, d = +t.get("min"), f = +t.get("max"), p = t.getModel("splitLine"), g = t.getModel("axisTick"), m = t.getModel("axisLabel"), v = t.get("splitNumber"), y = g.get("splitNumber"), x = Bo(p.get("length"), c), _ = Bo(g.get("length"), c), w = a, b = (r - a) / v, S = b / y, M = p.getModel("lineStyle").getLineStyle(), I = g.getModel("lineStyle").getLineStyle(), T = 0; T <= v; T++) {
        var A = Math.cos(w); var D = Math.sin(w); if (p.get("show")) {
          const C = new _M({
            shape: {
              x1: A * c + u, y1: D * c + h, x2: A * (c - x) + u, y2: D * (c - x) + h,
            },
            style: M,
            silent: !0,
          }); M.stroke === "auto" && C.setStyle({ stroke: n(T / v) }), l.add(C);
        } if (m.get("show")) {
          const L = Sf(Vo(T / v * (f - d) + d), m.get("formatter")); const k = m.get("distance"); const P = n(T / v); l.add(new rM({
            style: go({}, m, {
              text: L, x: A * (c - x - k) + u, y: D * (c - x - k) + h, textVerticalAlign: D < -0.4 ? "top" : D > 0.4 ? "bottom" : "middle", textAlign: A < -0.4 ? "left" : A > 0.4 ? "right" : "center",
            }, { autoColor: P }),
            silent: !0,
          }));
        } if (g.get("show") && T !== v) {
          for (let N = 0; N <= y; N++) {
            var A = Math.cos(w); var D = Math.sin(w); const O = new _M({
              shape: {
                x1: A * c + u, y1: D * c + h, x2: A * (c - _) + u, y2: D * (c - _) + h,
              },
              silent: !0,
              style: I,
            }); I.stroke === "auto" && O.setStyle({ stroke: n((T + N / y) / v) }), l.add(O), w += S;
          }w -= S;
        } else w += b;
      }
    },
    _renderPointer(t, e, i, n, o, a, r, s) {
      const l = this.group; const u = this._data; if (t.get("pointer.show")) {
        const h = [+t.get("min"), +t.get("max")]; const c = [a, r]; const d = t.getData(); const f = d.mapDimension("value"); d.diff(u).add((e) => { const i = new YL({ shape: { angle: a } }); Io(i, { shape: { angle: zo(d.get(f, e), h, c, !0) } }, t), l.add(i), d.setItemGraphicEl(e, i); }).update((e, i) => { const n = u.getItemGraphicEl(i); Mo(n, { shape: { angle: zo(d.get(f, e), h, c, !0) } }, t), l.add(n), d.setItemGraphicEl(e, n); }).remove((t) => { const e = u.getItemGraphicEl(t); l.remove(e); })
          .execute(), d.eachItemGraphicEl((t, e) => {
          const i = d.getItemModel(e); const a = i.getModel("pointer"); t.setShape({
            x: o.cx, y: o.cy, width: Bo(a.get("width"), o.r), r: Bo(a.get("length"), o.r),
          }), t.useStyle(i.getModel("itemStyle").getItemStyle()), t.style.fill === "auto" && t.setStyle("fill", n(zo(d.get(f, e), h, [0, 1], !0))), co(t, i.getModel("emphasis.itemStyle").getItemStyle());
        }), this._data = d;
      } else u && u.eachItemGraphicEl((t) => { l.remove(t); });
    },
    _renderTitle(t, e, i, n, o) {
      const a = t.getData(); const r = a.mapDimension("value"); const s = t.getModel("title"); if (s.get("show")) {
        const l = s.get("offsetCenter"); const u = o.cx + Bo(l[0], o.r); const h = o.cy + Bo(l[1], o.r); const c = +t.get("min"); const d = +t.get("max"); const f = n(zo(t.getData().get(r, 0), [c, d], [0, 1], !0)); this.group.add(new rM({
          silent: !0,
          style: go({}, s, {
            x: u, y: h, text: a.getName(0), textAlign: "center", textVerticalAlign: "middle",
          }, { autoColor: f, forceRich: !0 }),
        }));
      }
    },
    _renderDetail(t, e, i, n, o) {
      const a = t.getModel("detail"); const r = +t.get("min"); const s = +t.get("max"); if (a.get("show")) {
        const l = a.get("offsetCenter"); const u = o.cx + Bo(l[0], o.r); const h = o.cy + Bo(l[1], o.r); const c = Bo(a.get("width"), o.r); const d = Bo(a.get("height"), o.r); const f = t.getData(); const p = f.get(f.mapDimension("value"), 0); const g = n(zo(p, [r, s], [0, 1], !0)); this.group.add(new rM({
          silent: !0,
          style: go({}, a, {
            x: u, y: h, text: Sf(p, a.get("formatter")), textWidth: isNaN(c) ? null : c, textHeight: isNaN(d) ? null : d, textAlign: "center", textVerticalAlign: "middle",
          }, { autoColor: g, forceRich: !0 }),
        }));
      }
    },
  }), Ws({
    type: "series.funnel",
    init(t) { KL.superApply(this, "init", arguments), this.legendDataProvider = function () { return this.getRawData(); }, this._defaultLabelLine(t); },
    getInitialData(t, e) { return aC(this, ["value"]); },
    _defaultLabelLine(t) { Ci(t, "labelLine", ["show"]); const e = t.labelLine; const i = t.emphasis.labelLine; e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show; },
    getDataParams(t) { const e = this.getData(); const i = KL.superCall(this, "getDataParams", t); const n = e.mapDimension("value"); const o = e.getSum(n); return i.percent = o ? +(e.get(n, t) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i; },
    defaultOption: {
      zlevel: 0, z: 2, legendHoverLink: !0, left: 80, top: 60, right: 80, bottom: 60, minSize: "0%", maxSize: "100%", sort: "descending", gap: 0, funnelAlign: "center", label: { show: !0, position: "outer" }, labelLine: { show: !0, length: 20, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderColor: "#fff", borderWidth: 1 }, emphasis: { label: { show: !0 } },
    },
  })); const $L = Mf.prototype; const JL = ["itemStyle", "opacity"]; $L.updateData = function (t, e, i) { const n = this.childAt(0); const o = t.hostModel; const a = t.getItemModel(e); const s = t.getItemLayout(e); let l = t.getItemModel(e).get(JL); l = l == null ? 1 : l, n.useStyle({}), i ? (n.setShape({ points: s.points }), n.setStyle({ opacity: 0 }), Io(n, { style: { opacity: l } }, o, e)) : Mo(n, { style: { opacity: l }, shape: { points: s.points } }, o, e); const u = a.getModel("itemStyle"); const h = t.getItemVisual(e, "color"); n.setStyle(r({ lineJoin: "round", fill: h }, u.getItemStyle(["opacity"]))), n.hoverStyle = u.getModel("emphasis").getItemStyle(), this._updateLabel(t, e), co(this); }, $L._updateLabel = function (t, e) {
    const i = this.childAt(1); const n = this.childAt(2); const o = t.hostModel; const a = t.getItemModel(e); const r = t.getItemLayout(e).label; var s = t.getItemVisual(e, "color"); Mo(i, { shape: { points: r.linePoints || r.linePoints } }, o, e), Mo(n, { style: { x: r.x, y: r.y } }, o, e), n.attr({ rotation: r.rotation, origin: [r.x, r.y], z2: 10 }); const l = a.getModel("label"); const u = a.getModel("emphasis.label"); const h = a.getModel("labelLine"); const c = a.getModel("emphasis.labelLine"); var s = t.getItemVisual(e, "color"); po(n.style, n.hoverStyle = {}, l, u, {
      labelFetcher: t.hostModel, labelDataIndex: e, defaultText: t.getName(e), autoColor: s, useInsideStyle: !!r.inside,
    }, { textAlign: r.textAlign, textVerticalAlign: r.verticalAlign }), n.ignore = n.normalIgnore = !l.get("show"), n.hoverIgnore = !u.get("show"), i.ignore = i.normalIgnore = !h.get("show"), i.hoverIgnore = !c.get("show"), i.setStyle({ stroke: s }), i.setStyle(h.getModel("lineStyle").getLineStyle()), i.hoverStyle = c.getModel("lineStyle").getLineStyle();
  }, u(Mf, tb); Tr.extend({
    type: "funnel",
    render(t, e, i) {
      const n = t.getData(); const o = this._data; const a = this.group; n.diff(o).add((t) => { const e = new Mf(n, t); n.setItemGraphicEl(t, e), a.add(e); }).update((t, e) => { const i = o.getItemGraphicEl(e); i.updateData(n, t), a.add(i), n.setItemGraphicEl(t, i); }).remove((t) => { const e = o.getItemGraphicEl(t); a.remove(e); })
        .execute(), this._data = n;
    },
    remove() { this.group.removeAll(), this._data = null; },
    dispose() {},
  }); zs(hC("funnel")), Rs((t, e, i) => { t.eachSeriesByType("funnel", (t) => { const i = t.getData(); const n = i.mapDimension("value"); const o = t.get("sort"); const a = If(t, e); let r = Tf(i, o); const s = [Bo(t.get("minSize"), a.width), Bo(t.get("maxSize"), a.width)]; const l = i.getDataExtent(n); let u = t.get("min"); let h = t.get("max"); u == null && (u = Math.min(l[0], 0)), h == null && (h = l[1]); const c = t.get("funnelAlign"); let d = t.get("gap"); let f = (a.height - d * (i.count() - 1)) / i.count(); let p = a.y; const g = function (t, e) { let o; const r = zo(i.get(n, t) || 0, [u, h], s, !0); switch (c) { case "left": o = a.x; break; case "center": o = a.x + (a.width - r) / 2; break; case "right": o = a.x + a.width - r; } return [[o, e], [o + r, e]]; }; o === "ascending" && (f = -f, d = -d, p += a.height, r = r.reverse()); for (let m = 0; m < r.length; m++) { const v = r[m]; const y = r[m + 1]; let x = i.getItemModel(v).get("itemStyle.height"); x == null ? x = f : (x = Bo(x, a.height), o === "ascending" && (x = -x)); const _ = g(v, p); const w = g(y, p + x); p += x + d, i.setItemLayout(v, { points: _.concat(w.slice().reverse()) }); }Af(i); }); }), Ns(pC("funnel")); const QL = function (t, e, i, n, o) { rD.call(this, t, e, i), this.type = n || "value", this.axisIndex = o; }; QL.prototype = { constructor: QL, model: null, isHorizontal() { return this.coordinateSystem.getModel().get("layout") !== "horizontal"; } }, u(QL, rD); var tk = function (t, e, i, n, o, a) { e[0] = kf(e[0], i), e[1] = kf(e[1], i), t = t || 0; const r = i[1] - i[0]; o != null && (o = kf(o, [0, r])), a != null && (a = Math.max(a, o != null ? o : 0)), n === "all" && (o = a = Math.abs(e[1] - e[0]), n = 0); const s = Lf(e, n); e[n] += t; const l = o || 0; const u = i.slice(); s.sign < 0 ? u[0] += l : u[1] -= l, e[n] = kf(e[n], u); h = Lf(e, n); o != null && (h.sign !== s.sign || h.span < o) && (e[1 - n] = e[n] + s.sign * o); var h = Lf(e, n); return a != null && h.span > a && (e[1 - n] = e[n] + h.sign * a), e; }; const ek = d; var ik = Math.min; var nk = Math.max; const ok = Math.floor; const ak = Math.ceil; const rk = Vo; const sk = Math.PI; Pf.prototype = {
    type: "parallel",
    constructor: Pf,
    _init(t, e, i) { const n = t.dimensions; const o = t.parallelAxisIndex; ek(n, function (t, i) { const n = o[i]; const a = e.getComponent("parallelAxis", n); const r = this._axesMap.set(t, new QL(t, Wl(a), [0, 0], a.get("type"), n)); const s = r.type === "category"; r.onBand = s && a.get("boundaryGap"), r.inverse = a.get("inverse"), a.axis = r, r.model = a, r.coordinateSystem = a.coordinateSystem = this; }, this); },
    update(t, e) { this._updateAxesFromSeries(this._model, t); },
    containPoint(t) { const e = this._makeLayoutInfo(); const i = e.axisBase; const n = e.layoutBase; const o = e.pixelDimIndex; const a = t[1 - o]; const r = t[o]; return a >= i && a <= i + e.axisLength && r >= n && r <= n + e.layoutLength; },
    getModel() { return this._model; },
    _updateAxesFromSeries(t, e) { e.eachSeries(function (i) { if (t.contains(i, e)) { const n = i.getData(); ek(this.dimensions, function (t) { const e = this._axesMap.get(t); e.scale.unionExtentFromData(n, n.mapDimension(t)), Fl(e.scale, e.model); }, this); } }, this); },
    resize(t, e) { this._rect = ha(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), this._layoutAxes(); },
    getRect() { return this._rect; },
    _makeLayoutInfo() {
      let t; const e = this._model; const i = this._rect; const n = ["x", "y"]; const o = ["width", "height"]; const a = e.get("layout"); const r = a === "horizontal" ? 0 : 1; const s = i[o[r]]; const l = [0, s]; const u = this.dimensions.length; const h = Nf(e.get("axisExpandWidth"), l); const c = Nf(e.get("axisExpandCount") || 0, [0, u]); const d = e.get("axisExpandable") && u > 3 && u > c && c > 1 && h > 0 && s > 0; let f = e.get("axisExpandWindow"); f ? (t = Nf(f[1] - f[0], l), f[1] = f[0] + t) : (t = Nf(h * (c - 1), l), (f = [h * (e.get("axisExpandCenter") || ok(u / 2)) - t / 2])[1] = f[0] + t); let p = (s - t) / (u - c); p < 3 && (p = 0); const g = [ok(rk(f[0] / h, 1)) + 1, ak(rk(f[1] / h, 1)) - 1]; const m = p / h * f[0]; return {
        layout: a, pixelDimIndex: r, layoutBase: i[n[r]], layoutLength: s, axisBase: i[n[1 - r]], axisLength: i[o[1 - r]], axisExpandable: d, axisExpandWidth: h, axisCollapseWidth: p, axisExpandWindow: f, axisCount: u, winInnerIndices: g, axisExpandWindow0Pos: m,
      };
    },
    _layoutAxes() {
      const t = this._rect; const e = this._axesMap; const i = this.dimensions; const n = this._makeLayoutInfo(); const o = n.layout; e.each((t) => { const e = [0, n.axisLength]; const i = t.inverse ? 1 : 0; t.setExtent(e[i], e[1 - i]); }), ek(i, function (e, i) {
        const a = (n.axisExpandable ? Ef : Of)(i, n); const r = { horizontal: { x: a.position, y: n.axisLength }, vertical: { x: 0, y: a.position } }; const s = { horizontal: sk / 2, vertical: 0 }; const l = [r[o].x + t.x, r[o].y + t.y]; const u = s[o]; const h = xt(); Mt(h, h, u), St(h, h, l), this._axesLayout[e] = {
          position: l, rotation: u, transform: h, axisNameAvailableWidth: a.axisNameAvailableWidth, axisLabelShow: a.axisLabelShow, nameTruncateMaxWidth: a.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1,
        };
      }, this);
    },
    getAxis(t) { return this._axesMap.get(t); },
    dataToPoint(t, e) { return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e); },
    eachActiveState(t, e, i, n) { i == null && (i = 0), n == null && (n = t.count()); const o = this._axesMap; const a = this.dimensions; const r = []; const s = []; d(a, (e) => { r.push(t.mapDimension(e)), s.push(o.get(e).model); }); for (let l = this.hasAxisBrushed(), u = i; u < n; u++) { var h; if (l) { h = "active"; for (let c = t.getValues(r, u), f = 0, p = a.length; f < p; f++) if (s[f].getActiveState(c[f]) === "inactive") { h = "inactive"; break; } } else h = "normal"; e(h, u); } },
    hasAxisBrushed() { for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, o = t.length; n < o; n++)e.get(t[n]).model.getActiveState() !== "normal" && (i = !0); return i; },
    axisCoordToPoint(t, e) { return Ao([t, 0], this._axesLayout[e].transform); },
    getAxisLayout(t) { return i(this._axesLayout[t]); },
    getSlidedAxisExpandWindow(t) { const e = this._makeLayoutInfo(); const i = e.pixelDimIndex; let n = e.axisExpandWindow.slice(); let o = n[1] - n[0]; const a = [0, e.axisExpandWidth * (e.axisCount - 1)]; if (!this.containPoint(t)) return { behavior: "none", axisExpandWindow: n }; let r; const s = t[i] - e.layoutBase - e.axisExpandWindow0Pos; let l = "slide"; const u = e.axisCollapseWidth; const h = this._model.get("axisExpandSlideTriggerArea"); const c = h[0] != null; if (u)c && u && s < o * h[0] ? (l = "jump", r = s - o * h[2]) : c && u && s > o * (1 - h[0]) ? (l = "jump", r = s - o * (1 - h[2])) : (r = s - o * h[1]) >= 0 && (r = s - o * (1 - h[1])) <= 0 && (r = 0), (r *= e.axisExpandWidth / u) ? tk(r, n, a, "all") : l = "none"; else { o = n[1] - n[0]; (n = [nk(0, a[1] * s / o - o / 2)])[1] = ik(a[1], n[0] + o), n[0] = n[1] - o; } return { axisExpandWindow: n, behavior: l }; },
  }, Ga.register("parallel", { create(t, e) { const i = []; return t.eachComponent("parallel", (n, o) => { const a = new Pf(n, t, e); a.name = `parallel_${o}`, a.resize(n, e), n.coordinateSystem = a, a.model = n, i.push(a); }), t.eachSeries((e) => { if (e.get("coordinateSystem") === "parallel") { const i = t.queryComponents({ mainType: "parallel", index: e.get("parallelIndex"), id: e.get("parallelId") })[0]; e.coordinateSystem = i.coordinateSystem; } }), i; } }); const lk = uI.extend({
    type: "baseParallelAxis", axis: null, activeIntervals: [], getAreaSelectStyle() { return Qb([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle")); }, setActiveIntervals(t) { const e = this.activeIntervals = i(t); if (e) for (let n = e.length - 1; n >= 0; n--)Go(e[n]); }, getActiveState(t) { const e = this.activeIntervals; if (!e.length) return "normal"; if (t == null || isNaN(t)) return "inactive"; if (e.length === 1) { const i = e[0]; if (i[0] <= t && t <= i[1]) return "active"; } else for (let n = 0, o = e.length; n < o; n++) if (e[n][0] <= t && t <= e[n][1]) return "active"; return "inactive"; },
  }); const uk = {
    type: "value",
    dim: null,
    areaSelectStyle: {
      width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: 0.3,
    },
    realtime: !0,
    z: 10,
  }; n(lk.prototype, XA), RD("parallel", lk, (t, e) => e.type || (e.data ? "category" : "value"), uk), uI.extend({
    type: "parallel",
    dependencies: ["parallelAxis"],
    coordinateSystem: null,
    dimensions: null,
    parallelAxisIndex: null,
    layoutMode: "box",
    defaultOption: {
      zlevel: 0, z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: "horizontal", axisExpandable: !1, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4], axisExpandTriggerOn: "click", parallelAxisDefault: null,
    },
    init() { uI.prototype.init.apply(this, arguments), this.mergeOption({}); },
    mergeOption(t) { const e = this.option; t && n(e, t, !0), this._initDimensions(); },
    contains(t, e) { const i = t.get("parallelIndex"); return i != null && e.getComponent("parallel", i) === this; },
    setAxisExpand(t) { d(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function (e) { t.hasOwnProperty(e) && (this.option[e] = t[e]); }, this); },
    _initDimensions() { const t = this.dimensions = []; const e = this.parallelAxisIndex = []; d(g(this.dependentModels.parallelAxis, function (t) { return (t.get("parallelIndex") || 0) === this.componentIndex; }, this), (i) => { t.push(`dim${i.get("dim")}`), e.push(i.componentIndex); }); },
  }), Os({ type: "axisAreaSelect", event: "axisAreaSelected" }, (t, e) => { e.eachComponent({ mainType: "parallelAxis", query: t }, (e) => { e.axis.model.setActiveIntervals(t.intervals); }); }), Os("parallelAxisExpand", (t, e) => { e.eachComponent({ mainType: "parallel", query: t }, (e) => { e.setAxisExpand(t); }); }); var hk = v; var ck = d; var dk = f; var fk = Math.min; var pk = Math.max; var gk = Math.pow; var mk = 1e4; var vk = 6; var yk = 6; var xk = "globalPan"; var _k = {
    w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1],
  }; var wk = {
    w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse",
  }; var bk = {
    brushStyle: { lineWidth: 2, stroke: "rgba(0,0,0,0.3)", fill: "rgba(0,0,0,0.1)" }, transformable: !0, brushMode: "single", removeOnClick: !1,
  }; var Sk = 0; Rf.prototype = {
    constructor: Rf,
    enableBrush(t) { return this._brushType && Bf(this), t.brushType && zf(this, t), this; },
    setPanels(t) { if (t && t.length) { const e = this._panels = {}; d(t, (t) => { e[t.panelId] = i(t); }); } else this._panels = null; return this; },
    mount(t) { t = t || {}, this._enableGlobalPan = t.enableGlobalPan; const e = this.group; return this._zr.add(e), e.attr({ position: t.position || [0, 0], rotation: t.rotation || 0, scale: t.scale || [1, 1] }), this._transform = e.getLocalTransform(), this; },
    eachCover(t, e) { ck(this._covers, t, e); },
    updateCovers(t) {
      function e(t, e) { return `${t.id != null ? t.id : a + e}-${t.brushType}`; } function o(e, i) { const n = t[e]; if (i != null && r[i] === u)s[e] = r[i]; else { const o = s[e] = i != null ? (r[i].__brushOption = n, r[i]) : Gf(l, Vf(l, n)); Hf(l, o); } }t = f(t, t => n(i(bk), t, !0)); var a = "\0-brush-index-"; var r = this._covers; var s = this._covers = []; var l = this; var u = this._creatingCover; return new Us(r, t, ((t, i) => e(t.__brushOption, i)), e).add(o).update(o).remove((t) => { r[t] !== u && l.group.remove(r[t]); })
        .execute(), this;
    },
    unmount() { return this.enableBrush(!1), jf(this), this._zr.remove(this.group), this; },
    dispose() { this.unmount(), this.off(); },
  }, h(Rf, fw); var Mk = { mousedown(t) { if (this._dragging)gp.call(this, t); else if (!t.target || !t.target.draggable) { cp(t); const e = this.group.transformCoordToLocal(t.offsetX, t.offsetY); this._creatingCover = null, (this._creatingPanel = Uf(this, t, e)) && (this._dragging = !0, this._track = [e.slice()]); } }, mousemove(t) { const e = this.group.transformCoordToLocal(t.offsetX, t.offsetY); if (hp(this, t, e), this._dragging) { cp(t); const i = fp(this, t, e, !1); i && Yf(this, i); } }, mouseup: gp }; var Ik = {
    lineX: mp(0),
    lineY: mp(1),
    rect: {
      createCover(t, e) { return $f(hk(ap, t => t, t => t), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]); }, getCreatingRange(t) { const e = Kf(t); return ip(e[1][0], e[1][1], e[0][0], e[0][1]); }, updateCoverShape(t, e, i, n) { Jf(t, e, i, n); }, updateCommon: Qf, contain: dp,
    },
    polygon: {
      createCover(t, e) { const i = new tb(); return i.add(new gM({ name: "main", style: ep(e), silent: !0 })), i; },
      getCreatingRange(t) { return t; },
      endCreating(t, e) {
        e.remove(e.childAt(0)), e.add(new pM({
          name: "main", draggable: !0, drift: hk(rp, t, e), ondragend: hk(Yf, t, { isEnd: !0 }),
        }));
      },
      updateCoverShape(t, e, i, n) { e.childAt(0).setShape({ points: lp(t, e, i) }); },
      updateCommon: Qf,
      contain: dp,
    },
  }; const Tk = ["axisLine", "axisTickLabel", "axisName"]; var Ak = Fs({
    type: "parallelAxis",
    init(t, e) { Ak.superApply(this, "init", arguments), (this._brushController = new Rf(e.getZr())).on("brush", m(this._onBrush, this)); },
    render(t, e, i, n) { if (!wp(t, e, n)) { this.axisModel = t, this.api = i, this.group.removeAll(); const o = this._axisGroup; if (this._axisGroup = new tb(), this.group.add(this._axisGroup), t.get("show")) { const r = Sp(t, e); const s = r.coordinateSystem; const l = t.getAreaSelectStyle(); const u = l.width; const h = t.axis.dim; const c = a({ strokeContainThreshold: u }, s.getAxisLayout(h)); const f = new WD(t, c); d(Tk, f.add, f), this._axisGroup.add(f.getGroup()), this._refreshBrushController(c, l, t, r, u, i); const p = n && !1 === n.animation ? null : t; Co(o, this._axisGroup, p); } } },
    _refreshBrushController(t, e, i, n, o, a) {
      const r = i.axis.getExtent(); const s = r[1] - r[0]; const l = Math.min(30, 0.1 * Math.abs(s)); const u = de.create({
        x: r[0], y: -o / 2, width: s, height: o,
      }); u.x -= l, u.width += 2 * l, this._brushController.mount({ enableGlobalPan: !0, rotation: t.rotation, position: t.position }).setPanels([{
        panelId: "pl", clipPath: vp(u), isTargetByCursor: xp(u, a, n), getLinearBrushOtherExtent: yp(u, 0),
      }]).enableBrush({ brushType: "lineX", brushStyle: e, removeOnClick: !0 }).updateCovers(bp(i));
    },
    _onBrush(t, e) { const i = this.axisModel; const n = i.axis; const o = f(t, t => [n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0)]); (!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "axisAreaSelect", parallelAxisId: i.id, intervals: o }); },
    dispose() { this._brushController.dispose(); },
  }); Fs({
    type: "parallel", render(t, e, i) { this._model = t, this._api = i, this._handlers || (this._handlers = {}, d(Dk, function (t, e) { i.getZr().on(e, this._handlers[e] = m(t, this)); }, this)), Pr(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate"); }, dispose(t, e) { d(this._handlers, (t, i) => { e.getZr().off(i, t); }), this._handlers = null; }, _throttledDispatchExpand(t) { this._dispatchExpand(t); }, _dispatchExpand(t) { t && this._api.dispatchAction(a({ type: "parallelAxisExpand" }, t)); },
  }); var Dk = { mousedown(t) { Mp(this, "click") && (this._mouseDownPoint = [t.offsetX, t.offsetY]); }, mouseup(t) { const e = this._mouseDownPoint; if (Mp(this, "click") && e) { const i = [t.offsetX, t.offsetY]; if (Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2) > 5) return; const n = this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]); n.behavior !== "none" && this._dispatchExpand({ axisExpandWindow: n.axisExpandWindow }); } this._mouseDownPoint = null; }, mousemove(t) { if (!this._mouseDownPoint && Mp(this, "mousemove")) { const e = this._model; const i = e.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]); const n = i.behavior; n === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(n === "none" ? null : { axisExpandWindow: i.axisExpandWindow, animation: n === "jump" && null }); } } }; Ps((t) => { Df(t), Cf(t); }), qI.extend({
    type: "series.parallel",
    dependencies: ["parallel"],
    visualColorAccessPath: "lineStyle.color",
    getInitialData(t, e) { const i = this.getSource(); return Ip(i, this), gl(i, this); },
    getRawIndicesByActiveState(t) { const e = this.coordinateSystem; const i = this.getData(); const n = []; return e.eachActiveState(i, (e, o) => { t === e && n.push(i.getRawIndex(o)); }), n; },
    defaultOption: {
      zlevel: 0, z: 2, coordinateSystem: "parallel", parallelIndex: 0, label: { show: !1 }, inactiveOpacity: 0.05, activeOpacity: 1, lineStyle: { width: 1, opacity: 0.45, type: "solid" }, emphasis: { label: { show: !1 } }, progressive: 500, smooth: !1, animationEasing: "linear",
    },
  }); var Ck = 0.3; const Lk = (Tr.extend({
    type: "parallel",
    init() { this._dataGroup = new tb(), this.group.add(this._dataGroup), this._data, this._initialized; },
    render(t, e, i, n) {
      const o = this._dataGroup; const a = t.getData(); const r = this._data; const s = t.coordinateSystem; const l = s.dimensions; const u = Lp(t); if (a.diff(r).add((t) => { kp(Cp(a, o, t, l, s), a, t, u); }).update((e, i) => { const o = r.getItemGraphicEl(i); const h = Dp(a, e, l, s); a.setItemGraphicEl(e, o), Mo(o, { shape: { points: h } }, n && !1 === n.animation ? null : t, e), kp(o, a, e, u); }).remove((t) => { const e = r.getItemGraphicEl(t); o.remove(e); })
        .execute(), !this._initialized) { this._initialized = !0; const h = Ap(s, t, () => { setTimeout(() => { o.removeClipPath(); }); }); o.setClipPath(h); } this._data = a;
    },
    incrementalPrepareRender(t, e, i) { this._initialized = !0, this._data = null, this._dataGroup.removeAll(); },
    incrementalRender(t, e, i) { for (let n = e.getData(), o = e.coordinateSystem, a = o.dimensions, r = Lp(e), s = t.start; s < t.end; s++) { const l = Cp(n, this._dataGroup, s, a, o); l.incremental = !0, kp(l, n, s, r); } },
    dispose() {},
    remove() { this._dataGroup && this._dataGroup.removeAll(), this._data = null; },
  }), ["lineStyle", "normal", "opacity"]); zs({ seriesType: "parallel", reset(t, e, i) { const n = t.getModel("itemStyle"); const o = t.getModel("lineStyle"); const a = e.get("color"); const r = o.get("color") || n.get("color") || a[t.seriesIndex % a.length]; const s = t.get("inactiveOpacity"); const l = t.get("activeOpacity"); const u = t.getModel("lineStyle").getLineStyle(); const h = t.coordinateSystem; const c = t.getData(); const d = { normal: u.opacity, active: l, inactive: s }; return c.setVisual("color", r), { progress(t, e) { h.eachActiveState(e, (t, i) => { let n = d[t]; if (t === "normal" && e.hasItemOption) { const o = e.getItemModel(i).get(Lk, !0); o != null && (n = o); }e.setItemVisual(i, "opacity", n); }, t.start, t.end); } }; } }); var kk = qI.extend({
    type: "series.sankey",
    layoutInfo: null,
    getInitialData(t) { const e = t.edges || t.links; const i = t.data || t.nodes; if (i && e) return CL(i, e, this, !0).data; },
    setNodePosition(t, e) { const i = this.option.data[t]; i.localX = e[0], i.localY = e[1]; },
    getGraph() { return this.getData().graph; },
    getEdgeData() { return this.getGraph().edgeData; },
    formatTooltip(t, e, i) { if (i === "edge") { const n = this.getDataParams(t, i); const o = n.data; let a = `${o.source} -- ${o.target}`; return n.value && (a += ` : ${n.value}`), ea(a); } return kk.superCall(this, "formatTooltip", t, e); },
    optionUpdated() { const t = this.option; !0 === t.focusNodeAdjacency && (t.focusNodeAdjacency = "allEdges"); },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      layout: null,
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      focusNodeAdjacency: !1,
      layoutIterations: 32,
      label: {
        show: !0, position: "right", color: "#000", fontSize: 12,
      },
      itemStyle: { borderWidth: 1, borderColor: "#333" },
      lineStyle: { color: "#314656", opacity: 0.2, curveness: 0.5 },
      emphasis: { label: { show: !0 }, lineStyle: { opacity: 0.6 } },
      animationEasing: "linear",
      animationDuration: 1e3,
    },
  }); const Pk = ["itemStyle", "opacity"]; const Nk = ["lineStyle", "opacity"]; const Ok = Zn({
    shape: {
      x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, cpx2: 0, cpy2: 0, extent: 0, orient: "",
    },
    buildPath(t, e) { const i = e.extent; e.orient === "vertical" ? (t.moveTo(e.x1, e.y1), t.bezierCurveTo(e.cpx1, e.cpy1, e.cpx2, e.cpy2, e.x2, e.y2), t.lineTo(e.x2 + i, e.y2), t.bezierCurveTo(e.cpx2 + i, e.cpy2, e.cpx1 + i, e.cpy1, e.x1 + i, e.y1)) : (t.moveTo(e.x1, e.y1), t.bezierCurveTo(e.cpx1, e.cpy1, e.cpx2, e.cpy2, e.x2, e.y2), t.lineTo(e.x2, e.y2 + i), t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i)), t.closePath(); },
  }); Hs({
    type: "sankey",
    _model: null,
    _focusAdjacencyDisabled: !1,
    render(t, e, i) {
      const n = this; const o = t.getGraph(); const a = this.group; const r = t.layoutInfo; const s = r.width; const l = r.height; const u = t.getData(); const h = t.getData("edge"); const c = t.get("orient"); this._model = t, a.removeAll(), a.attr("position", [r.x, r.y]), o.eachEdge((e) => {
        const i = new Ok(); i.dataIndex = e.dataIndex, i.seriesIndex = t.seriesIndex, i.dataType = "edge"; let n; let o; let r; let u; let d; let f; let p; let g; const m = e.getModel("lineStyle"); const v = m.get("curveness"); const y = e.node1.getLayout(); const x = e.node1.getModel(); const _ = x.get("localX"); const w = x.get("localY"); const b = e.node2.getLayout(); const S = e.node2.getModel(); const M = S.get("localX"); const I = S.get("localY"); const T = e.getLayout(); switch (i.shape.extent = Math.max(1, T.dy), i.shape.orient = c, c === "vertical" ? (n = (_ != null ? _ * s : y.x) + T.sy, o = (w != null ? w * l : y.y) + y.dy, r = (M != null ? M * s : b.x) + T.ty, d = n, f = o * (1 - v) + (u = I != null ? I * l : b.y) * v, p = r, g = o * v + u * (1 - v)) : (n = (_ != null ? _ * s : y.x) + y.dx, o = (w != null ? w * l : y.y) + T.sy, d = n * (1 - v) + (r = M != null ? M * s : b.x) * v, f = o, p = n * v + r * (1 - v), g = u = (I != null ? I * l : b.y) + T.ty), i.setShape({
          x1: n, y1: o, x2: r, y2: u, cpx1: d, cpy1: f, cpx2: p, cpy2: g,
        }), i.setStyle(m.getItemStyle()), i.style.fill) { case "source": i.style.fill = e.node1.getVisual("color"); break; case "target": i.style.fill = e.node2.getVisual("color"); }co(i, e.getModel("emphasis.lineStyle").getItemStyle()), a.add(i), h.setItemGraphicEl(e.dataIndex, i);
      }), o.eachNode((e) => {
        const i = e.getLayout(); const n = e.getModel(); const o = n.get("localX"); const r = n.get("localY"); const h = n.getModel("label"); const c = n.getModel("emphasis.label"); const d = new yM({
          shape: {
            x: o != null ? o * s : i.x, y: r != null ? r * l : i.y, width: i.dx, height: i.dy,
          },
          style: n.getModel("itemStyle").getItemStyle(),
        }); const f = e.getModel("emphasis.itemStyle").getItemStyle(); po(d.style, f, h, c, {
          labelFetcher: t, labelDataIndex: e.dataIndex, defaultText: e.id, isRectText: !0,
        }), d.setStyle("fill", e.getVisual("color")), co(d, f), a.add(d), u.setItemGraphicEl(e.dataIndex, d), d.dataType = "node";
      }), u.eachItemGraphicEl((e, o) => {
        const a = u.getItemModel(o); a.get("draggable") && (e.drift = function (e, a) {
          n._focusAdjacencyDisabled = !0, this.shape.x += e, this.shape.y += a, this.dirty(), i.dispatchAction({
            type: "dragNode", seriesId: t.id, dataIndex: u.getRawIndex(o), localX: this.shape.x / s, localY: this.shape.y / l,
          });
        }, e.ondragend = function () { n._focusAdjacencyDisabled = !1; }, e.draggable = !0, e.cursor = "move"), a.get("focusNodeAdjacency") && (e.off("mouseover").on("mouseover", () => { n._focusAdjacencyDisabled || i.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, dataIndex: e.dataIndex }); }), e.off("mouseout").on("mouseout", () => { n._focusAdjacencyDisabled || i.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: t.id }); }));
      }), h.eachItemGraphicEl((e, o) => { h.getItemModel(o).get("focusNodeAdjacency") && (e.off("mouseover").on("mouseover", () => { n._focusAdjacencyDisabled || i.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, edgeDataIndex: e.dataIndex }); }), e.off("mouseout").on("mouseout", () => { n._focusAdjacencyDisabled || i.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: t.id }); })); }), !this._data && t.get("animation") && a.setClipPath(Rp(a.getBoundingRect(), t, () => { a.removeClipPath(); })), this._data = t.getData();
    },
    dispose() {},
    focusNodeAdjacency(t, e, i, n) { const o = this._model.getData(); const a = o.graph; const r = n.dataIndex; const s = o.getItemModel(r); const l = n.edgeDataIndex; if (r != null || l != null) { const u = a.getNodeByIndex(r); const h = a.getEdgeByIndex(l); if (a.eachNode((t) => { Op(t, Pk, 0.1); }), a.eachEdge((t) => { Op(t, Nk, 0.1); }), u) { Ep(u, Pk); const c = s.get("focusNodeAdjacency"); c === "outEdges" ? d(u.outEdges, (t) => { t.dataIndex < 0 || (Ep(t, Nk), Ep(t.node2, Pk)); }) : c === "inEdges" ? d(u.inEdges, (t) => { t.dataIndex < 0 || (Ep(t, Nk), Ep(t.node1, Pk)); }) : c === "allEdges" && d(u.edges, (t) => { t.dataIndex < 0 || (Ep(t, Nk), Ep(t.node1, Pk), Ep(t.node2, Pk)); }); }h && (Ep(h, Nk), Ep(h.node1, Pk), Ep(h.node2, Pk)); } },
    unfocusNodeAdjacency(t, e, i, n) { const o = this._model.getGraph(); o.eachNode((t) => { Op(t, Pk); }), o.eachEdge((t) => { Op(t, Nk); }); },
  }), Os({ type: "dragNode", event: "dragNode", update: "update" }, (t, e) => { e.eachComponent({ mainType: "series", subType: "sankey", query: t }, (e) => { e.setNodePosition(t.dataIndex, [t.localX, t.localY]); }); }); Rs((t, e, i) => { t.eachSeriesByType("sankey", (t) => { const i = t.get("nodeWidth"); const n = t.get("nodeGap"); const o = Bp(t, e); t.layoutInfo = o; const a = o.width; const r = o.height; const s = t.getGraph(); const l = s.nodes; const u = s.edges; Gp(l), Vp(l, u, i, n, a, r, g(l, t => t.getLayout().value === 0).length !== 0 ? 0 : t.get("layoutIterations"), t.get("orient")); }); }), zs((t, e) => {
    t.eachSeriesByType("sankey", (t) => {
      const e = t.getGraph().nodes; if (e.length) {
        let i = 1 / 0; let n = -1 / 0; d(e, (t) => { const e = t.getLayout().value; e < i && (i = e), e > n && (n = e); }), d(e, (e) => {
          const o = new cL({
            type: "color", mappingMethod: "linear", dataExtent: [i, n], visual: t.get("color"),
          }).mapValueToVisual(e.getLayout().value); e.setVisual("color", o); const a = e.getModel().get("itemStyle.color"); a != null && e.setVisual("color", a);
        });
      }
    });
  }); const Ek = {
    _baseAxisDim: null,
    getInitialData(t, e) {
      let i; let n; const o = e.getComponent("xAxis", this.get("xAxisIndex")); const a = e.getComponent("yAxis", this.get("yAxisIndex")); const r = o.get("type"); const s = a.get("type"); r === "category" ? (t.layout = "horizontal", i = o.getOrdinalMeta(), n = !0) : s === "category" ? (t.layout = "vertical", i = a.getOrdinalMeta(), n = !0) : t.layout = t.layout || "horizontal"; const l = ["x", "y"]; const u = t.layout === "horizontal" ? 0 : 1; const h = this._baseAxisDim = l[u]; const c = l[1 - u]; const f = [o, a]; const p = f[u].get("type"); const g = f[1 - u].get("type"); const m = t.data; if (m && n) { const v = []; d(m, (t, e) => { let i; t.value && y(t.value) ? (i = t.value.slice(), t.value.unshift(e)) : y(t) ? (i = t.slice(), t.unshift(e)) : i = t, v.push(i); }), t.data = v; } const x = this.defaultValueDimensions; return aC(this, {
        coordDimensions: [{
          name: h, type: Ys(p), ordinalMeta: i, otherDims: { tooltip: !1, itemName: 0 }, dimsDef: ["base"],
        }, { name: c, type: Ys(g), dimsDef: x.slice() }],
        dimensionsCount: x.length + 1,
      });
    },
    getBaseAxis() { const t = this._baseAxisDim; return this.ecModel.getComponent(`${t}Axis`, this.get(`${t}AxisIndex`)).axis; },
  }; h(qI.extend({
    type: "series.boxplot",
    dependencies: ["xAxis", "yAxis", "grid"],
    defaultValueDimensions: [{ name: "min", defaultTooltip: !0 }, { name: "Q1", defaultTooltip: !0 }, { name: "median", defaultTooltip: !0 }, { name: "Q3", defaultTooltip: !0 }, { name: "max", defaultTooltip: !0 }],
    dimensions: null,
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      hoverAnimation: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: { color: "#fff", borderWidth: 1 },
      emphasis: {
        itemStyle: {
          borderWidth: 2, shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2, shadowColor: "rgba(0,0,0,0.4)",
        },
      },
      animationEasing: "elasticOut",
      animationDuration: 800,
    },
  }), Ek, !0); var Rk = ["itemStyle"]; var zk = ["emphasis", "itemStyle"]; var Bk = (Tr.extend({
    type: "boxplot",
    render(t, e, i) {
      const n = t.getData(); const o = this.group; const a = this._data; this._data || o.removeAll(); const r = t.get("layout") === "horizontal" ? 1 : 0; n.diff(a).add((t) => { if (n.hasValue(t)) { const e = ig(n.getItemLayout(t), n, t, r, !0); n.setItemGraphicEl(t, e), o.add(e); } }).update((t, e) => { let i = a.getItemGraphicEl(e); if (n.hasValue(t)) { const s = n.getItemLayout(t); i ? ng(s, i, n, t) : i = ig(s, n, t, r), o.add(i), n.setItemGraphicEl(t, i); } else o.remove(i); }).remove((t) => { const e = a.getItemGraphicEl(t); e && o.remove(e); })
        .execute(), this._data = n;
    },
    remove(t) { const e = this.group; const i = this._data; this._data = null, i && i.eachItemGraphicEl((t) => { t && e.remove(t); }); },
    dispose: B,
  }), kn.extend({ type: "boxplotBoxPath", shape: {}, buildPath(t, e) { const i = e.points; let n = 0; for (t.moveTo(i[n][0], i[n][1]), n++; n < 4; n++)t.lineTo(i[n][0], i[n][1]); for (t.closePath(); n < i.length; n++)t.moveTo(i[n][0], i[n][1]), n++, t.lineTo(i[n][0], i[n][1]); } })); const Vk = ["itemStyle", "borderColor"]; var Gk = d; zs((t, e) => { const i = t.get("color"); t.eachRawSeriesByType("boxplot", (e) => { const n = i[e.seriesIndex % i.length]; const o = e.getData(); o.setVisual({ legendSymbol: "roundRect", color: e.get(Vk) || n }), t.isSeriesFiltered(e) || o.each((t) => { const e = o.getItemModel(t); o.setItemVisual(t, { color: e.get(Vk, !0) }); }); }); }), Rs((t) => { const e = ag(t); Gk(e, (t) => { const e = t.seriesModels; e.length && (rg(t), Gk(e, (e, i) => { sg(e, t.boxOffsetList[i], t.boxWidthList[i]); })); }); }), h(qI.extend({
    type: "series.candlestick",
    dependencies: ["xAxis", "yAxis", "grid"],
    defaultValueDimensions: [{ name: "open", defaultTooltip: !0 }, { name: "close", defaultTooltip: !0 }, { name: "lowest", defaultTooltip: !0 }, { name: "highest", defaultTooltip: !0 }],
    dimensions: null,
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      hoverAnimation: !0,
      layout: null,
      itemStyle: {
        color: "#c23531", color0: "#314656", borderWidth: 1, borderColor: "#c23531", borderColor0: "#314656",
      },
      emphasis: { itemStyle: { borderWidth: 2 } },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationUpdate: !1,
      animationEasing: "linear",
      animationDuration: 300,
    },
    getShadowDim() { return "open"; },
    brushSelector(t, e, i) { const n = e.getItemLayout(t); return n && i.rect(n.brushRect); },
  }), Ek, !0); var Fk = ["itemStyle"]; var Wk = ["emphasis", "itemStyle"]; var Hk = ["color", "color0", "borderColor", "borderColor0"]; var Zk = (Tr.extend({
    type: "candlestick",
    render(t, e, i) { this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t); },
    incrementalPrepareRender(t, e, i) { this._clear(), this._updateDrawMode(t); },
    incrementalRender(t, e, i, n) { this._isLargeDraw ? this._incrementalRenderLarge(t, e) : this._incrementalRenderNormal(t, e); },
    _updateDrawMode(t) { const e = t.pipelineContext.large; (this._isLargeDraw == null || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear()); },
    _renderNormal(t) {
      const e = t.getData(); const i = this._data; const n = this.group; const o = e.getLayout("isSimpleBox"); this._data || n.removeAll(), e.diff(i).add((i) => { if (e.hasValue(i)) { let a; const r = e.getItemLayout(i); Io(a = lg(r, 0, !0), { shape: { points: r.ends } }, t, i), ug(a, e, i, o), n.add(a), e.setItemGraphicEl(i, a); } }).update((a, r) => { let s = i.getItemGraphicEl(r); if (e.hasValue(a)) { const l = e.getItemLayout(a); s ? Mo(s, { shape: { points: l.ends } }, t, a) : s = lg(l), ug(s, e, a, o), n.add(s), e.setItemGraphicEl(a, s); } else n.remove(s); }).remove((t) => { const e = i.getItemGraphicEl(t); e && n.remove(e); })
        .execute(), this._data = e;
    },
    _renderLarge(t) { this._clear(), cg(t, this.group); },
    _incrementalRenderNormal(t, e) { for (var i, n = e.getData(), o = n.getLayout("isSimpleBox"); (i = t.next()) != null;) { var a; ug(a = lg(n.getItemLayout(i)), n, i, o), a.incremental = !0, this.group.add(a); } },
    _incrementalRenderLarge(t, e) { cg(e, this.group, !0); },
    remove(t) { this._clear(); },
    _clear() { this.group.removeAll(), this._data = null; },
    dispose: B,
  }), kn.extend({ type: "normalCandlestickBox", shape: {}, buildPath(t, e) { const i = e.points; this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1])); } })); var Uk = kn.extend({ type: "largeCandlestickBox", shape: {}, buildPath(t, e) { for (let i = e.points, n = 0; n < i.length;) if (this.__sign === i[n++]) { const o = i[n++]; t.moveTo(o, i[n++]), t.lineTo(o, i[n++]); } else n += 3; } }); const Xk = ["itemStyle", "borderColor"]; const jk = ["itemStyle", "borderColor0"]; const Yk = ["itemStyle", "color"]; const qk = ["itemStyle", "color0"]; const Kk = {
    seriesType: "candlestick",
    plan: JI(),
    performRawSeries: !0,
    reset(t, e) {
      function i(t, e) { return e.get(t > 0 ? Yk : qk); } function n(t, e) { return e.get(t > 0 ? Xk : jk); } const o = t.getData(); const a = t.pipelineContext.large; if (o.setVisual({
        legendSymbol: "roundRect", colorP: i(1, t), colorN: i(-1, t), borderColorP: n(1, t), borderColorN: n(-1, t),
      }), !e.isSeriesFiltered(t)) return !a && { progress(t, e) { for (var o; (o = t.next()) != null;) { const a = e.getItemModel(o); const r = e.getItemLayout(o).sign; e.setItemVisual(o, { color: i(r, a), borderColor: n(r, a) }); } } };
    },
  }; const $k = typeof Float32Array !== "undefined" ? Float32Array : Array; const Jk = {
    seriesType: "candlestick",
    plan: JI(),
    reset(t) {
      const e = t.coordinateSystem; const i = t.getData(); const n = pg(t, i); const o = 0; const a = 1; const r = ["x", "y"]; const s = i.mapDimension(r[o]); const l = i.mapDimension(r[a], !0); const u = l[0]; const h = l[1]; const c = l[2]; const d = l[3]; if (i.setLayout({ candleWidth: n, isSimpleBox: n <= 1.3 }), !(s == null || l.length < 4)) {
        return {
          progress: t.pipelineContext.large ? function (t, i) { for (var n, r, l = new $k(5 * t.count), f = 0, p = [], g = []; (r = t.next()) != null;) { const m = i.get(s, r); const v = i.get(u, r); const y = i.get(h, r); const x = i.get(c, r); const _ = i.get(d, r); isNaN(m) || isNaN(x) || isNaN(_) ? (l[f++] = NaN, f += 4) : (l[f++] = fg(i, r, v, y, h), p[o] = m, p[a] = x, n = e.dataToPoint(p, null, g), l[f++] = n ? n[0] : NaN, l[f++] = n ? n[1] : NaN, p[a] = _, n = e.dataToPoint(p, null, g), l[f++] = n ? n[1] : NaN); }i.setLayout("largePoints", l); } : function (t, i) {
            function r(t, i) { const n = []; return n[o] = i, n[a] = t, isNaN(i) || isNaN(t) ? [NaN, NaN] : e.dataToPoint(n); } function l(t, e, i) { const a = e.slice(); const r = e.slice(); a[o] = $n(a[o] + n / 2, 1, !1), r[o] = $n(r[o] - n / 2, 1, !0), i ? t.push(a, r) : t.push(r, a); } function f(t) { return t[o] = $n(t[o], 1), t; } for (var p; (p = t.next()) != null;) {
              const g = i.get(s, p); const m = i.get(u, p); const v = i.get(h, p); const y = i.get(c, p); const x = i.get(d, p); const _ = Math.min(m, v); const w = Math.max(m, v); const b = r(_, g); const S = r(w, g); const M = r(y, g); const I = r(x, g); const T = []; l(T, S, 0), l(T, b, 1), T.push(f(I), f(S), f(M), f(b)), i.setItemLayout(p, {
                sign: fg(i, p, m, v, h),
                initBaseline: m > v ? S[a] : b[a],
                ends: T,
                brushRect: (function (t, e, i) {
                  const s = r(t, i); const l = r(e, i); return s[o] -= n / 2, l[o] -= n / 2, {
                    x: s[0], y: s[1], width: a ? n : l[0] - s[0], height: a ? l[1] - s[1] : n,
                  };
                }(y, x, g)),
              });
            }
          },
        };
      }
    },
  }; Ps((t) => { t && y(t.series) && d(t.series, (t) => { w(t) && t.type === "k" && (t.type = "candlestick"); }); }), zs(Kk), Rs(Jk), qI.extend({
    type: "series.effectScatter",
    dependencies: ["grid", "polar"],
    getInitialData(t, e) { return gl(this.getSource(), this); },
    brushSelector: "point",
    defaultOption: {
      coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, effectType: "ripple", progressive: 0, showEffectOn: "render", rippleEffect: { period: 4, scale: 2.5, brushType: "fill" }, symbolSize: 10,
    },
  }); const Qk = vg.prototype; Qk.stopEffectAnimation = function () { this.childAt(1).removeAll(); }, Qk.startEffectAnimation = function (t) {
    for (var e = t.symbolType, i = t.color, n = this.childAt(1), o = 0; o < 3; o++) {
      const a = $l(e, -1, -1, 2, 2, i); a.attr({
        style: { strokeNoScale: !0 }, z2: 99, silent: !0, scale: [0.5, 0.5],
      }); const r = -o / 3 * t.period + t.effectOffset; a.animate("", !0).when(t.period, { scale: [t.rippleScale / 2, t.rippleScale / 2] }).delay(r).start(), a.animateStyle(!0).when(t.period, { opacity: 0 }).delay(r).start(), n.add(a);
    }mg(n, t);
  }, Qk.updateEffectAnimation = function (t) { for (var e = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale"], o = 0; o < n.length; o++) { const a = n[o]; if (e[a] !== t[a]) return this.stopEffectAnimation(), void this.startEffectAnimation(t); }mg(i, t); }, Qk.highlight = function () { this.trigger("emphasis"); }, Qk.downplay = function () { this.trigger("normal"); }, Qk.updateData = function (t, e) { const i = t.hostModel; this.childAt(0).updateData(t, e); const n = this.childAt(1); const o = t.getItemModel(e); const a = t.getItemVisual(e, "symbol"); const r = gg(t.getItemVisual(e, "symbolSize")); const s = t.getItemVisual(e, "color"); n.attr("scale", r), n.traverse((t) => { t.attr({ fill: s }); }); const l = o.getShallow("symbolOffset"); if (l) { const u = n.position; u[0] = Bo(l[0], r[0]), u[1] = Bo(l[1], r[1]); }n.rotation = (o.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0; const h = {}; if (h.showEffectOn = i.get("showEffectOn"), h.rippleScale = o.get("rippleEffect.scale"), h.brushType = o.get("rippleEffect.brushType"), h.period = 1e3 * o.get("rippleEffect.period"), h.effectOffset = e / t.count(), h.z = o.getShallow("z") || 0, h.zlevel = o.getShallow("zlevel") || 0, h.symbolType = a, h.color = s, this.off("mouseover").off("mouseout").off("emphasis").off("normal"), h.showEffectOn === "render") this._effectCfg ? this.updateEffectAnimation(h) : this.startEffectAnimation(h), this._effectCfg = h; else { this._effectCfg = null, this.stopEffectAnimation(); const c = this.childAt(0); const d = function () { c.highlight(), h.showEffectOn !== "render" && this.startEffectAnimation(h); }; const f = function () { c.downplay(), h.showEffectOn !== "render" && this.stopEffectAnimation(); }; this.on("mouseover", d, this).on("mouseout", f, this).on("emphasis", d, this).on("normal", f, this); } this._effectCfg = h; }, Qk.fadeOut = function (t) { this.off("mouseover").off("mouseout").off("emphasis").off("normal"), t && t(); }, u(vg, tb), Hs({
    type: "effectScatter", init() { this._symbolDraw = new Au(vg); }, render(t, e, i) { const n = t.getData(); const o = this._symbolDraw; o.updateData(n), this.group.add(o.group); }, updateTransform(t, e, i) { const n = t.getData(); this.group.dirty(); const o = DD().reset(t); o.progress && o.progress({ start: 0, end: n.count() }, n), this._symbolDraw.updateLayout(n); }, _updateGroupTransform(t) { const e = t.coordinateSystem; e && e.getRoamTransform && (this.group.transform = At(e.getRoamTransform()), this.group.decomposeTransform()); }, remove(t, e) { this._symbolDraw && this._symbolDraw.remove(e); }, dispose() {},
  }), zs(AD("effectScatter", "circle")), Rs(DD("effectScatter")); const tP = typeof Uint32Array === "undefined" ? Array : Uint32Array; const eP = typeof Float64Array === "undefined" ? Array : Float64Array; var iP = qI.extend({
    type: "series.lines",
    dependencies: ["grid", "polar"],
    visualColorAccessPath: "lineStyle.color",
    init(t) { t.data = t.data || [], yg(t); const e = this._processFlatCoordsArray(t.data); this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count)), iP.superApply(this, "init", arguments); },
    mergeOption(t) { if (t.data = t.data || [], yg(t), t.data) { const e = this._processFlatCoordsArray(t.data); this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset, e.flatCoords && (t.data = new Float32Array(e.count)); }iP.superApply(this, "mergeOption", arguments); },
    appendData(t) { const e = this._processFlatCoordsArray(t.data); e.flatCoords && (this._flatCoords ? (this._flatCoords = z(this._flatCoords, e.flatCoords), this._flatCoordsOffset = z(this._flatCoordsOffset, e.flatCoordsOffset)) : (this._flatCoords = e.flatCoords, this._flatCoordsOffset = e.flatCoordsOffset), t.data = new Float32Array(e.count)), this.getRawData().appendData(t.data); },
    _getCoordsFromItemModel(t) { const e = this.getData().getItemModel(t); return e.option instanceof Array ? e.option : e.getShallow("coords"); },
    getLineCoordsCount(t) { return this._flatCoordsOffset ? this._flatCoordsOffset[2 * t + 1] : this._getCoordsFromItemModel(t).length; },
    getLineCoords(t, e) { if (this._flatCoordsOffset) { for (var i = this._flatCoordsOffset[2 * t], n = this._flatCoordsOffset[2 * t + 1], o = 0; o < n; o++)e[o] = e[o] || [], e[o][0] = this._flatCoords[i + 2 * o], e[o][1] = this._flatCoords[i + 2 * o + 1]; return n; } for (var a = this._getCoordsFromItemModel(t), o = 0; o < a.length; o++)e[o] = e[o] || [], e[o][0] = a[o][0], e[o][1] = a[o][1]; return a.length; },
    _processFlatCoordsArray(t) { let e = 0; if (this._flatCoords && (e = this._flatCoords.length), typeof t[0] === "number") { for (var i = t.length, n = new tP(i), o = new eP(i), a = 0, r = 0, s = 0, l = 0; l < i;) { s++; const u = t[l++]; n[r++] = a + e, n[r++] = u; for (let h = 0; h < u; h++) { const c = t[l++]; const d = t[l++]; o[a++] = c, o[a++] = d; } } return { flatCoordsOffset: new Uint32Array(n.buffer, 0, r), flatCoords: o, count: s }; } return { flatCoordsOffset: null, flatCoords: null, count: t.length }; },
    getInitialData(t, e) { const i = new yA(["value"], this); return i.hasItemOption = !1, i.initData(t.data, [], (t, e, n, o) => { if (t instanceof Array) return NaN; i.hasItemOption = !0; const a = t.value; return a != null ? a instanceof Array ? a[o] : a : void 0; }), i; },
    formatTooltip(t) { const e = this.getData().getItemModel(t); const i = e.get("name"); if (i) return i; const n = e.get("fromName"); const o = e.get("toName"); const a = []; return n != null && a.push(n), o != null && a.push(o), ea(a.join(" > ")); },
    preventIncremental() { return !!this.get("effect.show"); },
    getProgressive() { const t = this.option.progressive; return t == null ? this.option.large ? 1e4 : this.get("progressive") : t; },
    getProgressiveThreshold() { const t = this.option.progressiveThreshold; return t == null ? this.option.large ? 2e4 : this.get("progressiveThreshold") : t; },
    defaultOption: {
      coordinateSystem: "geo",
      zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      hoverAnimation: !0,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      geoIndex: 0,
      effect: {
        show: !1, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: !0, trailLength: 0.2,
      },
      large: !1,
      largeThreshold: 2e3,
      polyline: !1,
      label: { show: !1, position: "end" },
      lineStyle: { opacity: 0.5 },
    },
  }); const nP = xg.prototype; nP.createLine = function (t, e, i) { return new af(t, e, i); }, nP._updateEffectSymbol = function (t, e) { const i = t.getItemModel(e).getModel("effect"); let n = i.get("symbolSize"); const o = i.get("symbol"); y(n) || (n = [n, n]); const a = i.get("color") || t.getItemVisual(e, "color"); let r = this.childAt(1); this._symbolType !== o && (this.remove(r), (r = $l(o, -0.5, -0.5, 1, 1, a)).z2 = 100, r.culling = !0, this.add(r)), r && (r.setStyle("shadowColor", a), r.setStyle(i.getItemStyle(["color"])), r.attr("scale", n), r.setColor(a), r.attr("scale", n), this._symbolType = o, this._updateEffectAnimation(t, i, e)); }, nP._updateEffectAnimation = function (t, e, i) { const n = this.childAt(1); if (n) { const o = this; const a = t.getItemLayout(i); let r = 1e3 * e.get("period"); const s = e.get("loop"); const l = e.get("constantSpeed"); const u = T(e.get("delay"), e => e / t.count() * r / 3); const h = typeof u === "function"; if (n.ignore = !0, this.updateAnimationPoints(n, a), l > 0 && (r = this.getLineLength(n) / l * 1e3), r !== this._period || s !== this._loop) { n.stopAnimation(); let c = u; h && (c = u(i)), n.__t > 0 && (c = -r * n.__t), n.__t = 0; const d = n.animate("", s).when(r, { __t: 1 }).delay(c).during(() => { o.updateSymbolPosition(n); }); s || d.done(() => { o.remove(n); }), d.start(); } this._period = r, this._loop = s; } }, nP.getLineLength = function (t) { return uw(t.__p1, t.__cp1) + uw(t.__cp1, t.__p2); }, nP.updateAnimationPoints = function (t, e) { t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]; }, nP.updateData = function (t, e, i) { this.childAt(0).updateData(t, e, i), this._updateEffectSymbol(t, e); }, nP.updateSymbolPosition = function (t) { const e = t.__p1; const i = t.__p2; const n = t.__cp1; const o = t.__t; const a = t.position; const r = rn; const s = sn; a[0] = r(e[0], n[0], i[0], o), a[1] = r(e[1], n[1], i[1], o); const l = s(e[0], n[0], i[0], o); const u = s(e[1], n[1], i[1], o); t.rotation = -Math.atan2(u, l) - Math.PI / 2, t.ignore = !1; }, nP.updateLayout = function (t, e) { this.childAt(0).updateLayout(t, e); const i = t.getItemModel(e).getModel("effect"); this._updateEffectAnimation(t, i, e); }, u(xg, tb); const oP = _g.prototype; oP._createPolyline = function (t, e, i) { const n = t.getItemLayout(e); const o = new gM({ shape: { points: n } }); this.add(o), this._updateCommonStl(t, e, i); }, oP.updateData = function (t, e, i) { const n = t.hostModel; Mo(this.childAt(0), { shape: { points: t.getItemLayout(e) } }, n, e), this._updateCommonStl(t, e, i); }, oP._updateCommonStl = function (t, e, i) { const n = this.childAt(0); const o = t.getItemModel(e); const a = t.getItemVisual(e, "color"); let s = i && i.lineStyle; let l = i && i.hoverLineStyle; i && !t.hasItemOption || (s = o.getModel("lineStyle").getLineStyle(), l = o.getModel("emphasis.lineStyle").getLineStyle()), n.useStyle(r({ strokeNoScale: !0, fill: "none", stroke: a }, s)), n.hoverStyle = l, co(this); }, oP.updateLayout = function (t, e) { this.childAt(0).setShape("points", t.getItemLayout(e)); }, u(_g, tb); const aP = wg.prototype; aP.createLine = function (t, e, i) { return new _g(t, e, i); }, aP.updateAnimationPoints = function (t, e) { this._points = e; for (var i = [0], n = 0, o = 1; o < e.length; o++) { const a = e[o - 1]; const r = e[o]; n += uw(a, r), i.push(n); } if (n !== 0) { for (o = 0; o < i.length; o++)i[o] /= n; this._offsets = i, this._length = n; } }, aP.getLineLength = function (t) { return this._length; }, aP.updateSymbolPosition = function (t) { const e = t.__t; const i = this._points; const n = this._offsets; const o = i.length; if (n) { const a = this._lastFrame; if (e < this._lastFramePercent) { for (r = Math.min(a + 1, o - 1); r >= 0 && !(n[r] <= e); r--);r = Math.min(r, o - 2); } else { for (var r = a; r < o && !(n[r] > e); r++);r = Math.min(r - 1, o - 2); }J(t.position, i[r], i[r + 1], (e - n[r]) / (n[r + 1] - n[r])); const s = i[r + 1][0] - i[r][0]; const l = i[r + 1][1] - i[r][1]; t.rotation = -Math.atan2(l, s) - Math.PI / 2, this._lastFrame = r, this._lastFramePercent = e, t.ignore = !1; } }, u(wg, xg); const rP = Zn({ shape: { polyline: !1, curveness: 0, segs: [] }, buildPath(t, e) { const i = e.segs; const n = e.curveness; if (e.polyline) for (r = 0; r < i.length;) { const o = i[r++]; if (o > 0) { t.moveTo(i[r++], i[r++]); for (let a = 1; a < o; a++)t.lineTo(i[r++], i[r++]); } } else for (var r = 0; r < i.length;) { const s = i[r++]; const l = i[r++]; const u = i[r++]; const h = i[r++]; if (t.moveTo(s, l), n > 0) { const c = (s + u) / 2 - (l - h) * n; const d = (l + h) / 2 - (u - s) * n; t.quadraticCurveTo(c, d, u, h); } else t.lineTo(u, h); } }, findDataIndex(t, e) { const i = this.shape; const n = i.segs; const o = i.curveness; if (i.polyline) for (var a = 0, r = 0; r < n.length;) { const s = n[r++]; if (s > 0) for (var l = n[r++], u = n[r++], h = 1; h < s; h++) if (vn(l, u, c = n[r++], d = n[r++])) return a; a++; } else for (var a = 0, r = 0; r < n.length;) { var l = n[r++]; var u = n[r++]; var c = n[r++]; var d = n[r++]; if (o > 0) { if (xn(l, u, (l + c) / 2 - (u - d) * o, (u + d) / 2 - (c - l) * o, c, d)) return a; } else if (vn(l, u, c, d)) return a; a++; } return -1; } }); const sP = bg.prototype; sP.isPersistent = function () { return !this._incremental; }, sP.updateData = function (t) { this.group.removeAll(); const e = new rP({ rectHover: !0, cursor: "default" }); e.setShape({ segs: t.getLayout("linesPoints") }), this._setCommon(e, t), this.group.add(e), this._incremental = null; }, sP.incrementalPrepareUpdate = function (t) { this.group.removeAll(), this._clearIncremental(), t.count() > 5e5 ? (this._incremental || (this._incremental = new Hn({ silent: !0 })), this.group.add(this._incremental)) : this._incremental = null; }, sP.incrementalUpdate = function (t, e) { const i = new rP(); i.setShape({ segs: e.getLayout("linesPoints") }), this._setCommon(i, e, !!this._incremental), this._incremental ? this._incremental.addDisplayable(i, !0) : (i.rectHover = !0, i.cursor = "default", i.__startIndex = t.start, this.group.add(i)); }, sP.remove = function () { this._clearIncremental(), this._incremental = null, this.group.removeAll(); }, sP._setCommon = function (t, e, i) { const n = e.hostModel; t.setShape({ polyline: n.get("polyline"), curveness: n.get("lineStyle.curveness") }), t.useStyle(n.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = !0; const o = e.getVisual("color"); o && t.setStyle("stroke", o), t.setStyle("fill"), i || (t.seriesIndex = n.seriesIndex, t.on("mousemove", (e) => { t.dataIndex = null; const i = t.findDataIndex(e.offsetX, e.offsetY); i > 0 && (t.dataIndex = i + t.__startIndex); })); }, sP._clearIncremental = function () { const t = this._incremental; t && t.clearDisplaybles(); }; const lP = { seriesType: "lines", plan: JI(), reset(t) { const e = t.coordinateSystem; const i = t.get("polyline"); const n = t.pipelineContext.large; return { progress(o, a) { const r = []; if (n) { let s; const l = o.end - o.start; if (i) { for (var u = 0, h = o.start; h < o.end; h++)u += t.getLineCoordsCount(h); s = new Float32Array(l + 2 * u); } else s = new Float32Array(4 * l); for (var c = 0, d = [], h = o.start; h < o.end; h++) { g = t.getLineCoords(h, r), i && (s[c++] = g); for (let f = 0; f < g; f++)d = e.dataToPoint(r[f], !1, d), s[c++] = d[0], s[c++] = d[1]; }a.setLayout("linesPoints", s); } else for (h = o.start; h < o.end; h++) { const p = a.getItemModel(h); var g = t.getLineCoords(h, r); const m = []; if (i) for (let v = 0; v < g; v++)m.push(e.dataToPoint(r[v])); else { m[0] = e.dataToPoint(r[0]), m[1] = e.dataToPoint(r[1]); const y = p.get("lineStyle.curveness"); +y && (m[2] = [(m[0][0] + m[1][0]) / 2 - (m[0][1] - m[1][1]) * y, (m[0][1] + m[1][1]) / 2 - (m[1][0] - m[0][0]) * y]); }a.setItemLayout(h, m); } } }; } }; Hs({
    type: "lines", init() {}, render(t, e, i) { const n = t.getData(); const o = this._updateLineDraw(n, t); const a = t.get("zlevel"); const r = t.get("effect.trailLength"); const s = i.getZr(); const l = s.painter.getType() === "svg"; l || s.painter.getLayer(a).clear(!0), this._lastZlevel == null || l || s.configLayer(this._lastZlevel, { motionBlur: !1 }), this._showEffect(t) && r && (l || s.configLayer(a, { motionBlur: !0, lastFrameAlpha: Math.max(Math.min(r / 10 + 0.9, 1), 0) })), o.updateData(n), this._lastZlevel = a, this._finished = !0; }, incrementalPrepareRender(t, e, i) { const n = t.getData(); this._updateLineDraw(n, t).incrementalPrepareUpdate(n), this._clearLayer(i), this._finished = !1; }, incrementalRender(t, e, i) { this._lineDraw.incrementalUpdate(t, e.getData()), this._finished = t.end === e.getData().count(); }, updateTransform(t, e, i) { const n = t.getData(); const o = t.pipelineContext; if (!this._finished || o.large || o.progressiveRender) return { update: !0 }; const a = lP.reset(t); a.progress && a.progress({ start: 0, end: n.count() }, n), this._lineDraw.updateLayout(), this._clearLayer(i); }, _updateLineDraw(t, e) { let i = this._lineDraw; const n = this._showEffect(e); const o = !!e.get("polyline"); const a = e.pipelineContext.large; return i && n === this._hasEffet && o === this._isPolyline && a === this._isLargeDraw || (i && i.remove(), i = this._lineDraw = a ? new bg() : new rf(o ? n ? wg : _g : n ? xg : af), this._hasEffet = n, this._isPolyline = o, this._isLargeDraw = a, this.group.removeAll()), this.group.add(i.group), i; }, _showEffect(t) { return !!t.get("effect.show"); }, _clearLayer(t) { const e = t.getZr(); e.painter.getType() === "svg" || this._lastZlevel == null || e.painter.getLayer(this._lastZlevel).clear(!0); }, remove(t, e) { this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(e); }, dispose() {},
  }); const uP = "lineStyle.opacity".split("."); const hP = { seriesType: "lines", reset(t, e, i) { const n = Sg(t.get("symbol")); const o = Sg(t.get("symbolSize")); const a = t.getData(); return a.setVisual("fromSymbol", n && n[0]), a.setVisual("toSymbol", n && n[1]), a.setVisual("fromSymbolSize", o && o[0]), a.setVisual("toSymbolSize", o && o[1]), a.setVisual("opacity", t.get(uP)), { dataEach: a.hasItemOption ? function (t, e) { const i = t.getItemModel(e); const n = Sg(i.getShallow("symbol", !0)); const o = Sg(i.getShallow("symbolSize", !0)); const a = i.get(uP); n[0] && t.setItemVisual(e, "fromSymbol", n[0]), n[1] && t.setItemVisual(e, "toSymbol", n[1]), o[0] && t.setItemVisual(e, "fromSymbolSize", o[0]), o[1] && t.setItemVisual(e, "toSymbolSize", o[1]), t.setItemVisual(e, "opacity", a); } : null }; } }; Rs(lP), zs(hP), qI.extend({
    type: "series.heatmap",
    getInitialData(t, e) { return gl(this.getSource(), this, { generateCoord: "value" }); },
    preventIncremental() { const t = Ga.get(this.get("coordinateSystem")); if (t && t.dimensions) return t.dimensions[0] === "lng" && t.dimensions[1] === "lat"; },
    defaultOption: {
      coordinateSystem: "cartesian2d", zlevel: 0, z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0,
    },
  }); Mg.prototype = { update(t, e, i, n, o, a) { const r = this._getBrush(); const s = this._getGradient(t, o, "inRange"); const l = this._getGradient(t, o, "outOfRange"); const u = this.pointSize + this.blurSize; const h = this.canvas; const c = h.getContext("2d"); const d = t.length; h.width = e, h.height = i; for (let f = 0; f < d; ++f) { const p = t[f]; const g = p[0]; const m = p[1]; var v = n(p[2]); c.globalAlpha = v, c.drawImage(r, g - u, m - u); } if (!h.width || !h.height) return h; for (var y = c.getImageData(0, 0, h.width, h.height), x = y.data, _ = 0, w = x.length, b = this.minOpacity, S = this.maxOpacity - b; _ < w;) { var v = x[_ + 3] / 256; const M = 4 * Math.floor(255 * v); if (v > 0) { const I = a(v) ? s : l; v > 0 && (v = v * S + b), x[_++] = I[M], x[_++] = I[M + 1], x[_++] = I[M + 2], x[_++] = I[M + 3] * v * 256; } else _ += 4; } return c.putImageData(y, 0, 0), h; }, _getBrush() { const t = this._brushCanvas || (this._brushCanvas = iw()); const e = this.pointSize + this.blurSize; const i = 2 * e; t.width = i, t.height = i; const n = t.getContext("2d"); return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = "#000", n.beginPath(), n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), t; }, _getGradient(t, e, i) { for (var n = this._gradientPixels, o = n[i] || (n[i] = new Uint8ClampedArray(1024)), a = [0, 0, 0, 0], r = 0, s = 0; s < 256; s++)e[i](s / 255, !0, a), o[r++] = a[0], o[r++] = a[1], o[r++] = a[2], o[r++] = a[3]; return o; } }, Hs({
    type: "heatmap",
    render(t, e, i) { let n; e.eachComponent("visualMap", (e) => { e.eachTargetSeries((i) => { i === t && (n = e); }); }), this.group.removeAll(), this._incrementalDisplayable = null; const o = t.coordinateSystem; o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : Ag(o) && this._renderOnGeo(o, t, n, i); },
    incrementalPrepareRender(t, e, i) { this.group.removeAll(); },
    incrementalRender(t, e, i, n) { e.coordinateSystem && this._renderOnCartesianAndCalendar(e, n, t.start, t.end, !0); },
    _renderOnCartesianAndCalendar(t, e, i, n, o) {
      let r; let s; const l = t.coordinateSystem; if (l.type === "cartesian2d") { const u = l.getAxis("x"); const h = l.getAxis("y"); r = u.getBandWidth(), s = h.getBandWidth(); } for (let c = this.group, d = t.getData(), f = t.getModel("itemStyle").getItemStyle(["color"]), p = t.getModel("emphasis.itemStyle").getItemStyle(), g = t.getModel("label"), m = t.getModel("emphasis.label"), v = l.type, y = v === "cartesian2d" ? [d.mapDimension("x"), d.mapDimension("y"), d.mapDimension("value")] : [d.mapDimension("time"), d.mapDimension("value")], x = i; x < n; x++) {
        var _; if (v === "cartesian2d") {
          if (isNaN(d.get(y[2], x))) continue; const w = l.dataToPoint([d.get(y[0], x), d.get(y[1], x)]); _ = new yM({
            shape: {
              x: w[0] - r / 2, y: w[1] - s / 2, width: r, height: s,
            },
            style: { fill: d.getItemVisual(x, "color"), opacity: d.getItemVisual(x, "opacity") },
          });
        } else { if (isNaN(d.get(y[1], x))) continue; _ = new yM({ z2: 1, shape: l.dataToRect([d.get(y[0], x)]).contentShape, style: { fill: d.getItemVisual(x, "color"), opacity: d.getItemVisual(x, "opacity") } }); } const b = d.getItemModel(x); d.hasItemOption && (f = b.getModel("itemStyle").getItemStyle(["color"]), p = b.getModel("emphasis.itemStyle").getItemStyle(), g = b.getModel("label"), m = b.getModel("emphasis.label")); const S = t.getRawValue(x); let M = "-"; S && S[2] != null && (M = S[2]), po(f, p, g, m, {
          labelFetcher: t, labelDataIndex: x, defaultText: M, isRectText: !0,
        }), _.setStyle(f), co(_, d.hasItemOption ? p : a({}, p)), _.incremental = o, o && (_.useHoverLayer = !0), c.add(_), d.setItemGraphicEl(x, _);
      }
    },
    _renderOnGeo(t, e, i, n) {
      const o = i.targetVisuals.inRange; const a = i.targetVisuals.outOfRange; const r = e.getData(); const s = this._hmLayer || this._hmLayer || new Mg(); s.blurSize = e.get("blurSize"), s.pointSize = e.get("pointSize"), s.minOpacity = e.get("minOpacity"), s.maxOpacity = e.get("maxOpacity"); const l = t.getViewRect().clone(); const u = t.getRoamTransform(); l.applyTransform(u); const h = Math.max(l.x, 0); const c = Math.max(l.y, 0); const d = Math.min(l.width + l.x, n.getWidth()); const f = Math.min(l.height + l.y, n.getHeight()); const p = d - h; const g = f - c; const m = [r.mapDimension("lng"), r.mapDimension("lat"), r.mapDimension("value")]; const v = r.mapArray(m, (e, i, n) => { const o = t.dataToPoint([e, i]); return o[0] -= h, o[1] -= c, o.push(n), o; }); const y = i.getExtent(); const x = i.type === "visualMap.continuous" ? Tg(y, i.option.range) : Ig(y, i.getPieceList(), i.option.selected); s.update(v, p, g, o.color.getNormalizer(), { inRange: o.color.getColorMapper(), outOfRange: a.color.getColorMapper() }, x); const _ = new fi({
        style: {
          width: p, height: g, x: h, y: c, image: s.canvas,
        },
        silent: !0,
      }); this.group.add(_);
    },
    dispose() {},
  }); var cP = JD.extend({
    type: "series.pictorialBar",
    dependencies: ["grid"],
    defaultOption: {
      symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: !1, symbolRepeatDirection: "end", symbolClip: !1, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", progressive: 0, hoverAnimation: !1,
    },
    getInitialData(t) { return t.stack = null, cP.superApply(this, "getInitialData", arguments); },
  }); var dP = ["itemStyle", "borderWidth"]; const fP = [{
    xy: "x", wh: "width", index: 0, posDesc: ["left", "right"],
  }, {
    xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"],
  }]; var pP = new sM(); Hs({
    type: "pictorialBar",
    render(t, e, i) {
      const n = this.group; const o = t.getData(); const a = this._data; const r = t.coordinateSystem; const s = !!r.getBaseAxis().isHorizontal(); const l = r.grid.getRect(); const u = {
        ecSize: { width: i.getWidth(), height: i.getHeight() }, seriesModel: t, coordSys: r, coordSysExtent: [[l.x, l.x + l.width], [l.y, l.y + l.height]], isHorizontal: s, valueDim: fP[+s], categoryDim: fP[1 - s],
      }; return o.diff(a).add((t) => { if (o.hasValue(t)) { const e = Vg(o, t); const i = Dg(o, t, e, u); const a = Hg(o, u, i); o.setItemGraphicEl(t, a), n.add(a), qg(a, u, i); } }).update((t, e) => { let i = a.getItemGraphicEl(e); if (o.hasValue(t)) { const r = Vg(o, t); const s = Dg(o, t, r, u); const l = Xg(o, s); i && l !== i.__pictorialShapeStr && (n.remove(i), o.setItemGraphicEl(t, null), i = null), i ? Zg(i, u, s) : i = Hg(o, u, s, !0), o.setItemGraphicEl(t, i), i.__pictorialSymbolMeta = s, n.add(i), qg(i, u, s); } else n.remove(i); }).remove((t) => { const e = a.getItemGraphicEl(t); e && Ug(a, t, e.__pictorialSymbolMeta.animationModel, e); })
        .execute(), this._data = o, this.group;
    },
    dispose: B,
    remove(t, e) { const i = this.group; const n = this._data; t.get("animation") ? n && n.eachItemGraphicEl((e) => { Ug(n, e.dataIndex, t, e); }) : i.removeAll(); },
  }); Rs(v(Ol, "pictorialBar")), zs(AD("pictorialBar", "roundRect")); const gP = function (t, e, i, n, o) { rD.call(this, t, e, i), this.type = n || "value", this.position = o || "bottom", this.orient = null; }; gP.prototype = {
    constructor: gP, model: null, isHorizontal() { const t = this.position; return t === "top" || t === "bottom"; }, pointToData(t, e) { return this.coordinateSystem.pointToData(t, e)[0]; }, toGlobalCoord: null, toLocalCoord: null,
  }, u(gP, rD), $g.prototype = {
    type: "singleAxis",
    axisPointerEnabled: !0,
    constructor: $g,
    _init(t, e, i) { const n = this.dimension; const o = new gP(n, Wl(t), [0, 0], t.get("type"), t.get("position")); const a = o.type === "category"; o.onBand = a && t.get("boundaryGap"), o.inverse = t.get("inverse"), o.orient = t.get("orient"), t.axis = o, o.model = t, o.coordinateSystem = this, this._axis = o; },
    update(t, e) { t.eachSeries(function (t) { if (t.coordinateSystem === this) { const e = t.getData(); d(e.mapDimension(this.dimension, !0), function (t) { this._axis.scale.unionExtentFromData(e, t); }, this), Fl(this._axis.scale, this._axis.model); } }, this); },
    resize(t, e) {
      this._rect = ha({
        left: t.get("left"), top: t.get("top"), right: t.get("right"), bottom: t.get("bottom"), width: t.get("width"), height: t.get("height"),
      }, { width: e.getWidth(), height: e.getHeight() }), this._adjustAxis();
    },
    getRect() { return this._rect; },
    _adjustAxis() { const t = this._rect; const e = this._axis; const i = e.isHorizontal(); const n = i ? [0, t.width] : [0, t.height]; const o = e.reverse ? 1 : 0; e.setExtent(n[o], n[1 - o]), this._updateAxisTransform(e, i ? t.x : t.y); },
    _updateAxisTransform(t, e) { const i = t.getExtent(); const n = i[0] + i[1]; const o = t.isHorizontal(); t.toGlobalCoord = o ? function (t) { return t + e; } : function (t) { return n - t + e; }, t.toLocalCoord = o ? function (t) { return t - e; } : function (t) { return n - t + e; }; },
    getAxis() { return this._axis; },
    getBaseAxis() { return this._axis; },
    getAxes() { return [this._axis]; },
    getTooltipAxes() { return { baseAxes: [this.getAxis()] }; },
    containPoint(t) { const e = this.getRect(); const i = this.getAxis(); return i.orient === "horizontal" ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height; },
    pointToData(t) { const e = this.getAxis(); return [e.coordToData(e.toLocalCoord(t[e.orient === "horizontal" ? 0 : 1]))]; },
    dataToPoint(t) { const e = this.getAxis(); const i = this.getRect(); const n = []; const o = e.orient === "horizontal" ? 0 : 1; return t instanceof Array && (t = t[0]), n[o] = e.toGlobalCoord(e.dataToCoord(+t)), n[1 - o] = o === 0 ? i.y + i.height / 2 : i.x + i.width / 2, n; },
  }, Ga.register("single", { create(t, e) { const i = []; return t.eachComponent("singleAxis", (n, o) => { const a = new $g(n, t, e); a.name = `single_${o}`, a.resize(n, e), n.coordinateSystem = a, i.push(a); }), t.eachSeries((e) => { if (e.get("coordinateSystem") === "singleAxis") { const i = t.queryComponents({ mainType: "singleAxis", index: e.get("singleAxisIndex"), id: e.get("singleAxisId") })[0]; e.coordinateSystem = i && i.coordinateSystem; } }), i; }, dimensions: $g.prototype.dimensions }); const mP = ["axisLine", "axisTickLabel", "axisName"]; var vP = jD.extend({
    type: "singleAxis",
    axisPointerClass: "SingleAxisPointer",
    render(t, e, i, n) { const o = this.group; o.removeAll(); const a = Jg(t); const r = new WD(t, a); d(mP, r.add, r), o.add(r.getGroup()), t.get("splitLine.show") && this._splitLine(t), vP.superCall(this, "render", t, e, i, n); },
    _splitLine(t) {
      const e = t.axis; if (!e.scale.isBlank()) {
        const i = t.getModel("splitLine"); const n = i.getModel("lineStyle"); const o = n.get("width"); let a = n.get("color"); a = a instanceof Array ? a : [a]; for (var r = t.coordinateSystem.getRect(), s = e.isHorizontal(), l = [], u = 0, h = e.getTicksCoords({ tickModel: i }), c = [], d = [], f = 0; f < h.length; ++f) {
          const p = e.toGlobalCoord(h[f].coord); s ? (c[0] = p, c[1] = r.y, d[0] = p, d[1] = r.y + r.height) : (c[0] = r.x, c[1] = p, d[0] = r.x + r.width, d[1] = p); const g = u++ % a.length; l[g] = l[g] || [], l[g].push(new _M(qn({
            shape: {
              x1: c[0], y1: c[1], x2: d[0], y2: d[1],
            },
            style: { lineWidth: o },
            silent: !0,
          })));
        } for (f = 0; f < l.length; ++f) this.group.add(OM(l[f], { style: { stroke: a[f % a.length], lineDash: n.getLineDash(o), lineWidth: o }, silent: !0 }));
      }
    },
  }); const yP = uI.extend({
    type: "singleAxis", layoutMode: "box", axis: null, coordinateSystem: null, getCoordSysModel() { return this; },
  }); const xP = {
    left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: !0, lineStyle: { width: 2, type: "solid" } }, tooltip: { show: !0 }, axisTick: { show: !0, length: 6, lineStyle: { width: 2 } }, axisLabel: { show: !0, interval: "auto" }, splitLine: { show: !0, lineStyle: { type: "dashed", opacity: 0.2 } },
  }; n(yP.prototype, XA), RD("single", yP, (t, e) => e.type || (e.data ? "category" : "value"), xP); const _P = function (t, e) { let i; let n = []; const o = t.seriesIndex; if (o == null || !(i = e.getSeriesByIndex(o))) return { point: [] }; const a = i.getData(); const r = zi(a, t); if (r == null || r < 0 || y(r)) return { point: [] }; const s = a.getItemGraphicEl(r); const l = i.coordinateSystem; if (i.getTooltipPosition)n = i.getTooltipPosition(r) || []; else if (l && l.dataToPoint)n = l.dataToPoint(a.getValues(f(l.dimensions, t => a.mapDimension(t)), r, !0)) || []; else if (s) { const u = s.getBoundingRect().clone(); u.applyTransform(s.transform), n = [u.x + u.width / 2, u.y + u.height / 2]; } return { point: n, el: s }; }; var wP = d; const bP = v; var SP = Bi(); var MP = (Gs({
    type: "axisPointer",
    coordSysAxesInfo: null,
    defaultOption: {
      show: "auto",
      triggerOn: null,
      zlevel: 0,
      z: 50,
      type: "line",
      snap: !1,
      triggerTooltip: !0,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: { color: "#aaa", width: 1, type: "solid" },
      shadowStyle: { color: "rgba(150,150,150,0.3)" },
      label: {
        show: !0, formatter: null, precision: "auto", margin: 3, color: "#fff", padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, shadowBlur: 3, shadowColor: "#aaa",
      },
      handle: {
        show: !1, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40,
      },
    },
  }), Bi()); var IP = d; var TP = Fs({
    type: "axisPointer",
    render(t, e, i) {
      const n = e.getComponent("tooltip"); const o = t.get("triggerOn") || n && n.get("triggerOn") || "mousemove|click"; um("axisPointer", i, (t, e, i) => {
        o !== "none" && (t === "leave" || o.indexOf(t) >= 0) && i({
          type: "updateAxisPointer", currTrigger: t, x: e && e.offsetX, y: e && e.offsetY,
        });
      });
    },
    remove(t, e) { gm(e.getZr(), "axisPointer"), TP.superApply(this._model, "remove", arguments); },
    dispose(t, e) { gm("axisPointer", e), TP.superApply(this._model, "dispose", arguments); },
  }); var AP = Bi(); const DP = i; const CP = m; (mm.prototype = {
    _group: null,
    _lastGraphicKey: null,
    _handle: null,
    _dragging: !1,
    _lastValue: null,
    _lastStatus: null,
    _payloadInfo: null,
    animationThreshold: 15,
    render(t, e, i, n) { const o = e.get("value"); const a = e.get("status"); if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== o || this._lastStatus !== a) { this._lastValue = o, this._lastStatus = a; let r = this._group; const s = this._handle; if (!a || a === "hide") return r && r.hide(), void (s && s.hide()); r && r.show(), s && s.show(); const l = {}; this.makeElOption(l, o, t, e, i); const u = l.graphicKey; u !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = u; const h = this._moveAnimation = this.determineAnimation(t, e); if (r) { const c = v(vm, e, h); this.updatePointerEl(r, l, c, e), this.updateLabelEl(r, l, c, e); } else r = this._group = new tb(), this.createPointerEl(r, l, t, e), this.createLabelEl(r, l, t, e), i.getZr().add(r); wm(r, e, !0), this._renderHandle(o); } },
    remove(t) { this.clear(t); },
    dispose(t) { this.clear(t); },
    determineAnimation(t, e) { const i = e.get("animation"); const n = t.axis; const o = n.type === "category"; const a = e.get("snap"); if (!a && !o) return !1; if (i === "auto" || i == null) { const r = this.animationThreshold; if (o && n.getBandWidth() > r) return !0; if (a) { const s = Sh(t).seriesDataCount; const l = n.getExtent(); return Math.abs(l[0] - l[1]) / s > r; } return !1; } return !0 === i; },
    makeElOption(t, e, i, n, o) {},
    createPointerEl(t, e, i, n) { const o = e.pointer; if (o) { const a = AP(t).pointerEl = new zM[o.type](DP(e.pointer)); t.add(a); } },
    createLabelEl(t, e, i, n) { if (e.label) { const o = AP(t).labelEl = new yM(DP(e.label)); t.add(o), xm(o, n); } },
    updatePointerEl(t, e, i) { const n = AP(t).pointerEl; n && (n.setStyle(e.pointer.style), i(n, { shape: e.pointer.shape })); },
    updateLabelEl(t, e, i, n) { const o = AP(t).labelEl; o && (o.setStyle(e.label.style), i(o, { shape: e.label.shape, position: e.label.position }), xm(o, n)); },
    _renderHandle(t) {
      if (!this._dragging && this.updateHandleTransform) {
        const e = this._axisPointerModel; const i = this._api.getZr(); let n = this._handle; const o = e.getModel("handle"); const a = e.get("status"); if (!o.get("show") || !a || a === "hide") return n && i.remove(n), void (this._handle = null); let r; this._handle || (r = !0, n = this._handle = ko(o.get("icon"), {
          cursor: "move", draggable: !0, onmousemove(t) { mw(t.event); }, onmousedown: CP(this._onHandleDragMove, this, 0, 0), drift: CP(this._onHandleDragMove, this), ondragend: CP(this._onHandleDragEnd, this),
        }), i.add(n)), wm(n, e, !1); const s = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]; n.setStyle(o.getItemStyle(null, s)); let l = o.get("size"); y(l) || (l = [l, l]), n.attr("scale", [l[0] / 2, l[1] / 2]), Pr(this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, r);
      }
    },
    _moveHandleToValue(t, e) { vm(this._axisPointerModel, !e && this._moveAnimation, this._handle, _m(this.getHandleTransform(t, this._axisModel, this._axisPointerModel))); },
    _onHandleDragMove(t, e) { const i = this._handle; if (i) { this._dragging = !0; const n = this.updateHandleTransform(_m(i), [t, e], this._axisModel, this._axisPointerModel); this._payloadInfo = n, i.stopAnimation(), i.attr(_m(n)), AP(i).lastProp = null, this._doDispatchAxisPointer(); } },
    _doDispatchAxisPointer() {
      if (this._handle) {
        const t = this._payloadInfo; const e = this._axisModel; this._api.dispatchAction({
          type: "updateAxisPointer", x: t.cursorPoint[0], y: t.cursorPoint[1], tooltipOption: t.tooltipOption, axesInfo: [{ axisDim: e.axis.dim, axisIndex: e.componentIndex }],
        });
      }
    },
    _onHandleDragEnd(t) { if (this._dragging = !1, this._handle) { const e = this._axisPointerModel.get("value"); this._moveHandleToValue(e), this._api.dispatchAction({ type: "hideTip" }); } },
    getHandleTransform: null,
    updateHandleTransform: null,
    clear(t) { this._lastValue = null, this._lastStatus = null; const e = t.getZr(); const i = this._group; const n = this._handle; e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, this._handle = null, this._payloadInfo = null); },
    doClear() {},
    buildLabel(t, e, i) {
      return i = i || 0, {
        x: t[i], y: t[1 - i], width: e[i], height: e[1 - i],
      };
    },
  }).constructor = mm, Xi(mm); const LP = mm.extend({
    makeElOption(t, e, i, n, o) { const a = i.axis; const r = a.grid; const s = n.get("type"); const l = km(r, a).getOtherAxis(a).getGlobalExtent(); const u = a.toGlobalCoord(a.dataToCoord(e, !0)); if (s && s !== "none") { const h = bm(n); const c = kP[s](a, u, l, h); c.style = h, t.graphicKey = c.type, t.pointer = c; }Am(e, t, Ch(r.model, i), i, n, o); },
    getHandleTransform(t, e, i) { const n = Ch(e.axis.grid.model, e, { labelInside: !1 }); return n.labelMargin = i.get("handle.margin"), { position: Tm(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) }; },
    updateHandleTransform(t, e, i, n) {
      const o = i.axis; const a = o.grid; const r = o.getGlobalExtent(!0); const s = km(a, o).getOtherAxis(o).getGlobalExtent(); const l = o.dim === "x" ? 0 : 1; const u = t.position; u[l] += e[l], u[l] = Math.min(r[1], u[l]), u[l] = Math.max(r[0], u[l]); const h = (s[1] + s[0]) / 2; const c = [h, h]; c[l] = u[l]; const d = [{ verticalAlign: "middle" }, { align: "center" }]; return {
        position: u, rotation: t.rotation, cursorPoint: c, tooltipOption: d[l],
      };
    },
  }); var kP = { line(t, e, i, n) { const o = Dm([e, i[0]], [e, i[1]], Pm(t)); return qn({ shape: o, style: n }), { type: "Line", shape: o }; }, shadow(t, e, i, n) { const o = Math.max(1, t.getBandWidth()); const a = i[1] - i[0]; return { type: "Rect", shape: Cm([e - o / 2, i[0]], [o, a], Pm(t)) }; } }; jD.registerAxisPointerClass("CartesianAxisPointer", LP), Ps((t) => { if (t) { (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {}); const e = t.axisPointer.link; e && !y(e) && (t.axisPointer.link = [e]); } }), Ns(GT.PROCESSOR.STATISTIC, (t, e) => { t.getComponent("axisPointer").coordSysAxesInfo = mh(t, e); }), Os({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, (t, e, i) => { const n = t.currTrigger; let o = [t.x, t.y]; const a = t; const r = t.dispatchAction || m(i.dispatchAction, i); const s = e.getComponent("axisPointer").coordSysAxesInfo; if (s) { lm(o) && (o = _P({ seriesIndex: a.seriesIndex, dataIndex: a.dataIndex }, e).point); const l = lm(o); const u = a.axesInfo; const h = s.axesInfo; const c = n === "leave" || lm(o); const d = {}; const f = {}; const p = { list: [], map: {} }; const g = { showPointer: bP(em, f), showTooltip: bP(im, p) }; wP(s.coordSysMap, (t, e) => { const i = l || t.containPoint(o); wP(s.coordSysAxesInfo[e], (t, e) => { const n = t.axis; const a = rm(u, t); if (!c && i && (!u || a)) { let r = a && a.value; r != null || l || (r = n.pointToData(o)), r != null && Qg(t, r, g, !1, d); } }); }); const v = {}; return wP(h, (t, e) => { const i = t.linkGroup; i && !f[e] && wP(i.axesInfo, (e, n) => { const o = f[n]; if (e !== t && o) { let a = o.value; i.mapper && (a = t.axis.scale.parse(i.mapper(a, sm(e), sm(t)))), v[t.key] = a; } }); }), wP(v, (t, e) => { Qg(h[e], t, g, !0, d); }), nm(f, h, d), om(p, o, t, r), am(h, 0, i), d; } }); var PP = ["x", "y"]; var NP = ["width", "height"]; const OP = mm.extend({
    makeElOption(t, e, i, n, o) { const a = i.axis; const r = a.coordinateSystem; const s = Om(r, 1 - Nm(a)); const l = r.dataToPoint(e)[0]; const u = n.get("type"); if (u && u !== "none") { const h = bm(n); const c = EP[u](a, l, s, h); c.style = h, t.graphicKey = c.type, t.pointer = c; }Am(e, t, Jg(i), i, n, o); },
    getHandleTransform(t, e, i) { const n = Jg(e, { labelInside: !1 }); return n.labelMargin = i.get("handle.margin"), { position: Tm(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) }; },
    updateHandleTransform(t, e, i, n) {
      const o = i.axis; const a = o.coordinateSystem; const r = Nm(o); const s = Om(a, r); const l = t.position; l[r] += e[r], l[r] = Math.min(s[1], l[r]), l[r] = Math.max(s[0], l[r]); const u = Om(a, 1 - r); const h = (u[1] + u[0]) / 2; const c = [h, h]; return c[r] = l[r], {
        position: l, rotation: t.rotation, cursorPoint: c, tooltipOption: { verticalAlign: "middle" },
      };
    },
  }); var EP = { line(t, e, i, n) { const o = Dm([e, i[0]], [e, i[1]], Nm(t)); return qn({ shape: o, style: n }), { type: "Line", shape: o }; }, shadow(t, e, i, n) { const o = t.getBandWidth(); const a = i[1] - i[0]; return { type: "Rect", shape: Cm([e - o / 2, i[0]], [o, a], Nm(t)) }; } }; jD.registerAxisPointerClass("SingleAxisPointer", OP), Fs({ type: "single" }); var RP = qI.extend({
    type: "series.themeRiver",
    dependencies: ["singleAxis"],
    nameMap: null,
    init(t) { RP.superApply(this, "init", arguments), this.legendDataProvider = function () { return this.getRawData(); }; },
    fixData(t) { for (var e = t.length, i = f(zp().key(t => t[2]).entries(t), t => ({ name: t.key, dataList: t.values })), n = i.length, o = -1, a = -1, r = 0; r < n; ++r) { const s = i[r].dataList.length; s > o && (o = s, a = r); } for (let l = 0; l < n; ++l) if (l !== a) for (let u = i[l].name, h = 0; h < o; ++h) { for (var c = i[a].dataList[h][0], d = i[l].dataList.length, p = -1, g = 0; g < d; ++g) if (i[l].dataList[g][0] === c) { p = g; break; }p === -1 && (t[e] = [], t[e][0] = c, t[e][1] = 0, t[e][2] = u, e++); } return t; },
    getInitialData(t, e) { for (var i = e.queryComponents({ mainType: "singleAxis", index: this.get("singleAxisIndex"), id: this.get("singleAxisId") })[0].get("type"), n = g(t.data, t => void 0 !== t[2]), o = this.fixData(n || []), a = [], r = this.nameMap = R(), s = 0, l = 0; l < o.length; ++l)a.push(o[l][2]), r.get(o[l][2]) || (r.set(o[l][2], s), s++); const u = wA(o, { coordDimensions: ["single"], dimensionsDefine: [{ name: "time", type: Ys(i) }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }], encodeDefine: { single: 0, value: 1, itemName: 2 } }); const h = new yA(u, this); return h.initData(o), h; },
    getLayerSeries() { for (var t = this.getData(), e = t.count(), i = [], n = 0; n < e; ++n)i[n] = n; for (var o = f(zp().key(e => t.get("name", e)).entries(i), t => ({ name: t.key, indices: t.values })), a = t.mapDimension("single"), r = 0; r < o.length; ++r)o[r].indices.sort((e, i) => t.get(a, e) - t.get(a, i)); return o; },
    getAxisTooltipData(t, e, i) { y(t) || (t = t ? [t] : []); for (var n, o = this.getData(), a = this.getLayerSeries(), r = [], s = a.length, l = 0; l < s; ++l) { for (var u = Number.MAX_VALUE, h = -1, c = a[l].indices.length, d = 0; d < c; ++d) { const f = o.get(t[0], a[l].indices[d]); const p = Math.abs(f - e); p <= u && (n = f, u = p, h = a[l].indices[d]); }r.push(h); } return { dataIndices: r, nestestValue: n }; },
    formatTooltip(t) { const e = this.getData(); const i = e.getName(t); let n = e.get(e.mapDimension("value"), t); return (isNaN(n) || n == null) && (n = "-"), ea(`${i} : ${n}`); },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "singleAxis",
      boundaryGap: ["10%", "10%"],
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4, show: !0, position: "left", color: "#000", fontSize: 11,
      },
      emphasis: { label: { show: !0 } },
    },
  }); Hs({
    type: "themeRiver",
    init() { this._layers = []; },
    render(t, e, i) {
      function n(t) { return t.name; } function o(e, i, n) {
        const o = this._layers; if (e !== "remove") {
          for (var u, h = [], c = [], f = l[i].indices, p = 0; p < f.length; p++) { const g = r.getItemLayout(f[p]); const m = g.x; const v = g.y0; const { y } = g; h.push([m, v]), c.push([m, v + y]), u = r.getItemVisual(f[p], "color"); } let x; let _; const w = r.getItemLayout(f[0]); const b = r.getItemModel(f[p - 1]); const S = b.getModel("label"); const M = S.get("margin"); if (e === "add") {
            I = d[i] = new tb(); x = new TD({
              shape: {
                points: h, stackedOnPoints: c, smooth: 0.4, stackedOnSmooth: 0.4, smoothConstraint: !1,
              },
              z2: 0,
            }), _ = new rM({ style: { x: w.x - M, y: w.y0 + w.y / 2 } }), I.add(x), I.add(_), s.add(I), x.setClipPath(Em(x.getBoundingRect(), t, () => { x.removeClipPath(); }));
          } else { var I = o[n]; x = I.childAt(0), _ = I.childAt(1), s.add(I), d[i] = I, Mo(x, { shape: { points: h, stackedOnPoints: c } }, t), Mo(_, { style: { x: w.x - M, y: w.y0 + w.y / 2 } }, t); } const T = b.getModel("emphasis.itemStyle"); const A = b.getModel("itemStyle"); go(_.style, S, { text: S.get("show") ? t.getFormattedLabel(f[p - 1], "normal") || r.getName(f[p - 1]) : null, textVerticalAlign: "middle" }), x.setStyle(a({ fill: u }, A.getItemStyle(["color"]))), co(x, T.getItemStyle());
        } else s.remove(o[i]);
      } var r = t.getData(); var s = this.group; var l = t.getLayerSeries(); const u = r.getLayout("layoutInfo"); const h = u.rect; const c = u.boundaryGap; s.attr("position", [0, h.y + c[0]]); var d = {}; new Us(this._layersSeries || [], l, n, n).add(m(o, this, "add")).update(m(o, this, "update")).remove(m(o, this, "remove"))
        .execute(), this._layersSeries = l, this._layers = d;
    },
    dispose() {},
  }); Rs((t, e) => { t.eachSeriesByType("themeRiver", (t) => { const e = t.getData(); const i = t.coordinateSystem; const n = {}; const o = i.getRect(); n.rect = o; const a = t.get("boundaryGap"); const r = i.getAxis(); n.boundaryGap = a, r.orient === "horizontal" ? (a[0] = Bo(a[0], o.height), a[1] = Bo(a[1], o.height), Rm(e, t, o.height - a[0] - a[1])) : (a[0] = Bo(a[0], o.width), a[1] = Bo(a[1], o.width), Rm(e, t, o.width - a[0] - a[1])), e.setLayout("layoutInfo", n); }); }), zs((t) => { t.eachSeriesByType("themeRiver", (t) => { const e = t.getData(); const i = t.getRawData(); const n = t.get("color"); const o = R(); e.each((t) => { o.set(e.getRawIndex(t), t); }), i.each((a) => { const r = i.getName(a); const s = n[(t.nameMap.get(r) - 1) % n.length]; i.setItemVisual(a, "color", s); const l = o.get(a); l != null && e.setItemVisual(l, "color", s); }); }); }), Ns(pC("themeRiver")), qI.extend({
    type: "series.sunburst",
    _viewRoot: null,
    getInitialData(t, e) { const i = { name: t.name, children: t.data }; Bm(i); const n = t.levels || []; const o = {}; return o.levels = n, Bc.createTree(i, this, o).data; },
    optionUpdated() { this.resetViewRoot(); },
    getDataParams(t) { const e = qI.prototype.getDataParams.apply(this, arguments); const i = this.getData().tree.getNodeByDataIndex(t); return e.treePathInfo = hd(i, this), e; },
    defaultOption: {
      zlevel: 0,
      z: 2,
      center: ["50%", "50%"],
      radius: [0, "75%"],
      clockwise: !0,
      startAngle: 90,
      minAngle: 0,
      percentPrecision: 2,
      stillShowZeroSum: !0,
      highlightPolicy: "descendant",
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        rotate: "radial", show: !0, opacity: 1, align: "center", position: "inside", distance: 5, silent: !0, emphasis: {},
      },
      itemStyle: {
        borderWidth: 1, borderColor: "white", borderType: "solid", shadowBlur: 0, shadowColor: "rgba(0, 0, 0, 0.2)", shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1, emphasis: {}, highlight: { opacity: 1 }, downplay: { opacity: 0.9 },
      },
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      animationEasing: "cubicOut",
      data: [],
      levels: [],
      sort: "desc",
    },
    getViewRoot() { return this._viewRoot; },
    resetViewRoot(t) { t ? this._viewRoot = t : t = this._viewRoot; const e = this.getRawData().tree.root; t && (t === e || e.contains(t)) || (this._viewRoot = e); },
  }); var zP = {
    NONE: "none", DESCENDANT: "descendant", ANCESTOR: "ancestor", SELF: "self",
  }; var BP = 2; var VP = 4; const GP = Vm.prototype; GP.updateData = function (t, e, i, o, s) { this.node = e, e.piece = this, o = o || this._seriesModel, s = s || this._ecModel; const l = this.childAt(0); l.dataIndex = e.dataIndex; const u = e.getModel(); const h = e.getLayout(); const c = a({}, h); c.label = null; const d = Gm(e, 0, s); Hm(e, o, d); let f; const p = u.getModel("itemStyle").getItemStyle(); f = r({ lineJoin: "bevel", fill: (f = i === "normal" ? p : n(u.getModel(`${i}.itemStyle`).getItemStyle(), p)).fill || d }, f), t ? (l.setShape(c), l.shape.r = h.r0, Mo(l, { shape: { r: h.r } }, o, e.dataIndex), l.useStyle(f)) : typeof f.fill === "object" && f.fill.type || typeof l.style.fill === "object" && l.style.fill.type ? (Mo(l, { shape: c }, o), l.useStyle(f)) : Mo(l, { shape: c, style: f }, o), this._updateLabel(o, d, i); const g = u.getShallow("cursor"); if (g && l.attr("cursor", g), t) { const m = o.getShallow("highlightPolicy"); this._initEvents(l, e, o, m); } this._seriesModel = o || this._seriesModel, this._ecModel = s || this._ecModel; }, GP.onEmphasis = function (t) { const e = this; this.node.hostTree.root.eachNode((i) => { i.piece && (e.node === i ? i.piece.updateData(!1, i, "emphasis") : Wm(i, e.node, t) ? i.piece.childAt(0).trigger("highlight") : t !== zP.NONE && i.piece.childAt(0).trigger("downplay")); }); }, GP.onNormal = function () { this.node.hostTree.root.eachNode((t) => { t.piece && t.piece.updateData(!1, t, "normal"); }); }, GP.onHighlight = function () { this.updateData(!1, this.node, "highlight"); }, GP.onDownplay = function () { this.updateData(!1, this.node, "downplay"); }, GP._updateLabel = function (t, e, i) {
    function n(t) { const e = r.get(t); return e == null ? a.get(t) : e; } const o = this.node.getModel(); var a = o.getModel("label"); var r = i === "normal" || i === "emphasis" ? a : o.getModel(`${i}.label`); const s = o.getModel("emphasis.label"); let l = T(t.getFormattedLabel(this.node.dataIndex, "normal", null, null, "label"), this.node.name); !1 === n("show") && (l = ""); const u = this.node.getLayout(); let h = r.get("minAngle"); h == null && (h = a.get("minAngle")), h = h / 180 * Math.PI; const c = u.endAngle - u.startAngle; h != null && Math.abs(c) < h && (l = ""); const d = this.childAt(1); po(d.style, d.hoverStyle || {}, a, s, { defaultText: r.getShallow("show") ? l : null, autoColor: e, useInsideStyle: !0 }); let f; const p = (u.startAngle + u.endAngle) / 2; const g = Math.cos(p); const m = Math.sin(p); const v = n("position"); const y = n("distance") || 0; let x = n("align"); v === "outside" ? (f = u.r + y, x = p > Math.PI / 2 ? "right" : "left") : x && x !== "center" ? x === "left" ? (f = u.r0 + y, p > Math.PI / 2 && (x = "right")) : x === "right" && (f = u.r - y, p > Math.PI / 2 && (x = "left")) : (f = (u.r + u.r0) / 2, x = "center"), d.attr("style", {
      text: l, textAlign: x, textVerticalAlign: n("verticalAlign") || "middle", opacity: n("opacity"),
    }); const _ = f * g + u.cx; const w = f * m + u.cy; d.attr("position", [_, w]); const b = n("rotate"); let S = 0; b === "radial" ? (S = -p) < -Math.PI / 2 && (S += Math.PI) : b === "tangential" ? (S = Math.PI / 2 - p) > Math.PI / 2 ? S -= Math.PI : S < -Math.PI / 2 && (S += Math.PI) : typeof b === "number" && (S = b * Math.PI / 180), d.attr("rotation", S);
  }, GP._initEvents = function (t, e, i, n) {
    t.off("mouseover").off("mouseout").off("emphasis").off("normal"); const o = this; const a = function () { o.onEmphasis(n); }; const r = function () { o.onNormal(); }; i.isAnimationEnabled() && t.on("mouseover", a).on("mouseout", r).on("emphasis", a).on("normal", r)
      .on("downplay", () => { o.onDownplay(); })
      .on("highlight", () => { o.onHighlight(); });
  }, u(Vm, tb); Tr.extend({
    type: "sunburst",
    init() {},
    render(t, e, i, n) {
      function o(i, n) { if (c || !i || i.getValue() || (i = null), i !== l && n !== l) if (n && n.piece)i ? (n.piece.updateData(!1, i, "normal", t, e), s.setItemGraphicEl(i.dataIndex, n.piece)) : a(n); else if (i) { const o = new Vm(i, t, e); h.add(o), s.setItemGraphicEl(i.dataIndex, o); } } function a(t) { t && t.piece && (h.remove(t.piece), t.piece = null); } const r = this; this.seriesModel = t, this.api = i, this.ecModel = e; var s = t.getData(); var l = s.tree.root; const u = t.getViewRoot(); var h = this.group; var c = t.get("renderLabelForZeroData"); const d = []; u.eachNode((t) => { d.push(t); }); const f = this._oldChildren || []; if ((function (t, e) {
        function i(t) { return t.getId(); } function n(i, n) { o(i == null ? null : t[i], n == null ? null : e[n]); }t.length === 0 && e.length === 0 || new Us(e, t, i, i).add(n).update(n).remove(v(n, null))
          .execute();
      }(d, f)), (function (i, n) { if (n.depth > 0) { r.virtualPiece ? r.virtualPiece.updateData(!1, i, "normal", t, e) : (r.virtualPiece = new Vm(i, t, e), h.add(r.virtualPiece)), n.piece._onclickEvent && n.piece.off("click", n.piece._onclickEvent); const o = function (t) { r._rootToNode(n.parentNode); }; n.piece._onclickEvent = o, r.virtualPiece.on("click", o); } else r.virtualPiece && (h.remove(r.virtualPiece), r.virtualPiece = null); }(l, u)), n && n.highlight && n.highlight.piece) { const p = t.getShallow("highlightPolicy"); n.highlight.piece.onEmphasis(p); } else if (n && n.unhighlight) { let g = this.virtualPiece; !g && l.children.length && (g = l.children[0].piece), g && g.onNormal(); } this._initEvents(), this._oldChildren = d;
    },
    dispose() {},
    _initEvents() { const t = this; const e = function (e) { let i = !1; t.seriesModel.getViewRoot().eachNode((n) => { if (!i && n.piece && n.piece.childAt(0) === e.target) { const o = n.getModel().get("nodeClick"); if (o === "rootToNode")t._rootToNode(n); else if (o === "link") { const a = n.getModel(); const r = a.get("link"); if (r) { const s = a.get("target", !0) || "_blank"; window.open(r, s); } }i = !0; } }); }; this.group._onclickEvent && this.group.off("click", this.group._onclickEvent), this.group.on("click", e), this.group._onclickEvent = e; },
    _rootToNode(t) {
      t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: "sunburstRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t,
      });
    },
    containPoint(t, e) { const i = e.getData().getItemLayout(0); if (i) { const n = t[0] - i.cx; const o = t[1] - i.cy; const a = Math.sqrt(n * n + o * o); return a <= i.r && a >= i.r0; } },
  }); const FP = "sunburstRootToNode"; Os({ type: FP, update: "updateView" }, (t, e) => { e.eachComponent({ mainType: "series", subType: "sunburst", query: t }, (e, i) => { const n = sd(t, [FP], e); if (n) { const o = e.getViewRoot(); o && (t.direction = ud(o, n.node) ? "rollUp" : "drillDown"), e.resetViewRoot(n.node); } }); }); const WP = "sunburstHighlight"; Os({ type: WP, update: "updateView" }, (t, e) => { e.eachComponent({ mainType: "series", subType: "sunburst", query: t }, (e, i) => { const n = sd(t, [WP], e); n && (t.highlight = n.node); }); }); Os({ type: "sunburstUnhighlight", update: "updateView" }, (t, e) => { e.eachComponent({ mainType: "series", subType: "sunburst", query: t }, (e, i) => { t.unhighlight = !0; }); }); const HP = Math.PI / 180; zs(v(hC, "sunburst")), Rs(v((t, e, i, n) => {
    e.eachSeriesByType(t, (t) => {
      let e = t.get("center"); let n = t.get("radius"); y(n) || (n = [0, n]), y(e) || (e = [e, e]); const o = i.getWidth(); const a = i.getHeight(); const r = Math.min(o, a); const s = Bo(e[0], o); const l = Bo(e[1], a); const u = Bo(n[0], r / 2); const h = Bo(n[1], r / 2); const c = -t.get("startAngle") * HP; const f = t.get("minAngle") * HP; const p = t.getData().tree.root; const g = t.getViewRoot(); const m = g.depth; const v = t.get("sort"); v != null && Zm(g, v); let x = 0; d(g.children, (t) => { !isNaN(t.getValue()) && x++; }); const _ = g.getValue(); const w = Math.PI / (_ || x) * 2; const b = g.depth > 0; const S = g.height - (b ? -1 : 1); const M = (h - u) / (S || 1); const I = t.get("clockwise"); const T = t.get("stillShowZeroSum"); const A = I ? 1 : -1; var D = function (t, e) {
        if (t) {
          let i = e; if (t !== p) {
            const n = t.getValue(); let o = _ === 0 && T ? w : n * w; o < f && (o = f), i = e + A * o; const a = t.depth - m - (b ? -1 : 1); let h = u + M * a; let c = u + M * (a + 1); const g = t.getModel(); g.get("r0") != null && (h = Bo(g.get("r0"), r / 2)), g.get("r") != null && (c = Bo(g.get("r"), r / 2)), t.setLayout({
              angle: o, startAngle: e, endAngle: i, clockwise: I, cx: s, cy: l, r0: h, r: c,
            });
          } if (t.children && t.children.length) { let v = 0; d(t.children, (t) => { v += D(t, e + v); }); } return i - e;
        }
      }; if (b) {
        const C = u; const L = u + M; const k = 2 * Math.PI; p.setLayout({
          angle: k, startAngle: c, endAngle: c + k, clockwise: I, cx: s, cy: l, r0: C, r: L,
        });
      }D(g, c);
    });
  }, "sunburst")), Ns(v(pC, "sunburst")); var ZP = ["itemStyle"]; var UP = ["emphasis", "itemStyle"]; var XP = ["label"]; var jP = ["emphasis", "label"]; var YP = "e\0\0"; var qP = {
    cartesian2d(t) {
      const e = t.grid.getRect(); return {
        coordSys: {
          type: "cartesian2d", x: e.x, y: e.y, width: e.width, height: e.height,
        },
        api: { coord(e) { return t.dataToPoint(e); }, size: m(Xm, t) },
      };
    },
    geo(t) {
      const e = t.getBoundingRect(); return {
        coordSys: {
          type: "geo", x: e.x, y: e.y, width: e.width, height: e.height, zoom: t.getZoom(),
        },
        api: { coord(e) { return t.dataToPoint(e); }, size: m(jm, t) },
      };
    },
    singleAxis(t) {
      const e = t.getRect(); return {
        coordSys: {
          type: "singleAxis", x: e.x, y: e.y, width: e.width, height: e.height,
        },
        api: { coord(e) { return t.dataToPoint(e); }, size: m(Ym, t) },
      };
    },
    polar(t) {
      const e = t.getRadiusAxis(); const i = t.getAngleAxis(); const n = e.getExtent(); return n[0] > n[1] && n.reverse(), {
        coordSys: {
          type: "polar", cx: t.cx, cy: t.cy, r: n[1], r0: n[0],
        },
        api: { coord: m((n) => { const o = e.dataToRadius(n[0]); const a = i.dataToAngle(n[1]); const r = t.coordToPoint([o, a]); return r.push(o, a * Math.PI / 180), r; }), size: m(qm, t) },
      };
    },
    calendar(t) {
      const e = t.getRect(); const i = t.getRangeInfo(); return {
        coordSys: {
          type: "calendar",
          x: e.x,
          y: e.y,
          width: e.width,
          height: e.height,
          cellWidth: t.getCellWidth(),
          cellHeight: t.getCellHeight(),
          rangeInfo: {
            start: i.start, end: i.end, weeks: i.weeks, dayCount: i.allDay,
          },
        },
        api: { coord(e, i) { return t.dataToPoint(e, i); } },
      };
    },
  }; qI.extend({
    type: "series.custom",
    dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
    defaultOption: {
      coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, useTransform: !0,
    },
    getInitialData(t, e) { return gl(this.getSource(), this); },
    getDataParams(t, e, i) { const n = qI.prototype.getDataParams.apply(this, arguments); return i && (n.info = i.info), n; },
  }), Tr.extend({
    type: "custom",
    _data: null,
    render(t, e, i, n) {
      const o = this._data; const a = t.getData(); const r = this.group; const s = Qm(t, a, e, i); a.diff(o).add((e) => { ev(null, e, s(e, n), t, r, a); }).update((e, i) => { ev(o.getItemGraphicEl(i), e, s(e, n), t, r, a); }).remove((t) => { const e = o.getItemGraphicEl(t); e && r.remove(e); })
        .execute(), this._data = a;
    },
    incrementalPrepareRender(t, e, i) { this.group.removeAll(), this._data = null; },
    incrementalRender(t, e, i, n, o) { for (let a = e.getData(), r = Qm(e, a, i, n), s = t.start; s < t.end; s++)ev(null, s, r(s, o), e, this.group, a).traverse((t) => { t.isGroup || (t.incremental = !0, t.useHoverLayer = !0); }); },
    dispose: B,
    filterForExposedEvent(t, e, i, n) { const o = e.element; if (o == null || i.name === o) return !0; for (;(i = i.parent) && i !== this.group;) if (i.name === o) return !0; return !1; },
  }), Ps((t) => { const e = t.graphic; y(e) ? e[0] && e[0].elements ? t.graphic = [t.graphic[0]] : t.graphic = [{ elements: e }] : e && !e.elements && (t.graphic = [{ elements: [e] }]); }); var KP = Gs({
    type: "graphic", defaultOption: { elements: [], parentId: null }, _elOptionsToUpdate: null, mergeOption(t) { const e = this.option.elements; this.option.elements = null, KP.superApply(this, "mergeOption", arguments), this.option.elements = e; }, optionUpdated(t, e) { const i = this.option; const n = (e ? i : t).elements; const o = i.elements = e ? [] : i.elements; const a = []; this._flatten(n, a); const r = Pi(o, a); Ni(r); const s = this._elOptionsToUpdate = []; d(r, (t, e) => { const i = t.option; i && (s.push(i), gv(t, i), mv(o, e, i), vv(o[e], i)); }, this); for (let l = o.length - 1; l >= 0; l--)o[l] == null ? o.splice(l, 1) : delete o[l].$action; }, _flatten(t, e, i) { d(t, function (t) { if (t) { i && (t.parentOption = i), e.push(t); const n = t.children; t.type === "group" && n && this._flatten(n, e, t), delete t.children; } }, this); }, useElOptionsToUpdate() { const t = this._elOptionsToUpdate; return this._elOptionsToUpdate = null, t; },
  }); Fs({
    type: "graphic", init(t, e) { this._elMap = R(), this._lastGraphicModel; }, render(t, e, i) { t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i); }, _updateElements(t) { const e = t.useElOptionsToUpdate(); if (e) { const i = this._elMap; const n = this.group; d(e, (e) => { const o = e.$action; const a = e.id; const r = i.get(a); const s = e.parentId; const l = s != null ? i.get(s) : n; const u = e.style; e.type === "text" && u && (e.hv && e.hv[1] && (u.textVerticalAlign = u.textBaseline = null), !u.hasOwnProperty("textFill") && u.fill && (u.textFill = u.fill), !u.hasOwnProperty("textStroke") && u.stroke && (u.textStroke = u.stroke)); const h = fv(e); o && o !== "merge" ? o === "replace" ? (dv(r, i), cv(a, l, h, i)) : o === "remove" && dv(r, i) : r ? r.attr(h) : cv(a, l, h, i); const c = i.get(a); c && (c.__ecGraphicWidth = e.width, c.__ecGraphicHeight = e.height, yv(c, t)); }); } }, _relocate(t, e) { for (let i = t.option.elements, n = this.group, o = this._elMap, a = i.length - 1; a >= 0; a--) { const r = i[a]; const s = o.get(r.id); if (s) { const l = s.parent; ca(s, r, l === n ? { width: e.getWidth(), height: e.getHeight() } : { width: l.__ecGraphicWidth || 0, height: l.__ecGraphicHeight || 0 }, null, { hv: r.hv, boundingMode: r.bounding }); } } }, _clear() { const t = this._elMap; t.each((e) => { dv(e, t); }), this._elMap = R(); }, dispose() { this._clear(); },
  }); var $P = Gs({
    type: "legend.plain",
    dependencies: ["series"],
    layoutMode: { type: "box", ignoreSize: !0 },
    init(t, e, i) { this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}; },
    mergeOption(t) { $P.superCall(this, "mergeOption", t); },
    optionUpdated() { this._updateData(this.ecModel); const t = this._data; if (t[0] && this.get("selectedMode") === "single") { for (var e = !1, i = 0; i < t.length; i++) { const n = t[i].get("name"); if (this.isSelected(n)) { this.select(n), e = !0; break; } }!e && this.select(t[0].get("name")); } },
    _updateData(t) { let e = []; let i = []; t.eachRawSeries((n) => { const o = n.name; i.push(o); let a; if (n.legendDataProvider) { const r = n.legendDataProvider(); const s = r.mapArray(r.getName); t.isSeriesFiltered(n) || (i = i.concat(s)), s.length ? e = e.concat(s) : a = !0; } else a = !0; a && Oi(n) && e.push(n.name); }), this._availableNames = i; const n = f(this.get("data") || e, function (t) { return typeof t !== "string" && typeof t !== "number" || (t = { name: t }), new Po(t, this, this.ecModel); }, this); this._data = n; },
    getData() { return this._data; },
    select(t) { const e = this.option.selected; this.get("selectedMode") === "single" && d(this._data, (t) => { e[t.get("name")] = !1; }), e[t] = !0; },
    unSelect(t) { this.get("selectedMode") !== "single" && (this.option.selected[t] = !1); },
    toggleSelected(t) { const e = this.option.selected; e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t); },
    isSelected(t) { const e = this.option.selected; return !(e.hasOwnProperty(t) && !e[t]) && l(this._availableNames, t) >= 0; },
    defaultOption: {
      zlevel: 0, z: 4, show: !0, orient: "horizontal", left: "center", top: 0, align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, inactiveColor: "#ccc", textStyle: { color: "#333" }, selectedMode: !0, tooltip: { show: !1 },
    },
  }); Os("legendToggleSelect", "legendselectchanged", v(xv, "toggleSelected")), Os("legendSelect", "legendselected", v(xv, "select")), Os("legendUnSelect", "legendunselected", v(xv, "unSelect")); const JP = v; const QP = d; const tN = tb; const eN = Fs({
    type: "legend.plain",
    newlineDisabled: !1,
    init() { this.group.add(this._contentGroup = new tN()), this._backgroundEl, this._isFirstRender = !0; },
    getContentGroup() { return this._contentGroup; },
    render(t, e, i) { const n = this._isFirstRender; if (this._isFirstRender = !1, this.resetInner(), t.get("show", !0)) { let o = t.get("align"); o && o !== "auto" || (o = t.get("left") === "right" && t.get("orient") === "vertical" ? "right" : "left"), this.renderInner(o, t, e, i); const a = t.getBoxLayoutParams(); const s = { width: i.getWidth(), height: i.getHeight() }; const l = t.get("padding"); const u = ha(a, s, l); const h = this.layoutInner(t, o, u, n); const c = ha(r({ width: h.width, height: h.height }, a), s, l); this.group.attr("position", [c.x - h.x, c.y - h.y]), this.group.add(this._backgroundEl = wv(h, t)); } },
    resetInner() { this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl); },
    renderInner(t, e, i, n) { const o = this.getContentGroup(); const a = R(); const r = e.get("selectedMode"); const s = []; i.eachRawSeries((t) => { !t.get("legendHoverLink") && s.push(t.id); }), QP(e.getData(), function (l, u) { const h = l.get("name"); if (this.newlineDisabled || h !== "" && h !== "\n") { const c = i.getSeriesByName(h)[0]; if (!a.get(h)) if (c) { const d = c.getData(); let f = d.getVisual("color"); typeof f === "function" && (f = f(c.getDataParams(0))); const p = d.getVisual("legendSymbol") || "roundRect"; const g = d.getVisual("symbol"); this._createItem(h, u, l, e, p, g, t, f, r).on("click", JP(bv, h, n)).on("mouseover", JP(Sv, c.name, null, n, s)).on("mouseout", JP(Mv, c.name, null, n, s)), a.set(h, !0); } else i.eachRawSeries(function (i) { if (!a.get(h) && i.legendDataProvider) { const o = i.legendDataProvider(); const c = o.indexOfName(h); if (c < 0) return; const d = o.getItemVisual(c, "color"); this._createItem(h, u, l, e, "roundRect", null, t, d, r).on("click", JP(bv, h, n)).on("mouseover", JP(Sv, null, h, n, s)).on("mouseout", JP(Mv, null, h, n, s)), a.set(h, !0); } }, this); } else o.add(new tN({ newline: !0 })); }, this); },
    _createItem(t, e, i, n, o, r, s, l, u) {
      const h = n.get("itemWidth"); const c = n.get("itemHeight"); const d = n.get("inactiveColor"); const f = n.get("symbolKeepAspect"); const p = n.isSelected(t); const g = new tN(); const m = i.getModel("textStyle"); const v = i.get("icon"); const y = i.getModel("tooltip"); const x = y.parentModel; if (o = v || o, g.add($l(o, 0, 0, h, c, p ? l : d, f == null || f)), !v && r && (r !== o || r === "none")) { const _ = 0.8 * c; r === "none" && (r = "circle"), g.add($l(r, (h - _) / 2, (c - _) / 2, _, _, p ? l : d, f == null || f)); } const w = s === "left" ? h + 5 : -5; const b = s; const S = n.get("formatter"); let M = t; typeof S === "string" && S ? M = S.replace("{name}", t != null ? t : "") : typeof S === "function" && (M = S(t)), g.add(new rM({
        style: go({}, m, {
          text: M, x: w, y: c / 2, textFill: p ? m.getTextColor() : d, textAlign: b, textVerticalAlign: "middle",
        }),
      })); const I = new yM({
        shape: g.getBoundingRect(),
        invisible: !0,
        tooltip: y.get("show") ? a({
          content: t,
          formatter: x.get("formatter", !0) || function () { return t; },
          formatterParams: {
            componentType: "legend", legendIndex: n.componentIndex, name: t, $vars: ["name"],
          },
        }, y.option) : null,
      }); return g.add(I), g.eachChild((t) => { t.silent = !0; }), I.silent = !u, this.getContentGroup().add(g), co(g), g.__legendDataIndex = e, g;
    },
    layoutInner(t, e, i) { const n = this.getContentGroup(); rI(t.get("orient"), n, t.get("itemGap"), i.width, i.height); const o = n.getBoundingRect(); return n.attr("position", [-o.x, -o.y]), this.group.getBoundingRect(); },
    remove() { this.getContentGroup().removeAll(), this._isFirstRender = !0; },
  }); Ns((t) => { const e = t.findComponents({ mainType: "legend" }); e && e.length && t.filterSeries((t) => { for (let i = 0; i < e.length; i++) if (!e[i].isSelected(t.name)) return !1; return !0; }); }), uI.registerSubTypeDefaulter("legend", () => "plain"); var iN = $P.extend({
    type: "legend.scroll",
    setScrollDataIndex(t) { this.option.scrollDataIndex = t; },
    defaultOption: {
      scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: "end", pageFormatter: "{current}/{total}", pageIcons: { horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"], vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"] }, pageIconColor: "#2f4554", pageIconInactiveColor: "#aaa", pageIconSize: 15, pageTextStyle: { color: "#333" }, animationDurationUpdate: 800,
    },
    init(t, e, i, n) { const o = pa(t); iN.superCall(this, "init", t, e, i, n), Iv(this, t, o); },
    mergeOption(t, e) { iN.superCall(this, "mergeOption", t, e), Iv(this, this.option, t); },
    getOrient() { return this.get("orient") === "vertical" ? { index: 1, name: "vertical" } : { index: 0, name: "horizontal" }; },
  }); const nN = tb; const oN = ["width", "height"]; const aN = ["x", "y"]; var rN = eN.extend({
    type: "legend.scroll",
    newlineDisabled: !0,
    init() { rN.superCall(this, "init"), this._currentIndex = 0, this.group.add(this._containerGroup = new nN()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new nN()), this._showController; },
    resetInner() { rN.superCall(this, "resetInner"), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null; },
    renderInner(t, e, i, n) {
      function o(t, i) {
        const o = `${t}DataIndex`; const l = ko(e.get("pageIcons", !0)[e.getOrient().name][i], { onclick: m(a._pageGo, a, o, e, n) }, {
          x: -s[0] / 2, y: -s[1] / 2, width: s[0], height: s[1],
        }); l.name = t, r.add(l);
      } var a = this; rN.superCall(this, "renderInner", t, e, i, n); var r = this._controllerGroup; var s = e.get("pageIconSize", !0); y(s) || (s = [s, s]), o("pagePrev", 0); const l = e.getModel("pageTextStyle"); r.add(new rM({
        name: "pageText",
        style: {
          textFill: l.getTextColor(), font: l.getFont(), textVerticalAlign: "middle", textAlign: "center",
        },
        silent: !0,
      })), o("pageNext", 1);
    },
    layoutInner(t, e, i, n) { const o = this.getContentGroup(); const a = this._containerGroup; const r = this._controllerGroup; const s = t.getOrient().index; const l = oN[s]; const u = oN[1 - s]; const h = aN[1 - s]; rI(t.get("orient"), o, t.get("itemGap"), s ? i.width : null, s ? null : i.height), rI("horizontal", r, t.get("pageButtonItemGap", !0)); const c = o.getBoundingRect(); const d = r.getBoundingRect(); const f = this._showController = c[l] > i[l]; const p = [-c.x, -c.y]; n || (p[s] = o.position[s]); const g = [0, 0]; const m = [-d.x, -d.y]; const v = A(t.get("pageButtonGap", !0), t.get("itemGap", !0)); f && (t.get("pageButtonPosition", !0) === "end" ? m[s] += i[l] - d[l] : g[s] += d[l] + v), m[1 - s] += c[u] / 2 - d[u] / 2, o.attr("position", p), a.attr("position", g), r.attr("position", m); let y = this.group.getBoundingRect(); if ((y = { x: 0, y: 0 })[l] = f ? i[l] : c[l], y[u] = Math.max(c[u], d[u]), y[h] = Math.min(0, d[h] + m[1 - s]), a.__rectSize = i[l], f) { const x = { x: 0, y: 0 }; x[l] = Math.max(i[l] - d[l] - v, 0), x[u] = y[u], a.setClipPath(new yM({ shape: x })), a.__rectSize = x[l]; } else r.eachChild((t) => { t.attr({ invisible: !0, silent: !0 }); }); const _ = this._getPageInfo(t); return _.pageIndex != null && Mo(o, { position: _.contentPosition }, !!f && t), this._updatePageInfoView(t, _), y; },
    _pageGo(t, e, i) { const n = this._getPageInfo(e)[t]; n != null && i.dispatchAction({ type: "legendScroll", scrollDataIndex: n, legendId: e.id }); },
    _updatePageInfoView(t, e) { const i = this._controllerGroup; d(["pagePrev", "pageNext"], (n) => { const o = e[`${n}DataIndex`] != null; const a = i.childOfName(n); a && (a.setStyle("fill", o ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), a.cursor = o ? "pointer" : "default"); }); const n = i.childOfName("pageText"); const o = t.get("pageFormatter"); const a = e.pageIndex; const r = a != null ? a + 1 : 0; const s = e.pageCount; n && o && n.setStyle("text", _(o) ? o.replace("{current}", r).replace("{total}", s) : o({ current: r, total: s })); },
    _getPageInfo(t) {
      function e(t) { if (t) { const e = t.getBoundingRect(); const i = e[l] + t.position[r]; return { s: i, e: i + e[s], i: t.__legendDataIndex }; } } function i(t, e) { return t.e >= e && t.s <= e + a; } const n = t.get("scrollDataIndex", !0); const o = this.getContentGroup(); var a = this._containerGroup.__rectSize; var r = t.getOrient().index; var s = oN[r]; var l = aN[r]; const u = this._findTargetItemIndex(n); const h = o.children(); const c = h[u]; const d = h.length; const f = d ? 1 : 0; const p = {
        contentPosition: o.position.slice(), pageCount: f, pageIndex: f - 1, pagePrevDataIndex: null, pageNextDataIndex: null,
      }; if (!c) return p; const g = e(c); p.contentPosition[r] = -g.s; for (var m = u + 1, v = g, y = g, x = null; m <= d; ++m)(!(x = e(h[m])) && y.e > v.s + a || x && !i(x, v.s)) && (v = y.i > v.i ? y : x) && (p.pageNextDataIndex == null && (p.pageNextDataIndex = v.i), ++p.pageCount), y = x; for (var m = u - 1, v = g, y = g, x = null; m >= -1; --m)(x = e(h[m])) && i(y, x.s) || !(v.i < y.i) || (y = v, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = v.i), ++p.pageCount, ++p.pageIndex), v = x; return p;
    },
    _findTargetItemIndex(t) { let e; const i = this.getContentGroup(); return this._showController ? i.eachChild((i, n) => { i.__legendDataIndex === t && (e = n); }) : e = 0, e; },
  }); Os("legendScroll", "legendscroll", (t, e) => { const i = t.scrollDataIndex; i != null && e.eachComponent({ mainType: "legend", subType: "scroll", query: t }, (t) => { t.setScrollDataIndex(i); }); }), Gs({
    type: "tooltip",
    dependencies: ["axisPointer"],
    defaultOption: {
      zlevel: 0,
      z: 60,
      show: !0,
      showContent: !0,
      trigger: "item",
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      confine: !1,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "rgba(50,50,50,0.7)",
      borderColor: "#333",
      borderRadius: 4,
      borderWidth: 0,
      padding: 5,
      extraCssText: "",
      axisPointer: {
        type: "line",
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999", width: 1, type: "dashed", textStyle: {},
        },
      },
      textStyle: { color: "#fff", fontSize: 14 },
    },
  }); var sN = d; var lN = ta; var uN = ["", "-webkit-", "-moz-", "-o-"]; Cv.prototype = {
    constructor: Cv, _enterable: !0, update() { const t = this._container; const e = t.currentStyle || document.defaultView.getComputedStyle(t); const i = t.style; i.position !== "absolute" && e.position !== "absolute" && (i.position = "relative"); }, show(t) { clearTimeout(this._hideTimeout); const e = this.el; e.style.cssText = `position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;${Dv(t)};left:${this._x}px;top:${this._y}px;${t.get("extraCssText") || ""}`, e.style.display = e.innerHTML ? "block" : "none", e.style.pointerEvents = this._enterable ? "auto" : "none", this._show = !0; }, setContent(t) { this.el.innerHTML = t == null ? "" : t; }, setEnterable(t) { this._enterable = t; }, getSize() { const t = this.el; return [t.clientWidth, t.clientHeight]; }, moveTo(t, e) { let i; const n = this._zr; n && n.painter && (i = n.painter.getViewportRootOffset()) && (t += i.offsetLeft, e += i.offsetTop); const o = this.el.style; o.left = `${t}px`, o.top = `${e}px`, this._x = t, this._y = e; }, hide() { this.el.style.display = "none", this._show = !1; }, hideLater(t) { !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(m(this.hide, this), t)) : this.hide()); }, isShow() { return this._show; }, getOuterSize() { let t = this.el.clientWidth; let e = this.el.clientHeight; if (document.defaultView && document.defaultView.getComputedStyle) { const i = document.defaultView.getComputedStyle(this.el); i && (t += parseInt(i.paddingLeft, 10) + parseInt(i.paddingRight, 10) + parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10), e += parseInt(i.paddingTop, 10) + parseInt(i.paddingBottom, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10)); } return { width: t, height: e }; },
  }, Lv.prototype = {
    constructor: Lv,
    _enterable: !0,
    update() {},
    show(t) { this._hideTimeout && clearTimeout(this._hideTimeout), this.el.attr("show", !0), this._show = !0; },
    setContent(t, e, i) {
      this.el && this._zr.remove(this.el); for (var n = {}, o = t, a = o.indexOf("{marker"); a >= 0;) {
        const r = o.indexOf("|}"); const s = o.substr(a + "{marker".length, r - a - "{marker".length); s.indexOf("sub") > -1 ? n[`marker${s}`] = {
          textWidth: 4, textHeight: 4, textBorderRadius: 2, textBackgroundColor: e[s], textOffset: [3, 0],
        } : n[`marker${s}`] = {
          textWidth: 10, textHeight: 10, textBorderRadius: 5, textBackgroundColor: e[s],
        }, a = (o = o.substr(r + 1)).indexOf("{marker");
      } this.el = new rM({
        style: {
          rich: n, text: t, textLineHeight: 20, textBackgroundColor: i.get("backgroundColor"), textBorderRadius: i.get("borderRadius"), textFill: i.get("textStyle.color"), textPadding: i.get("padding"),
        },
        z: i.get("z"),
      }), this._zr.add(this.el); const l = this; this.el.on("mouseover", () => { l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0; }), this.el.on("mouseout", () => { l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1; });
    },
    setEnterable(t) { this._enterable = t; },
    getSize() { const t = this.el.getBoundingRect(); return [t.width, t.height]; },
    moveTo(t, e) { this.el && this.el.attr("position", [t, e]); },
    hide() { this.el.hide(), this._show = !1; },
    hideLater(t) { !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(m(this.hide, this), t)) : this.hide()); },
    isShow() { return this._show; },
    getOuterSize() { return this.getSize(); },
  }; const hN = m; const cN = d; const dN = Bo; const fN = new yM({
    shape: {
      x: -1, y: -1, width: 2, height: 2,
    },
  }); Fs({
    type: "tooltip",
    init(t, e) { if (!U_.node) { const i = t.getComponent("tooltip").get("renderMode"); this._renderMode = Hi(i); let n; this._renderMode === "html" ? (n = new Cv(e.getDom(), e), this._newLine = "<br/>") : (n = new Lv(e), this._newLine = "\n"), this._tooltipContent = n; } },
    render(t, e, i) { if (!U_.node) { this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent"); const n = this._tooltipContent; n.update(), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(); } },
    _initGlobalListener() { const t = this._tooltipModel.get("triggerOn"); um("itemTooltip", this._api, hN(function (e, i, n) { t !== "none" && (t.indexOf(e) >= 0 ? this._tryShow(i, n) : e === "leave" && this._hide(n)); }, this)); },
    _keepShow() { const t = this._tooltipModel; const e = this._ecModel; const i = this._api; if (this._lastX != null && this._lastY != null && t.get("triggerOn") !== "none") { const n = this; clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(() => { n.manuallyShowTip(t, e, i, { x: n._lastX, y: n._lastY }); }); } },
    manuallyShowTip(t, e, i, n) {
      if (n.from !== this.uid && !U_.node) {
        const o = Pv(n, i); this._ticket = ""; const a = n.dataByCoordSys; if (n.tooltip && n.x != null && n.y != null) { const r = fN; r.position = [n.x, n.y], r.update(), r.tooltip = n.tooltip, this._tryShow({ offsetX: n.x, offsetY: n.y, target: r }, o); } else if (a) {
          this._tryShow({
            offsetX: n.x, offsetY: n.y, position: n.position, event: {}, dataByCoordSys: n.dataByCoordSys, tooltipOption: n.tooltipOption,
          }, o);
        } else if (n.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, e, i, n)) return; const s = _P(n, e); const l = s.point[0]; const u = s.point[1]; l != null && u != null && this._tryShow({
            offsetX: l, offsetY: u, position: n.position, target: s.el, event: {},
          }, o);
        } else {
          n.x != null && n.y != null && (i.dispatchAction({ type: "updateAxisPointer", x: n.x, y: n.y }), this._tryShow({
            offsetX: n.x, offsetY: n.y, position: n.position, target: i.getZr().findHover(n.x, n.y).target, event: {},
          }, o));
        }
      }
    },
    manuallyHideTip(t, e, i, n) { const o = this._tooltipContent; !this._alwaysShowContent && this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = null, n.from !== this.uid && this._hide(Pv(n, i)); },
    _manuallyAxisShowTip(t, e, i, n) {
      const o = n.seriesIndex; const a = n.dataIndex; const r = e.getComponent("axisPointer").coordSysAxesInfo; if (o != null && a != null && r != null) {
        const s = e.getSeriesByIndex(o); if (s && (t = kv([s.getData().getItemModel(a), s, (s.coordinateSystem || {}).model, t])).get("trigger") === "axis") {
          return i.dispatchAction({
            type: "updateAxisPointer", seriesIndex: o, dataIndex: a, position: n.position,
          }), !0;
        }
      }
    },
    _tryShow(t, e) { const i = t.target; if (this._tooltipModel) { this._lastX = t.offsetX, this._lastY = t.offsetY; const n = t.dataByCoordSys; n && n.length ? this._showAxisTooltip(n, t) : i && i.dataIndex != null ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e)); } },
    _showOrMove(t, e) { const i = t.get("showDelay"); e = m(e, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(e, i) : e(); },
    _showAxisTooltip(t, e) { const i = this._ecModel; const o = this._tooltipModel; const a = [e.offsetX, e.offsetY]; let r = []; const s = []; const l = kv([e.tooltipOption, o]); const u = this._renderMode; const h = this._newLine; const c = {}; cN(t, (t) => { cN(t.dataByAxis, (t) => { const e = i.getComponent(`${t.axisDim}Axis`, t.axisIndex); const o = t.value; const a = []; if (e && o != null) { const l = Im(o, e.axis, i, t.seriesDataIndices, t.valueLabelOpt); d(t.seriesDataIndices, (r) => { const h = i.getSeriesByIndex(r.seriesIndex); const d = r.dataIndexInside; const f = h && h.getDataParams(d); if (f.axisDim = t.axisDim, f.axisIndex = t.axisIndex, f.axisType = t.axisType, f.axisId = t.axisId, f.axisValue = Ul(e.axis, o), f.axisValueLabel = l, f) { s.push(f); let p; const g = h.formatTooltip(d, !0, null, u); if (w(g)) { p = g.html; const m = g.markers; n(c, m); } else p = g; a.push(p); } }); const f = l; u !== "html" ? r.push(a.join(h)) : r.push((f ? ea(f) + h : "") + a.join(h)); } }); }, this), r.reverse(), r = r.join(this._newLine + this._newLine); const f = e.position; this._showOrMove(l, function () { this._updateContentNotChangedOnAxis(t) ? this._updatePosition(l, f, a[0], a[1], this._tooltipContent, s) : this._showTooltipContent(l, r, s, Math.random(), a[0], a[1], f, void 0, c); }); },
    _showSeriesItemTooltip(t, e, i) {
      const n = this._ecModel; const o = e.seriesIndex; const a = n.getSeriesByIndex(o); const r = e.dataModel || a; const s = e.dataIndex; const l = e.dataType; const u = r.getData(); const h = kv([u.getItemModel(s), r, a && (a.coordinateSystem || {}).model, this._tooltipModel]); const c = h.get("trigger"); if (c == null || c === "item") {
        let d; let f; const p = r.getDataParams(s, l); const g = r.formatTooltip(s, !1, l, this._renderMode); w(g) ? (d = g.html, f = g.markers) : (d = g, f = null); const m = `item_${r.name}_${s}`; this._showOrMove(h, function () { this._showTooltipContent(h, d, p, m, t.offsetX, t.offsetY, t.position, t.target, f); }), i({
          type: "showTip", dataIndexInside: s, dataIndex: u.getRawIndex(s), seriesIndex: o, from: this.uid,
        });
      }
    },
    _showComponentItemTooltip(t, e, i) { let n = e.tooltip; if (typeof n === "string") { const o = n; n = { content: o, formatter: o }; } const a = new Po(n, this._tooltipModel, this._ecModel); const r = a.get("content"); const s = Math.random(); this._showOrMove(a, function () { this._showTooltipContent(a, r, a.get("formatterParams") || {}, s, t.offsetX, t.offsetY, t.position, e); }), i({ type: "showTip", from: this.uid }); },
    _showTooltipContent(t, e, i, n, o, a, r, s, l) { if (this._ticket = "", t.get("showContent") && t.get("show")) { const u = this._tooltipContent; const h = t.get("formatter"); r = r || t.get("position"); let c = e; if (h && typeof h === "string")c = ia(h, i, !0); else if (typeof h === "function") { const d = hN(function (e, n) { e === this._ticket && (u.setContent(n, l, t), this._updatePosition(t, r, o, a, u, i, s)); }, this); this._ticket = n, c = h(i, n, d); }u.setContent(c, l, t), u.show(t), this._updatePosition(t, r, o, a, u, i, s); } },
    _updatePosition(t, e, i, n, o, a, r) { const s = this._api.getWidth(); const l = this._api.getHeight(); e = e || t.get("position"); const u = o.getSize(); let h = t.get("align"); let c = t.get("verticalAlign"); const d = r && r.getBoundingRect().clone(); if (r && d.applyTransform(r.transform), typeof e === "function" && (e = e([i, n], a, o.el, d, { viewSize: [s, l], contentSize: u.slice() })), y(e))i = dN(e[0], s), n = dN(e[1], l); else if (w(e)) { e.width = u[0], e.height = u[1]; const f = ha(e, { width: s, height: l }); i = f.x, n = f.y, h = null, c = null; } else typeof e === "string" && r ? (i = (p = Ev(e, d, u))[0], n = p[1]) : (i = (p = Nv(i, n, o, s, l, h ? null : 20, c ? null : 20))[0], n = p[1]); if (h && (i -= Rv(h) ? u[0] / 2 : h === "right" ? u[0] : 0), c && (n -= Rv(c) ? u[1] / 2 : c === "bottom" ? u[1] : 0), t.get("confine")) { var p = Ov(i, n, o, s, l); i = p[0], n = p[1]; }o.moveTo(i, n); },
    _updateContentNotChangedOnAxis(t) { const e = this._lastDataByCoordSys; let i = !!e && e.length === t.length; return i && cN(e, (e, n) => { const o = e.dataByAxis || {}; const a = (t[n] || {}).dataByAxis || []; (i &= o.length === a.length) && cN(o, (t, e) => { const n = a[e] || {}; const o = t.seriesDataIndices || []; const r = n.seriesDataIndices || []; (i &= t.value === n.value && t.axisType === n.axisType && t.axisId === n.axisId && o.length === r.length) && cN(o, (t, e) => { const n = r[e]; i &= t.seriesIndex === n.seriesIndex && t.dataIndex === n.dataIndex; }); }); }), this._lastDataByCoordSys = t, !!i; },
    _hide(t) { this._lastDataByCoordSys = null, t({ type: "hideTip", from: this.uid }); },
    dispose(t, e) { U_.node || (this._tooltipContent.hide(), gm("itemTooltip", e)); },
  }), Os({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, () => {}), Os({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, () => {}), Gv.prototype = {
    constructor: Gv, pointToData(t, e) { return this.polar.pointToData(t, e)[this.dim === "radius" ? 0 : 1]; }, dataToRadius: rD.prototype.dataToCoord, radiusToData: rD.prototype.coordToData,
  }, u(Gv, rD); const pN = Bi(); Fv.prototype = {
    constructor: Fv, pointToData(t, e) { return this.polar.pointToData(t, e)[this.dim === "radius" ? 0 : 1]; }, dataToAngle: rD.prototype.dataToCoord, angleToData: rD.prototype.coordToData, calculateCategoryInterval() { const t = this; const e = t.getLabelModel(); const i = t.scale; const n = i.getExtent(); const o = i.count(); if (n[1] - n[0] < 1) return 0; const a = n[0]; const r = t.dataToCoord(a + 1) - t.dataToCoord(a); const s = Math.abs(r); const l = ke(a, e.getFont(), "center", "top"); let u = Math.max(l.height, 7) / s; isNaN(u) && (u = 1 / 0); let h = Math.max(0, Math.floor(u)); const c = pN(t.model); const d = c.lastAutoInterval; const f = c.lastTickCount; return d != null && f != null && Math.abs(d - h) <= 1 && Math.abs(f - o) <= 1 && d > h ? h = d : (c.lastTickCount = o, c.lastAutoInterval = h), h; },
  }, u(Fv, rD); const gN = function (t) { this.name = t || "", this.cx = 0, this.cy = 0, this._radiusAxis = new Gv(), this._angleAxis = new Fv(), this._radiusAxis.polar = this._angleAxis.polar = this; }; gN.prototype = {
    type: "polar", axisPointerEnabled: !0, constructor: gN, dimensions: ["radius", "angle"], model: null, containPoint(t) { const e = this.pointToCoord(t); return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]); }, containData(t) { return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]); }, getAxis(t) { return this[`_${t}Axis`]; }, getAxes() { return [this._radiusAxis, this._angleAxis]; }, getAxesByScale(t) { const e = []; const i = this._angleAxis; const n = this._radiusAxis; return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e; }, getAngleAxis() { return this._angleAxis; }, getRadiusAxis() { return this._radiusAxis; }, getOtherAxis(t) { const e = this._angleAxis; return t === e ? this._radiusAxis : e; }, getBaseAxis() { return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis(); }, getTooltipAxes(t) { const e = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis(); return { baseAxes: [e], otherAxes: [this.getOtherAxis(e)] }; }, dataToPoint(t, e) { return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)]); }, pointToData(t, e) { const i = this.pointToCoord(t); return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)]; }, pointToCoord(t) { let e = t[0] - this.cx; let i = t[1] - this.cy; const n = this.getAngleAxis(); const o = n.getExtent(); let a = Math.min(o[0], o[1]); let r = Math.max(o[0], o[1]); n.inverse ? a = r - 360 : r = a + 360; const s = Math.sqrt(e * e + i * i); e /= s, i /= s; for (var l = Math.atan2(-i, e) / Math.PI * 180, u = l < a ? 1 : -1; l < a || l > r;)l += 360 * u; return [s, l]; }, coordToPoint(t) { const e = t[0]; const i = t[1] / 180 * Math.PI; return [Math.cos(i) * e + this.cx, -Math.sin(i) * e + this.cy]; },
  }; const mN = uI.extend({ type: "polarAxis", axis: null, getCoordSysModel() { return this.ecModel.queryComponents({ mainType: "polar", index: this.option.polarIndex, id: this.option.polarId })[0]; } }); n(mN.prototype, XA); const vN = {
    angle: {
      startAngle: 90, clockwise: !0, splitNumber: 12, axisLabel: { rotate: !1 },
    },
    radius: { splitNumber: 5 },
  }; RD("angle", mN, Wv, vN.angle), RD("radius", mN, Wv, vN.radius), Gs({
    type: "polar",
    dependencies: ["polarAxis", "angleAxis"],
    coordinateSystem: null,
    findAxisModel(t) { let e; return this.ecModel.eachComponent(t, function (t) { t.getCoordSysModel() === this && (e = t); }, this), e; },
    defaultOption: {
      zlevel: 0, z: 0, center: ["50%", "50%"], radius: "80%",
    },
  }); const yN = { dimensions: gN.prototype.dimensions, create(t, e) { const i = []; return t.eachComponent("polar", (t, n) => { const o = new gN(n); o.update = Zv; const a = o.getRadiusAxis(); const r = o.getAngleAxis(); const s = t.findAxisModel("radiusAxis"); const l = t.findAxisModel("angleAxis"); Uv(a, s), Uv(r, l), Hv(o, t, e), i.push(o), t.coordinateSystem = o, o.model = t; }), t.eachSeries((e) => { if (e.get("coordinateSystem") === "polar") { const i = t.queryComponents({ mainType: "polar", index: e.get("polarIndex"), id: e.get("polarId") })[0]; e.coordinateSystem = i.coordinateSystem; } }), i; } }; Ga.register("polar", yN); const xN = ["axisLine", "axisLabel", "axisTick", "splitLine", "splitArea"]; jD.extend({
    type: "angleAxis",
    axisPointerClass: "PolarAxisPointer",
    render(t, e) { if (this.group.removeAll(), t.get("show")) { const n = t.axis; const o = n.polar; const a = o.getRadiusAxis().getExtent(); const r = n.getTicksCoords(); const s = f(n.getViewLabels(), t => (t = i(t)).coord = n.dataToCoord(t.tickValue), t); Yv(s), Yv(r), d(xN, function (e) { !t.get(`${e}.show`) || n.scale.isBlank() && e !== "axisLine" || this[`_${e}`](t, o, r, a, s); }, this); } },
    _axisLine(t, e, i, n) {
      const o = t.getModel("axisLine.lineStyle"); const a = new sM({
        shape: { cx: e.cx, cy: e.cy, r: n[jv(e)] }, style: o.getLineStyle(), z2: 1, silent: !0,
      }); a.style.fill = null, this.group.add(a);
    },
    _axisTick(t, e, i, n) { const o = t.getModel("axisTick"); const a = (o.get("inside") ? -1 : 1) * o.get("length"); const s = n[jv(e)]; const l = f(i, t => new _M({ shape: Xv(e, [s, s + a], t.coord) })); this.group.add(OM(l, { style: r(o.getModel("lineStyle").getLineStyle(), { stroke: t.get("axisLine.lineStyle.color") }) })); },
    _axisLabel(t, e, i, n, o) {
      const a = t.getCategories(!0); const r = t.getModel("axisLabel"); const s = r.get("margin"); d(o, function (i, o) {
        let l = r; const u = i.tickValue; const h = n[jv(e)]; const c = e.coordToPoint([h + s, i.coord]); const d = e.cx; const f = e.cy; const p = Math.abs(c[0] - d) / h < 0.3 ? "center" : c[0] > d ? "left" : "right"; const g = Math.abs(c[1] - f) / h < 0.3 ? "middle" : c[1] > f ? "top" : "bottom"; a && a[u] && a[u].textStyle && (l = new Po(a[u].textStyle, r, r.ecModel)); const m = new rM({ silent: !0 }); this.group.add(m), go(m.style, l, {
          x: c[0], y: c[1], textFill: l.getTextColor() || t.get("axisLine.lineStyle.color"), text: i.formattedLabel, textAlign: p, textVerticalAlign: g,
        });
      }, this);
    },
    _splitLine(t, e, i, n) { const o = t.getModel("splitLine").getModel("lineStyle"); let a = o.get("color"); let s = 0; a = a instanceof Array ? a : [a]; for (var l = [], u = 0; u < i.length; u++) { const h = s++ % a.length; l[h] = l[h] || [], l[h].push(new _M({ shape: Xv(e, n, i[u].coord) })); } for (u = 0; u < l.length; u++) this.group.add(OM(l[u], { style: r({ stroke: a[u % a.length] }, o.getLineStyle()), silent: !0, z: t.get("z") })); },
    _splitArea(t, e, i, n) {
      if (i.length) {
        const o = t.getModel("splitArea").getModel("areaStyle"); let a = o.get("color"); let s = 0; a = a instanceof Array ? a : [a]; for (var l = [], u = Math.PI / 180, h = -i[0].coord * u, c = Math.min(n[0], n[1]), d = Math.max(n[0], n[1]), f = t.get("clockwise"), p = 1; p < i.length; p++) {
          const g = s++ % a.length; l[g] = l[g] || [], l[g].push(new hM({
            shape: {
              cx: e.cx, cy: e.cy, r0: c, r: d, startAngle: h, endAngle: -i[p].coord * u, clockwise: f,
            },
            silent: !0,
          })), h = -i[p].coord * u;
        } for (p = 0; p < l.length; p++) this.group.add(OM(l[p], { style: r({ fill: a[p % a.length] }, o.getAreaStyle()), silent: !0 }));
      }
    },
  }); const _N = ["axisLine", "axisTickLabel", "axisName"]; const wN = ["splitLine", "splitArea"]; jD.extend({
    type: "radiusAxis",
    axisPointerClass: "PolarAxisPointer",
    render(t, e) { if (this.group.removeAll(), t.get("show")) { const i = t.axis; const n = i.polar; const o = n.getAngleAxis(); const a = i.getTicksCoords(); const r = o.getExtent()[0]; const s = i.getExtent(); const l = qv(n, t, r); const u = new WD(t, l); d(_N, u.add, u), this.group.add(u.getGroup()), d(wN, function (e) { t.get(`${e}.show`) && !i.scale.isBlank() && this[`_${e}`](t, n, r, s, a); }, this); } },
    _splitLine(t, e, i, n, o) { const a = t.getModel("splitLine").getModel("lineStyle"); let s = a.get("color"); let l = 0; s = s instanceof Array ? s : [s]; for (var u = [], h = 0; h < o.length; h++) { const c = l++ % s.length; u[c] = u[c] || [], u[c].push(new sM({ shape: { cx: e.cx, cy: e.cy, r: o[h].coord }, silent: !0 })); } for (h = 0; h < u.length; h++) this.group.add(OM(u[h], { style: r({ stroke: s[h % s.length], fill: null }, a.getLineStyle()), silent: !0 })); },
    _splitArea(t, e, i, n, o) {
      if (o.length) {
        const a = t.getModel("splitArea").getModel("areaStyle"); let s = a.get("color"); let l = 0; s = s instanceof Array ? s : [s]; for (var u = [], h = o[0].coord, c = 1; c < o.length; c++) {
          const d = l++ % s.length; u[d] = u[d] || [], u[d].push(new hM({
            shape: {
              cx: e.cx, cy: e.cy, r0: h, r: o[c].coord, startAngle: 0, endAngle: 2 * Math.PI,
            },
            silent: !0,
          })), h = o[c].coord;
        } for (c = 0; c < u.length; c++) this.group.add(OM(u[c], { style: r({ fill: s[c % s.length] }, a.getAreaStyle()), silent: !0 }));
      }
    },
  }); const bN = mm.extend({ makeElOption(t, e, i, n, o) { const a = i.axis; a.dim === "angle" && (this.animationThreshold = Math.PI / 18); let r; const s = a.polar; const l = s.getOtherAxis(a).getExtent(); r = a[`dataTo${sa(a.dim)}`](e); const u = n.get("type"); if (u && u !== "none") { const h = bm(n); const c = SN[u](a, s, r, l, h); c.style = h, t.graphicKey = c.type, t.pointer = c; }Sm(t, i, n, o, Kv(e, i, 0, s, n.get("label.margin"))); } }); var SN = { line(t, e, i, n, o) { return t.dim === "angle" ? { type: "Line", shape: Dm(e.coordToPoint([n[0], i]), e.coordToPoint([n[1], i])) } : { type: "Circle", shape: { cx: e.cx, cy: e.cy, r: i } }; }, shadow(t, e, i, n, o) { const a = Math.max(1, t.getBandWidth()); const r = Math.PI / 180; return t.dim === "angle" ? { type: "Sector", shape: Lm(e.cx, e.cy, n[0], n[1], (-i - a / 2) * r, (a / 2 - i) * r) } : { type: "Sector", shape: Lm(e.cx, e.cy, i - a / 2, i + a / 2, 0, 2 * Math.PI) }; } }; jD.registerAxisPointerClass("PolarAxisPointer", bN), Rs(v(function (t, e, i) {
    i.getWidth(), i.getHeight(); const n = {}; const o = Vv(g(e.getSeriesByType(t), t => !e.isSeriesFiltered(t) && t.coordinateSystem && t.coordinateSystem.type === "polar")); e.eachSeriesByType(t, (t) => {
      if (t.coordinateSystem.type === "polar") {
        const e = t.getData(); const i = t.coordinateSystem; const a = i.getBaseAxis(); const r = zv(t); const s = o[Bv(a)][r]; const l = s.offset; const u = s.width; const h = i.getOtherAxis(a); const c = t.coordinateSystem.cx; const d = t.coordinateSystem.cy; const f = t.get("barMinHeight") || 0; const p = t.get("barMinAngle") || 0; n[r] = n[r] || []; for (let g = e.mapDimension(h.dim), m = e.mapDimension(a.dim), v = fl(e, g), y = h.getExtent()[0], x = 0, _ = e.count(); x < _; x++) {
          const w = e.get(g, x); const b = e.get(m, x); if (!isNaN(w)) {
            const S = w >= 0 ? "p" : "n"; let M = y; v && (n[r][b] || (n[r][b] = { p: y, n: y }), M = n[r][b][S]); var I; var T; var A; var D; if (h.dim === "radius") { let C = h.dataToRadius(w) - y; const L = a.dataToAngle(b); Math.abs(C) < f && (C = (C < 0 ? -1 : 1) * f), I = M, T = M + C, D = (A = L - l) - u, v && (n[r][b][S] = T); } else { let k = h.dataToAngle(w, !0) - y; const P = a.dataToRadius(b); Math.abs(k) < p && (k = (k < 0 ? -1 : 1) * p), T = (I = P + l) + u, A = M, D = M + k, v && (n[r][b][S] = D); }e.setItemLayout(x, {
              cx: c, cy: d, r0: I, r: T, startAngle: -A * Math.PI / 180, endAngle: -D * Math.PI / 180,
            });
          }
        }
      }
    }, this);
  }, "bar")), Fs({ type: "polar" }), h(uI.extend({
    type: "geo",
    coordinateSystem: null,
    layoutMode: "box",
    init(t) { uI.prototype.init.apply(this, arguments), Ci(t, "label", ["show"]); },
    optionUpdated() { const t = this.option; const e = this; t.regions = FC.getFilledRegions(t.regions, t.map, t.nameMap), this._optionModelMap = p(t.regions || [], (t, i) => i.name && t.set(i.name, new Po(i, e)), t, R()), this.updateSelectedMap(t.regions); },
    defaultOption: {
      zlevel: 0, z: 0, show: !0, left: "center", top: "center", aspectScale: null, silent: !1, map: "", boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: !1, color: "#000" }, itemStyle: { borderWidth: 0.5, borderColor: "#444", color: "#eee" }, emphasis: { label: { show: !0, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, regions: [],
    },
    getRegionModel(t) { return this._optionModelMap.get(t) || new Po(null, this, this.ecModel); },
    getFormattedLabel(t, e) { const i = this.getRegionModel(t).get(`label.${e}.formatter`); const n = { name: t }; return typeof i === "function" ? (n.status = e, i(n)) : typeof i === "string" ? i.replace("{a}", t != null ? t : "") : void 0; },
    setZoom(t) { this.option.zoom = t; },
    setCenter(t) { this.option.center = t; },
  }), rC), Fs({
    type: "geo", init(t, e) { const i = new yc(e, !0); this._mapDraw = i, this.group.add(i.group); }, render(t, e, i, n) { if (!n || n.type !== "geoToggleSelect" || n.from !== this.uid) { const o = this._mapDraw; t.get("show") ? o.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(), this.group.silent = t.get("silent"); } }, dispose() { this._mapDraw && this._mapDraw.remove(); },
  }), $v("toggleSelected", { type: "geoToggleSelect", event: "geoselectchanged" }), $v("select", { type: "geoSelect", event: "geoselected" }), $v("unSelect", { type: "geoUnSelect", event: "geounselected" }); const MN = ["rect", "polygon", "keep", "clear"]; var IN = d; var TN = {
    lineX: oy(0), lineY: oy(1), rect: { point(t, e, i) { return t && i.boundingRect.contain(t[0], t[1]); }, rect(t, e, i) { return t && i.boundingRect.intersect(t); } }, polygon: { point(t, e, i) { return t && i.boundingRect.contain(t[0], t[1]) && Ql(i.range, t[0], t[1]); }, rect(t, e, i) { const n = i.range; if (!t || n.length <= 1) return !1; const o = t.x; const a = t.y; const r = t.width; const s = t.height; const l = n[0]; return !!(Ql(n, o, a) || Ql(n, o + r, a) || Ql(n, o, a + s) || Ql(n, o + r, a + s) || de.create(t).contain(l[0], l[1]) || ry(o, a, o + r, a, n) || ry(o, a, o, a + s, n) || ry(o + r, a, o + r, a + s, n) || ry(o, a + s, o + r, a + s, n)) || void 0; } },
  }; var AN = d; var DN = l; const CN = v; const LN = ["dataToPoint", "pointToData"]; var kN = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"]; const PN = hy.prototype; PN.setOutputRanges = function (t, e) { this.matchOutputRanges(t, e, (t, e, i) => { if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) { t.coordRange = e; const n = RN[t.brushType](0, i, e); t.__rangeOffset = { offset: zN[t.brushType](n.values, t.range, [1, 1]), xyMinMax: n.xyMinMax }; } }); }, PN.matchOutputRanges = function (t, e, i) { AN(t, function (t) { const n = this.findTargetInfo(t, e); n && !0 !== n && d(n.coordSyses, (n) => { const o = RN[t.brushType](1, n, t.range); i(t, o.values, n, e); }); }, this); }, PN.setInputRanges = function (t, e) { AN(t, function (t) { const i = this.findTargetInfo(t, e); if (t.range = t.range || [], i && !0 !== i) { t.panelId = i.panelId; const n = RN[t.brushType](0, i.coordSys, t.coordRange); const o = t.__rangeOffset; t.range = o ? zN[t.brushType](n.values, o.offset, gy(n.xyMinMax, o.xyMinMax)) : n.values; } }, this); }, PN.makePanelOpts = function (t, e) {
    return f(this._targetInfoList, (i) => {
      const n = i.getPanelRect(); return {
        panelId: i.panelId, defaultBrushType: e && e(i), clipPath: vp(n), isTargetByCursor: xp(n, t, i.coordSysModel), getLinearBrushOtherExtent: yp(n),
      };
    });
  }, PN.controlSeries = function (t, e, i) { const n = this.findTargetInfo(t, i); return !0 === n || n && DN(n.coordSyses, e.coordinateSystem) >= 0; }, PN.findTargetInfo = function (t, e) { for (let i = this._targetInfoList, n = dy(e, t), o = 0; o < i.length; o++) { const a = i[o]; const r = t.panelId; if (r) { if (a.panelId === r) return a; } else for (o = 0; o < ON.length; o++) if (ON[o](n, a)) return a; } return !0; }; var NN = {
    grid(t, e) {
      const i = t.xAxisModels; const n = t.yAxisModels; const o = t.gridModels; const a = R(); const r = {}; const s = {}; (i || n || o) && (AN(i, (t) => { const e = t.axis.grid.model; a.set(e.id, e), r[e.id] = !0; }), AN(n, (t) => { const e = t.axis.grid.model; a.set(e.id, e), s[e.id] = !0; }), AN(o, (t) => { a.set(t.id, t), r[t.id] = !0, s[t.id] = !0; }), a.each((t) => {
        const o = t.coordinateSystem; const a = []; AN(o.getCartesians(), (t, e) => { (DN(i, t.getAxis("x").model) >= 0 || DN(n, t.getAxis("y").model) >= 0) && a.push(t); }), e.push({
          panelId: `grid--${t.id}`, gridModel: t, coordSysModel: t, coordSys: a[0], coordSyses: a, getPanelRect: EN.grid, xAxisDeclared: r[t.id], yAxisDeclared: s[t.id],
        });
      }));
    },
    geo(t, e) {
      AN(t.geoModels, (t) => {
        const i = t.coordinateSystem; e.push({
          panelId: `geo--${t.id}`, geoModel: t, coordSysModel: t, coordSys: i, coordSyses: [i], getPanelRect: EN.geo,
        });
      });
    },
  }; var ON = [function (t, e) { const i = t.xAxisModel; const n = t.yAxisModel; let o = t.gridModel; return !o && i && (o = i.axis.grid.model), !o && n && (o = n.axis.grid.model), o && o === e.gridModel; }, function (t, e) { const i = t.geoModel; return i && i === e.geoModel; }]; var EN = { grid() { return this.coordSys.grid.getRect().clone(); }, geo() { const t = this.coordSys; const e = t.getBoundingRect().clone(); return e.applyTransform(To(t)), e; } }; var RN = {
    lineX: CN(fy, 0), lineY: CN(fy, 1), rect(t, e, i) { const n = e[LN[t]]([i[0][0], i[1][0]]); const o = e[LN[t]]([i[0][1], i[1][1]]); const a = [cy([n[0], o[0]]), cy([n[1], o[1]])]; return { values: a, xyMinMax: a }; }, polygon(t, e, i) { const n = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]]; return { values: f(i, (i) => { const o = e[LN[t]](i); return n[0][0] = Math.min(n[0][0], o[0]), n[1][0] = Math.min(n[1][0], o[1]), n[0][1] = Math.max(n[0][1], o[0]), n[1][1] = Math.max(n[1][1], o[1]), o; }), xyMinMax: n }; },
  }; var zN = {
    lineX: CN(py, 0), lineY: CN(py, 1), rect(t, e, i) { return [[t[0][0] - i[0] * e[0][0], t[0][1] - i[0] * e[0][1]], [t[1][0] - i[1] * e[1][0], t[1][1] - i[1] * e[1][1]]]; }, polygon(t, e, i) { return f(t, (t, n) => [t[0] - i[0] * e[n][0], t[1] - i[1] * e[n][1]]); },
  }; const BN = ["inBrush", "outOfBrush"]; var VN = "__ecBrushSelect"; var GN = "__ecInBrushSelectEvent"; const FN = GT.VISUAL.BRUSH; Rs(FN, (t, e, i) => { t.eachComponent({ mainType: "brush" }, (e) => { i && i.type === "takeGlobalCursor" && e.setBrushOption(i.key === "brush" ? i.brushOption : { brushType: !1 }), (e.brushTargetManager = new hy(e.option, t)).setInputRanges(e.areas, t); }); }), zs(FN, (t, e, n) => {
    let o; let a; const s = []; t.eachComponent({ mainType: "brush" }, (e, n) => {
      function l(t) { return m === "all" || v[t]; } function u(t) { return !!t.length; } function h(t, e) { const i = t.coordinateSystem; w |= i.hasAxisBrushed(), l(e) && i.eachActiveState(t.getData(), (t, e) => { t === "active" && (x[e] = 1); }); } function c(i, n, o) { const a = _y(i); if (a && !wy(e, n) && (d(b, (n) => { a[n.brushType] && e.brushTargetManager.controlSeries(n, i, t) && o.push(n), w |= u(o); }), l(n) && u(o))) { const r = i.getData(); r.each((t) => { xy(a, o, r, t) && (x[t] = 1); }); } } const p = {
        brushId: e.id, brushIndex: n, brushName: e.name, areas: i(e.areas), selected: [],
      }; s.push(p); const g = e.option; var m = g.brushLink; var v = []; var x = []; const _ = []; var w = 0; n || (o = g.throttleType, a = g.throttleDelay); var b = f(e.areas, t => by(r({ boundingRect: WN[t.brushType](t) }, t))); const S = ty(e.option, BN, (t) => { t.mappingMethod = "fixed"; }); y(m) && d(m, (t) => { v[t] = 1; }), t.eachSeries((t, e) => { const i = _[e] = []; t.subType === "parallel" ? h(t, e) : c(t, e, i); }), t.eachSeries((t, e) => {
        const i = {
          seriesId: t.id, seriesIndex: e, seriesName: t.name, dataIndex: [],
        }; p.selected.push(i); const n = _y(t); const o = _[e]; const a = t.getData(); const r = l(e) ? function (t) { return x[t] ? (i.dataIndex.push(a.getRawIndex(t)), "inBrush") : "outOfBrush"; } : function (t) { return xy(n, o, a, t) ? (i.dataIndex.push(a.getRawIndex(t)), "inBrush") : "outOfBrush"; }; (l(e) ? w : u(o)) && iy(BN, S, a, r);
      });
    }), vy(e, o, a, s, n);
  }); var WN = {
    lineX: B, lineY: B, rect(t) { return Sy(t.range); }, polygon(t) { for (var e, i = t.range, n = 0, o = i.length; n < o; n++) { e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]]; const a = i[n]; a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]); } return e && Sy(e); },
  }; const HN = ["#ddd"]; Gs({
    type: "brush",
    dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
    defaultOption: {
      toolbox: null, brushLink: null, seriesIndex: "all", geoIndex: null, xAxisIndex: null, yAxisIndex: null, brushType: "rect", brushMode: "single", transformable: !0, brushStyle: { borderWidth: 1, color: "rgba(120,140,180,0.3)", borderColor: "rgba(120,140,180,0.8)" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: !0, z: 1e4,
    },
    areas: [],
    brushType: null,
    brushOption: {},
    coordInfoList: [],
    optionUpdated(t, e) { const i = this.option; !e && ey(i, t, ["inBrush", "outOfBrush"]); const n = i.inBrush = i.inBrush || {}; i.outOfBrush = i.outOfBrush || { color: HN }, n.hasOwnProperty("liftZ") || (n.liftZ = 5); },
    setAreas(t) { t && (this.areas = f(t, function (t) { return My(this.option, t); }, this)); },
    setBrushOption(t) { this.brushOption = My(this.option, t), this.brushType = this.brushOption.brushType; },
  }); Fs({
    type: "brush",
    init(t, e) { this.ecModel = t, this.api = e, this.model, (this._brushController = new Rf(e.getZr())).on("brush", m(this._onBrush, this)).mount(); },
    render(t) { return this.model = t, Iy.apply(this, arguments); },
    updateTransform: Iy,
    updateView: Iy,
    dispose() { this._brushController.dispose(); },
    _onBrush(t, e) {
      const n = this.model.id; this.model.brushTargetManager.setOutputRanges(t, this.ecModel), (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({
        type: "brush", brushId: n, areas: i(t), $from: n,
      });
    },
  }), Os({ type: "brush", event: "brush" }, (t, e) => { e.eachComponent({ mainType: "brush", query: t }, (e) => { e.setAreas(t.areas); }); }), Os({ type: "brushSelect", event: "brushSelected", update: "none" }, () => {}); var ZN = {}; const UN = sT.toolbox.brush; Dy.defaultOption = {
    show: !0,
    type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
    icon: {
      rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2",
    },
    title: i(UN.title),
  }; const XN = Dy.prototype; XN.render = XN.updateView = function (t, e, i) { let n; let o; let a; e.eachComponent({ mainType: "brush" }, (t) => { n = t.brushType, o = t.brushOption.brushMode || "single", a |= t.areas.length; }), this._brushType = n, this._brushMode = o, d(t.get("type", !0), (e) => { t.setIconStatus(e, (e === "keep" ? o === "multiple" : e === "clear" ? a : e === n) ? "emphasis" : "normal"); }); }, XN.getIcons = function () { const t = this.model; const e = t.get("icon", !0); const i = {}; return d(t.get("type", !0), (t) => { e[t] && (i[t] = e[t]); }), i; }, XN.onclick = function (t, e, i) { const n = this._brushType; const o = this._brushMode; i === "clear" ? (e.dispatchAction({ type: "axisAreaSelect", intervals: [] }), e.dispatchAction({ type: "brush", command: "clear", areas: [] })) : e.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: i === "keep" ? n : n !== i && i, brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o } }); }, Ty("brush", Dy), Ps((t, e) => { let i = t && t.brush; if (y(i) || (i = i ? [i] : []), i.length) { let n = []; d(i, (t) => { const e = t.hasOwnProperty("toolbox") ? t.toolbox : []; e instanceof Array && (n = n.concat(e)); }); let o = t && t.toolbox; y(o) && (o = o[0]), o || (o = { feature: {} }, t.toolbox = [o]); const a = o.feature || (o.feature = {}); const r = a.brush || (a.brush = {}); const s = r.type || (r.type = []); s.push.apply(s, n), Jv(s), e && !s.length && s.push.apply(s, MN); } }); Cy.prototype = {
    constructor: Cy,
    type: "calendar",
    dimensions: ["time", "value"],
    getDimensionsInfo() { return [{ name: "time", type: "time" }, "value"]; },
    getRangeInfo() { return this._rangeInfo; },
    getModel() { return this._model; },
    getRect() { return this._rect; },
    getCellWidth() { return this._sw; },
    getCellHeight() { return this._sh; },
    getOrient() { return this._orient; },
    getFirstDayOfWeek() { return this._firstDayOfWeek; },
    getDateInfo(t) {
      const e = (t = jo(t)).getFullYear(); let i = t.getMonth() + 1; i = i < 10 ? `0${i}` : i; let n = t.getDate(); n = n < 10 ? `0${n}` : n; let o = t.getDay(); return o = Math.abs((o + 7 - this.getFirstDayOfWeek()) % 7), {
        y: e, m: i, d: n, day: o, time: t.getTime(), formatedDate: `${e}-${i}-${n}`, date: t,
      };
    },
    getNextNDay(t, e) { return (e = e || 0) === 0 ? this.getDateInfo(t) : ((t = new Date(this.getDateInfo(t).time)).setDate(t.getDate() + e), this.getDateInfo(t)); },
    update(t, e) { function i(t, e) { return t[e] != null && t[e] !== "auto"; } this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption()); const n = this._rangeInfo.weeks || 1; const o = ["width", "height"]; const a = this._model.get("cellSize").slice(); const r = this._model.getBoxLayoutParams(); const s = this._orient === "horizontal" ? [n, 7] : [7, n]; d([0, 1], (t) => { i(a, t) && (r[o[t]] = a[t] * s[t]); }); const l = { width: e.getWidth(), height: e.getHeight() }; const u = this._rect = ha(r, l); d([0, 1], (t) => { i(a, t) || (a[t] = u[o[t]] / s[t]); }), this._sw = a[0], this._sh = a[1]; },
    dataToPoint(t, e) { y(t) && (t = t[0]), e == null && (e = !0); const i = this.getDateInfo(t); const n = this._rangeInfo; const o = i.formatedDate; if (e && !(i.time >= n.start.time && i.time < n.end.time + 864e5)) return [NaN, NaN]; const a = i.day; const r = this._getRangeInfo([n.start.time, o]).nthWeek; return this._orient === "vertical" ? [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + r * this._sh + this._sh / 2] : [this._rect.x + r * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2]; },
    pointToData(t) { const e = this.pointToDate(t); return e && e.time; },
    dataToRect(t, e) {
      const i = this.dataToPoint(t, e); return {
        contentShape: {
          x: i[0] - (this._sw - this._lineWidth) / 2, y: i[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth,
        },
        center: i,
        tl: [i[0] - this._sw / 2, i[1] - this._sh / 2],
        tr: [i[0] + this._sw / 2, i[1] - this._sh / 2],
        br: [i[0] + this._sw / 2, i[1] + this._sh / 2],
        bl: [i[0] - this._sw / 2, i[1] + this._sh / 2],
      };
    },
    pointToDate(t) { const e = Math.floor((t[0] - this._rect.x) / this._sw) + 1; const i = Math.floor((t[1] - this._rect.y) / this._sh) + 1; const n = this._rangeInfo.range; return this._orient === "vertical" ? this._getDateByWeeksAndDay(i, e - 1, n) : this._getDateByWeeksAndDay(e, i - 1, n); },
    convertToPixel: v(Ly, "dataToPoint"),
    convertFromPixel: v(Ly, "pointToData"),
    _initRangeOption() { let t = this._model.get("range"); let e = t; if (y(e) && e.length === 1 && (e = e[0]), /^\d{4}$/.test(e) && (t = [`${e}-01-01`, `${e}-12-31`]), /^\d{4}[\/|-]\d{1,2}$/.test(e)) { const i = this.getDateInfo(e); const n = i.date; n.setMonth(n.getMonth() + 1); const o = this.getNextNDay(n, -1); t = [i.formatedDate, o.formatedDate]; }/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(e) && (t = [e, e]); const a = this._getRangeInfo(t); return a.start.time > a.end.time && t.reverse(), t; },
    _getRangeInfo(t) {
      let e; (t = [this.getDateInfo(t[0]), this.getDateInfo(t[1])])[0].time > t[1].time && (e = !0, t.reverse()); let i = Math.floor(t[1].time / 864e5) - Math.floor(t[0].time / 864e5) + 1; const n = new Date(t[0].time); const o = n.getDate(); const a = t[1].date.getDate(); if (n.setDate(o + i - 1), n.getDate() !== a) for (let r = n.getTime() - t[1].time > 0 ? 1 : -1; n.getDate() !== a && (n.getTime() - t[1].time) * r > 0;)i -= r, n.setDate(o + i - 1); const s = Math.floor((i + t[0].day + 6) / 7); const l = e ? 1 - s : s - 1; return e && t.reverse(), {
        range: [t[0].formatedDate, t[1].formatedDate], start: t[0], end: t[1], allDay: i, weeks: s, nthWeek: l, fweek: t[0].day, lweek: t[1].day,
      };
    },
    _getDateByWeeksAndDay(t, e, i) { const n = this._getRangeInfo(i); if (t > n.weeks || t === 0 && e < n.fweek || t === n.weeks && e > n.lweek) return !1; const o = 7 * (t - 1) - n.fweek + e; const a = new Date(n.start.time); return a.setDate(n.start.d + o), this.getDateInfo(a); },
  }, Cy.dimensions = Cy.prototype.dimensions, Cy.getDimensionsInfo = Cy.prototype.getDimensionsInfo, Cy.create = function (t, e) { const i = []; return t.eachComponent("calendar", (n) => { const o = new Cy(n, t, e); i.push(o), n.coordinateSystem = o; }), t.eachSeries((t) => { t.get("coordinateSystem") === "calendar" && (t.coordinateSystem = i[t.get("calendarIndex") || 0]); }), i; }, Ga.register("calendar", Cy); var jN = uI.extend({
    type: "calendar",
    coordinateSystem: null,
    defaultOption: {
      zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: "horizontal",
      splitLine: { show: !0, lineStyle: { color: "#000", width: 1, type: "solid" } },
      itemStyle: { color: "#fff", borderWidth: 1, borderColor: "#ccc" },
      dayLabel: {
        show: !0, firstDay: 0, position: "start", margin: "50%", nameMap: "en", color: "#000",
      },
      monthLabel: {
        show: !0, position: "start", margin: 5, align: "center", nameMap: "en", formatter: null, color: "#000",
      },
      yearLabel: {
        show: !0, position: null, margin: 30, formatter: null, color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20,
      },
    },
    init(t, e, i, n) { const o = pa(t); jN.superApply(this, "init", arguments), ky(t, o); },
    mergeOption(t, e) { jN.superApply(this, "mergeOption", arguments), ky(this.option, t); },
  }); const YN = { EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], CN: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"] }; const qN = { EN: ["S", "M", "T", "W", "T", "F", "S"], CN: ["日", "一", "二", "三", "四", "五", "六"] }; Fs({
    type: "calendar",
    _tlpoints: null,
    _blpoints: null,
    _firstDayOfMonth: null,
    _firstDayPoints: null,
    render(t, e, i) { const n = this.group; n.removeAll(); const o = t.coordinateSystem; const a = o.getRangeInfo(); const r = o.getOrient(); this._renderDayRect(t, a, n), this._renderLines(t, a, r, n), this._renderYearText(t, a, r, n), this._renderMonthText(t, r, n), this._renderWeekText(t, a, r, n); },
    _renderDayRect(t, e, i) {
      for (let n = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), a = n.getCellWidth(), r = n.getCellHeight(), s = e.start.time; s <= e.end.time; s = n.getNextNDay(s, 1).time) {
        const l = n.dataToRect([s], !1).tl; const u = new yM({
          shape: {
            x: l[0], y: l[1], width: a, height: r,
          },
          cursor: "default",
          style: o,
        }); i.add(u);
      }
    },
    _renderLines(t, e, i, n) { function o(e) { a._firstDayOfMonth.push(r.getDateInfo(e)), a._firstDayPoints.push(r.dataToRect([e], !1).tl); const o = a._getLinePointsOfOneWeek(t, e, i); a._tlpoints.push(o[0]), a._blpoints.push(o[o.length - 1]), l && a._drawSplitline(o, s, n); } var a = this; var r = t.coordinateSystem; var s = t.getModel("splitLine.lineStyle").getLineStyle(); var l = t.get("splitLine.show"); const u = s.lineWidth; this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = []; for (let h = e.start, c = 0; h.time <= e.end.time; c++) { o(h.formatedDate), c === 0 && (h = r.getDateInfo(`${e.start.y}-${e.start.m}`)); const d = h.date; d.setMonth(d.getMonth() + 1), h = r.getDateInfo(d); }o(r.getNextNDay(e.end.time, 1).formatedDate), l && this._drawSplitline(a._getEdgesPoints(a._tlpoints, u, i), s, n), l && this._drawSplitline(a._getEdgesPoints(a._blpoints, u, i), s, n); },
    _getEdgesPoints(t, e, i) { const n = [t[0].slice(), t[t.length - 1].slice()]; const o = i === "horizontal" ? 0 : 1; return n[0][o] = n[0][o] - e / 2, n[1][o] = n[1][o] + e / 2, n; },
    _drawSplitline(t, e, i) { const n = new gM({ z2: 20, shape: { points: t }, style: e }); i.add(n); },
    _getLinePointsOfOneWeek(t, e, i) { const n = t.coordinateSystem; e = n.getDateInfo(e); for (var o = [], a = 0; a < 7; a++) { const r = n.getNextNDay(e.time, a); const s = n.dataToRect([r.time], !1); o[2 * r.day] = s.tl, o[2 * r.day + 1] = s[i === "horizontal" ? "bl" : "tr"]; } return o; },
    _formatterLabel(t, e) { return typeof t === "string" && t ? na(t, e) : typeof t === "function" ? t(e) : e.nameMap; },
    _yearTextPositionControl(t, e, i, n, o) { e = e.slice(); let a = ["center", "bottom"]; n === "bottom" ? (e[1] += o, a = ["center", "top"]) : n === "left" ? e[0] -= o : n === "right" ? (e[0] += o, a = ["center", "top"]) : e[1] -= o; let r = 0; return n !== "left" && n !== "right" || (r = Math.PI / 2), { rotation: r, position: e, style: { textAlign: a[0], textVerticalAlign: a[1] } }; },
    _renderYearText(t, e, i, n) {
      const o = t.getModel("yearLabel"); if (o.get("show")) {
        const a = o.get("margin"); let r = o.get("position"); r || (r = i !== "horizontal" ? "top" : "left"); const s = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]]; const l = (s[0][0] + s[1][0]) / 2; const u = (s[0][1] + s[1][1]) / 2; const h = i === "horizontal" ? 0 : 1; const c = {
          top: [l, s[h][1]], bottom: [l, s[1 - h][1]], left: [s[1 - h][0], u], right: [s[h][0], u],
        }; let d = e.start.y; +e.end.y > +e.start.y && (d = `${d}-${e.end.y}`); const f = o.get("formatter"); const p = { start: e.start.y, end: e.end.y, nameMap: d }; const g = this._formatterLabel(f, p); const m = new rM({ z2: 30 }); go(m.style, o, { text: g }), m.attr(this._yearTextPositionControl(m, c[r], i, r, a)), n.add(m);
      }
    },
    _monthTextPositionControl(t, e, i, n, o) {
      let a = "left"; let r = "top"; let s = t[0]; let l = t[1]; return i === "horizontal" ? (l += o, e && (a = "center"), n === "start" && (r = "bottom")) : (s += o, e && (r = "middle"), n === "start" && (a = "right")), {
        x: s, y: l, textAlign: a, textVerticalAlign: r,
      };
    },
    _renderMonthText(t, e, i) {
      const n = t.getModel("monthLabel"); if (n.get("show")) {
        let o = n.get("nameMap"); let r = n.get("margin"); const s = n.get("position"); const l = n.get("align"); const u = [this._tlpoints, this._blpoints]; _(o) && (o = YN[o.toUpperCase()] || []); const h = s === "start" ? 0 : 1; const c = e === "horizontal" ? 0 : 1; r = s === "start" ? -r : r; for (let d = l === "center", f = 0; f < u[h].length - 1; f++) {
          const p = u[h][f].slice(); const g = this._firstDayOfMonth[f]; if (d) { const m = this._firstDayPoints[f]; p[c] = (m[c] + u[0][f + 1][c]) / 2; } const v = n.get("formatter"); const y = o[+g.m - 1]; const x = {
            yyyy: g.y, yy: (`${g.y}`).slice(2), MM: g.m, M: +g.m, nameMap: y,
          }; const w = this._formatterLabel(v, x); const b = new rM({ z2: 30 }); a(go(b.style, n, { text: w }), this._monthTextPositionControl(p, d, e, s, r)), i.add(b);
        }
      }
    },
    _weekTextPositionControl(t, e, i, n, o) {
      let a = "center"; let r = "middle"; let s = t[0]; let l = t[1]; const u = i === "start"; return e === "horizontal" ? (s = s + n + (u ? 1 : -1) * o[0] / 2, a = u ? "right" : "left") : (l = l + n + (u ? 1 : -1) * o[1] / 2, r = u ? "bottom" : "top"), {
        x: s, y: l, textAlign: a, textVerticalAlign: r,
      };
    },
    _renderWeekText(t, e, i, n) { const o = t.getModel("dayLabel"); if (o.get("show")) { const r = t.coordinateSystem; const s = o.get("position"); let l = o.get("nameMap"); let u = o.get("margin"); const h = r.getFirstDayOfWeek(); _(l) && (l = qN[l.toUpperCase()] || []); let c = r.getNextNDay(e.end.time, 7 - e.lweek).time; const d = [r.getCellWidth(), r.getCellHeight()]; u = Bo(u, d[i === "horizontal" ? 0 : 1]), s === "start" && (c = r.getNextNDay(e.start.time, -(7 + e.fweek)).time, u = -u); for (let f = 0; f < 7; f++) { const p = r.getNextNDay(c, f); const g = r.dataToRect([p.time], !1).center; let m = f; m = Math.abs((f + h) % 7); const v = new rM({ z2: 30 }); a(go(v.style, o, { text: l[m] }), this._weekTextPositionControl(g, i, s, u, d)), n.add(v); } } },
  }), Gs({
    type: "title",
    layoutMode: { type: "box", ignoreSize: !0 },
    defaultOption: {
      zlevel: 0, z: 6, show: !0, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bolder", color: "#333" }, subtextStyle: { color: "#aaa" },
    },
  }), Fs({
    type: "title",
    render(t, e, i) {
      if (this.group.removeAll(), t.get("show")) {
        const n = this.group; const o = t.getModel("textStyle"); const a = t.getModel("subtextStyle"); let r = t.get("textAlign"); let s = t.get("textBaseline"); const l = new rM({ style: go({}, o, { text: t.get("text"), textFill: o.getTextColor() }, { disableBox: !0 }), z2: 10 }); const u = l.getBoundingRect(); const h = t.get("subtext"); const c = new rM({
          style: go({}, a, {
            text: h, textFill: a.getTextColor(), y: u.height + t.get("itemGap"), textVerticalAlign: "top",
          }, { disableBox: !0 }),
          z2: 10,
        }); const d = t.get("link"); const f = t.get("sublink"); const p = t.get("triggerEvent", !0); l.silent = !d && !p, c.silent = !f && !p, d && l.on("click", () => { window.open(d, `_${t.get("target")}`); }), f && c.on("click", () => { window.open(f, `_${t.get("subtarget")}`); }), l.eventData = c.eventData = p ? { componentType: "title", componentIndex: t.componentIndex } : null, n.add(l), h && n.add(c); let g = n.getBoundingRect(); const m = t.getBoxLayoutParams(); m.width = g.width, m.height = g.height; const v = ha(m, { width: i.getWidth(), height: i.getHeight() }, t.get("padding")); r || ((r = t.get("left") || t.get("right")) === "middle" && (r = "center"), r === "right" ? v.x += v.width : r === "center" && (v.x += v.width / 2)), s || ((s = t.get("top") || t.get("bottom")) === "center" && (s = "middle"), s === "bottom" ? v.y += v.height : s === "middle" && (v.y += v.height / 2), s = s || "top"), n.attr("position", [v.x, v.y]); const y = { textAlign: r, textVerticalAlign: s }; l.setStyle(y), c.setStyle(y), g = n.getBoundingRect(); const x = v.margin; const _ = t.getItemStyle(["color", "opacity"]); _.fill = t.get("backgroundColor"); const w = new yM({
          shape: {
            x: g.x - x[3], y: g.y - x[0], width: g.width + x[1] + x[3], height: g.height + x[0] + x[2], r: t.get("borderRadius"),
          },
          style: _,
          silent: !0,
        }); Kn(w), n.add(w);
      }
    },
  }), uI.registerSubTypeDefaulter("dataZoom", () => "slider"); var KN = ["cartesian2d", "polar", "singleAxis"]; const $N = (function (t, e) { const i = f(t = t.slice(), sa); const n = f(e = (e || []).slice(), sa); return function (o, a) { d(t, (t, r) => { for (var s = { name: t, capital: i[r] }, l = 0; l < e.length; l++)s[e[l]] = t + n[l]; o.call(a, s); }); }; }(["x", "y", "z", "radius", "angle", "single"], ["axisIndex", "axis", "index", "id"])); var JN = d; const QN = Go; const tO = function (t, e, i, n) { this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this._minMaxSpan, this.ecModel = n, this._dataZoomModel = i; }; tO.prototype = {
    constructor: tO, hostedBy(t) { return this._dataZoomModel === t; }, getDataValueWindow() { return this._valueWindow.slice(); }, getDataPercentWindow() { return this._percentWindow.slice(); }, getTargetSeriesModels() { const t = []; const e = this.ecModel; return e.eachSeries(function (i) { if (Py(i.get("coordinateSystem"))) { const n = this._dimName; const o = e.queryComponents({ mainType: `${n}Axis`, index: i.get(`${n}AxisIndex`), id: i.get(`${n}AxisId`) })[0]; this._axisIndex === (o && o.componentIndex) && t.push(i); } }, this), t; }, getAxisModel() { return this.ecModel.getComponent(`${this._dimName}Axis`, this._axisIndex); }, getOtherAxisModel() { let t; let e; const i = this._dimName; const n = this.ecModel; const o = this.getAxisModel(); i === "x" || i === "y" ? (e = "gridIndex", t = i === "x" ? "y" : "x") : (e = "polarIndex", t = i === "angle" ? "radius" : "angle"); let a; return n.eachComponent(`${t}Axis`, (t) => { (t.get(e) || 0) === (o.get(e) || 0) && (a = t); }), a; }, getMinMaxSpan() { return i(this._minMaxSpan); }, calculateDataWindow(t) { const e = this._dataExtent; const i = this.getAxisModel().axis.scale; const n = this._dataZoomModel.getRangePropMode(); const o = [0, 100]; const a = [t.start, t.end]; const r = []; return JN(["startValue", "endValue"], (e) => { r.push(t[e] != null ? i.parse(t[e]) : null); }), JN([0, 1], (t) => { let s = r[t]; let l = a[t]; n[t] === "percent" ? (l == null && (l = o[t]), s = i.parse(zo(l, o, e, !0))) : l = zo(s, e, o, !0), r[t] = s, a[t] = l; }), { valueWindow: QN(r), percentWindow: QN(a) }; }, reset(t) { if (t === this._dataZoomModel) { const e = this.getTargetSeriesModels(); this._dataExtent = Oy(this, this._dimName, e); const i = this.calculateDataWindow(t.option); this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, zy(this), Ry(this); } }, restore(t) { t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, Ry(this, !0)); }, filterData(t, e) { function i(t) { return t >= r[0] && t <= r[1]; } if (t === this._dataZoomModel) { const n = this._dimName; const o = this.getTargetSeriesModels(); const a = t.get("filterMode"); var r = this._valueWindow; a !== "none" && JN(o, (t) => { const e = t.getData(); const o = e.mapDimension(n, !0); o.length && (a === "weakFilter" ? e.filterSelf((t) => { for (var i, n, a, s = 0; s < o.length; s++) { const l = e.get(o[s], t); const u = !isNaN(l); const h = l < r[0]; const c = l > r[1]; if (u && !h && !c) return !0; u && (a = !0), h && (i = !0), c && (n = !0); } return a && i && n; }) : JN(o, (n) => { if (a === "empty")t.setData(e.map(n, t => (i(t) ? t : NaN))); else { const o = {}; o[n] = r, e.selectRange(o); } }), JN(o, (t) => { e.setApproximateExtent(r, t); })); }); } },
  }; var eO = d; const iO = $N; const nO = Gs({
    type: "dataZoom",
    dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"],
    defaultOption: {
      zlevel: 0, z: 4, orient: null, xAxisIndex: null, yAxisIndex: null, filterMode: "filter", throttle: null, start: 0, end: 100, startValue: null, endValue: null, minSpan: null, maxSpan: null, minValueSpan: null, maxValueSpan: null, rangeMode: null,
    },
    init(t, e, i) { this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, this._autoThrottle = !0, this._rangePropMode = ["percent", "percent"]; const n = By(t); this.mergeDefaultAndTheme(t, i), this.doInit(n); },
    mergeOption(t) { const e = By(t); n(this.option, t, !0), this.doInit(e); },
    doInit(t) { const e = this.option; U_.canvasSupported || (e.realtime = !1), this._setDefaultThrottle(t), Vy(this, t), eO([["start", "startValue"], ["end", "endValue"]], function (t, i) { this._rangePropMode[i] === "value" && (e[t[0]] = null); }, this), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), this._giveAxisProxies(); },
    _giveAxisProxies() { const t = this._axisProxies; this.eachTargetAxis(function (e, i, n, o) { const a = this.dependentModels[e.axis][i]; const r = a.__dzAxisProxy || (a.__dzAxisProxy = new tO(e.name, i, this, o)); t[`${e.name}_${i}`] = r; }, this); },
    _resetTarget() { const t = this.option; const e = this._judgeAutoMode(); iO((e) => { const i = e.axisIndex; t[i] = Di(t[i]); }, this), e === "axisIndex" ? this._autoSetAxisIndex() : e === "orient" && this._autoSetOrient(); },
    _judgeAutoMode() { const t = this.option; let e = !1; iO((i) => { t[i.axisIndex] != null && (e = !0); }, this); const i = t.orient; return i == null && e ? "orient" : e ? void 0 : (i == null && (t.orient = "horizontal"), "axisIndex"); },
    _autoSetAxisIndex() { let t = !0; const e = this.get("orient", !0); const i = this.option; const n = this.dependentModels; if (t) { const o = e === "vertical" ? "y" : "x"; n[`${o}Axis`].length ? (i[`${o}AxisIndex`] = [0], t = !1) : eO(n.singleAxis, (n) => { t && n.get("orient", !0) === e && (i.singleAxisIndex = [n.componentIndex], t = !1); }); }t && iO(function (e) { if (t) { const n = []; const o = this.dependentModels[e.axis]; if (o.length && !n.length) for (let a = 0, r = o.length; a < r; a++)o[a].get("type") === "category" && n.push(a); i[e.axisIndex] = n, n.length && (t = !1); } }, this), t && this.ecModel.eachSeries(function (t) { this._isSeriesHasAllAxesTypeOf(t, "value") && iO((e) => { const n = i[e.axisIndex]; let o = t.get(e.axisIndex); const a = t.get(e.axisId); l(n, o = t.ecModel.queryComponents({ mainType: e.axis, index: o, id: a })[0].componentIndex) < 0 && n.push(o); }); }, this); },
    _autoSetOrient() { let t; this.eachTargetAxis((e) => { !t && (t = e.name); }, this), this.option.orient = t === "y" ? "vertical" : "horizontal"; },
    _isSeriesHasAllAxesTypeOf(t, e) { let i = !0; return iO(function (n) { const o = t.get(n.axisIndex); const a = this.dependentModels[n.axis][o]; a && a.get("type") === e || (i = !1); }, this), i; },
    _setDefaultThrottle(t) { if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) { const e = this.ecModel.option; this.option.throttle = e.animation && e.animationDurationUpdate > 0 ? 100 : 20; } },
    getFirstTargetAxisModel() { let t; return iO(function (e) { if (t == null) { const i = this.get(e.axisIndex); i.length && (t = this.dependentModels[e.axis][i[0]]); } }, this), t; },
    eachTargetAxis(t, e) { const i = this.ecModel; iO(function (n) { eO(this.get(n.axisIndex), function (o) { t.call(e, n, o, this, i); }, this); }, this); },
    getAxisProxy(t, e) { return this._axisProxies[`${t}_${e}`]; },
    getAxisModel(t, e) { const i = this.getAxisProxy(t, e); return i && i.getAxisModel(); },
    setRawRange(t, e) { const i = this.option; eO([["start", "startValue"], ["end", "endValue"]], (e) => { t[e[0]] == null && t[e[1]] == null || (i[e[0]] = t[e[0]], i[e[1]] = t[e[1]]); }, this), !e && Vy(this, t); },
    getPercentRange() { const t = this.findRepresentativeAxisProxy(); if (t) return t.getDataPercentWindow(); },
    getValueRange(t, e) { if (t != null || e != null) return this.getAxisProxy(t, e).getDataValueWindow(); const i = this.findRepresentativeAxisProxy(); return i ? i.getDataValueWindow() : void 0; },
    findRepresentativeAxisProxy(t) { if (t) return t.__dzAxisProxy; const e = this._axisProxies; for (var i in e) if (e.hasOwnProperty(i) && e[i].hostedBy(this)) return e[i]; for (var i in e) if (e.hasOwnProperty(i) && !e[i].hostedBy(this)) return e[i]; },
    getRangePropMode() { return this._rangePropMode.slice(); },
  }); const oO = KI.extend({ type: "dataZoom", render(t, e, i, n) { this.dataZoomModel = t, this.ecModel = e, this.api = i; }, getTargetCoordInfo() { function t(t, e, i, n) { for (var o, a = 0; a < i.length; a++) if (i[a].model === t) { o = i[a]; break; }o || i.push(o = { model: t, axisModels: [], coordIndex: n }), o.axisModels.push(e); } const e = this.dataZoomModel; const i = this.ecModel; const n = {}; return e.eachTargetAxis((e, o) => { const a = i.getComponent(e.axis, o); if (a) { const r = a.getCoordSysModel(); r && t(r, a, n[r.mainType] || (n[r.mainType] = []), r.componentIndex); } }, this), n; } }); const aO = (nO.extend({
    type: "dataZoom.slider",
    layoutMode: "box",
    defaultOption: {
      show: !0, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#2f4554", width: 0.5, opacity: 0.3 }, areaStyle: { color: "rgba(47,69,84,0.3)", opacity: 0.3 } }, borderColor: "#ddd", fillerColor: "rgba(167,183,204,0.4)", handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z", handleSize: "100%", handleStyle: { color: "#a7b7cc" }, labelPrecision: null, labelFormatter: null, showDetail: !0, showDataShadow: "auto", realtime: !0, zoomLock: !1, textStyle: { color: "#333" },
    },
  }), yM); const rO = zo; const sO = Go; const lO = m; const uO = d; const hO = "horizontal"; const cO = 5; const dO = ["line", "bar", "candlestick", "scatter"]; var fO = oO.extend({
    type: "dataZoom.slider",
    init(t, e) { this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, this.api = e; },
    render(t, e, i, n) { fO.superApply(this, "render", arguments), Pr(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), !1 !== this.dataZoomModel.get("show") ? (n && n.type === "dataZoom" && n.from === this.uid || this._buildView(), this._updateView()) : this.group.removeAll(); },
    remove() { fO.superApply(this, "remove", arguments), Nr(this, "_dispatchZoomAction"); },
    dispose() { fO.superApply(this, "dispose", arguments), Nr(this, "_dispatchZoomAction"); },
    _buildView() { const t = this.group; t.removeAll(), this._resetLocation(), this._resetInterval(); const e = this._displayables.barGroup = new tb(); this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), this._positionGroup(); },
    _resetLocation() {
      const t = this.dataZoomModel; const e = this.api; const i = this._findCoordRect(); const n = { width: e.getWidth(), height: e.getHeight() }; const o = this._orient === hO ? {
        right: n.width - i.x - i.width, top: n.height - 30 - 7, width: i.width, height: 30,
      } : {
        right: 7, top: i.y, width: 30, height: i.height,
      }; const a = pa(t.option); d(["right", "top", "width", "height"], (t) => { a[t] === "ph" && (a[t] = o[t]); }); const r = ha(a, n, t.padding); this._location = { x: r.x, y: r.y }, this._size = [r.width, r.height], this._orient === "vertical" && this._size.reverse();
    },
    _positionGroup() { const t = this.group; const e = this._location; const i = this._orient; const n = this.dataZoomModel.getFirstTargetAxisModel(); const o = n && n.get("inverse"); const a = this._displayables.barGroup; const r = (this._dataShadowInfo || {}).otherAxisInverse; a.attr(i !== hO || o ? i === hO && o ? { scale: r ? [-1, 1] : [-1, -1] } : i !== "vertical" || o ? { scale: r ? [-1, -1] : [-1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, -1] : [1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, 1] : [1, -1] }); const s = t.getBoundingRect([a]); t.attr("position", [e.x - s.x, e.y - s.y]); },
    _getViewExtent() { return [0, this._size[0]]; },
    _renderBackground() {
      const t = this.dataZoomModel; const e = this._size; const i = this._displayables.barGroup; i.add(new aO({
        silent: !0,
        shape: {
          x: 0, y: 0, width: e[0], height: e[1],
        },
        style: { fill: t.get("backgroundColor") },
        z2: -40,
      })), i.add(new aO({
        shape: {
          x: 0, y: 0, width: e[0], height: e[1],
        },
        style: { fill: "transparent" },
        z2: 0,
        onclick: m(this._onClickPanelClick, this),
      }));
    },
    _renderDataShadow() {
      const t = this._dataShadowInfo = this._prepareDataShadowInfo(); if (t) {
        const e = this._size; const i = t.series; const n = i.getRawData(); const o = i.getShadowDim ? i.getShadowDim() : t.otherDim; if (o != null) {
          let a = n.getDataExtent(o); const s = 0.3 * (a[1] - a[0]); a = [a[0] - s, a[1] + s]; let l; const u = [0, e[1]]; const h = [0, e[0]]; const c = [[e[0], 0], [0, 0]]; const d = []; const f = h[1] / (n.count() - 1); let p = 0; const g = Math.round(n.count() / e[0]); n.each([o], (t, e) => { if (g > 0 && e % g)p += f; else { const i = t == null || isNaN(t) || t === ""; const n = i ? 0 : rO(t, a, u, !0); i && !l && e ? (c.push([c[c.length - 1][0], 0]), d.push([d[d.length - 1][0], 0])) : !i && l && (c.push([p, 0]), d.push([p, 0])), c.push([p, n]), d.push([p, n]), p += f, l = i; } }); const m = this.dataZoomModel; this._displayables.barGroup.add(new pM({
            shape: { points: c }, style: r({ fill: m.get("dataBackgroundColor") }, m.getModel("dataBackground.areaStyle").getAreaStyle()), silent: !0, z2: -20,
          })), this._displayables.barGroup.add(new gM({
            shape: { points: d }, style: m.getModel("dataBackground.lineStyle").getLineStyle(), silent: !0, z2: -19,
          }));
        }
      }
    },
    _prepareDataShadowInfo() {
      const t = this.dataZoomModel; const e = t.get("showDataShadow"); if (!1 !== e) {
        let i; const n = this.ecModel; return t.eachTargetAxis(function (o, a) {
          d(t.getAxisProxy(o.name, a).getTargetSeriesModels(), (t) => {
            if (!(i || !0 !== e && l(dO, t.get("type")) < 0)) {
              let r; const s = n.getComponent(o.axis, a).axis; let u = Gy(o.name); const h = t.coordinateSystem; u != null && h.getOtherAxis && (r = h.getOtherAxis(s).inverse), u = t.getData().mapDimension(u), i = {
                thisAxis: s, series: t, thisDim: o.name, otherDim: u, otherAxisInverse: r,
              };
            }
          }, this);
        }, this), i;
      }
    },
    _renderHandle() {
      const t = this._displayables; const e = t.handles = []; const i = t.handleLabels = []; const n = this._displayables.barGroup; const o = this._size; const a = this.dataZoomModel; n.add(t.filler = new aO({
        draggable: !0, cursor: Fy(this._orient), drift: lO(this._onDragMove, this, "all"), onmousemove(t) { mw(t.event); }, ondragstart: lO(this._showDataInfo, this, !0), ondragend: lO(this._onDragEnd, this), onmouseover: lO(this._showDataInfo, this, !0), onmouseout: lO(this._showDataInfo, this, !1), style: { fill: a.get("fillerColor"), textPosition: "inside" },
      })), n.add(new aO(Kn({
        silent: !0,
        shape: {
          x: 0, y: 0, width: o[0], height: o[1],
        },
        style: { stroke: a.get("dataBackgroundColor") || a.get("borderColor"), lineWidth: 1, fill: "rgba(0,0,0,0)" },
      }))), uO([0, 1], function (t) {
        const o = ko(a.get("handleIcon"), {
          cursor: Fy(this._orient), draggable: !0, drift: lO(this._onDragMove, this, t), onmousemove(t) { mw(t.event); }, ondragend: lO(this._onDragEnd, this), onmouseover: lO(this._showDataInfo, this, !0), onmouseout: lO(this._showDataInfo, this, !1),
        }, {
          x: -1, y: 0, width: 2, height: 2,
        }); const r = o.getBoundingRect(); this._handleHeight = Bo(a.get("handleSize"), this._size[1]), this._handleWidth = r.width / r.height * this._handleHeight, o.setStyle(a.getModel("handleStyle").getItemStyle()); const s = a.get("handleColor"); s != null && (o.style.fill = s), n.add(e[t] = o); const l = a.textStyleModel; this.group.add(i[t] = new rM({
          silent: !0,
          invisible: !0,
          style: {
            x: 0, y: 0, text: "", textVerticalAlign: "middle", textAlign: "center", textFill: l.getTextColor(), textFont: l.getFont(),
          },
          z2: 10,
        }));
      }, this);
    },
    _resetInterval() { const t = this._range = this.dataZoomModel.getPercentRange(); const e = this._getViewExtent(); this._handleEnds = [rO(t[0], [0, 100], e, !0), rO(t[1], [0, 100], e, !0)]; },
    _updateInterval(t, e) { const i = this.dataZoomModel; const n = this._handleEnds; const o = this._getViewExtent(); const a = i.findRepresentativeAxisProxy().getMinMaxSpan(); const r = [0, 100]; tk(e, n, o, i.get("zoomLock") ? "all" : t, a.minSpan != null ? rO(a.minSpan, r, o, !0) : null, a.maxSpan != null ? rO(a.maxSpan, r, o, !0) : null); const s = this._range; const l = this._range = sO([rO(n[0], o, r, !0), rO(n[1], o, r, !0)]); return !s || s[0] !== l[0] || s[1] !== l[1]; },
    _updateView(t) {
      const e = this._displayables; const i = this._handleEnds; const n = sO(i.slice()); const o = this._size; uO([0, 1], function (t) { const n = e.handles[t]; const a = this._handleHeight; n.attr({ scale: [a / 2, a / 2], position: [i[t], o[1] / 2 - a / 2] }); }, this), e.filler.setShape({
        x: n[0], y: 0, width: n[1] - n[0], height: o[1],
      }), this._updateDataInfo(t);
    },
    _updateDataInfo(t) {
      function e(t) {
        const e = To(n.handles[t].parent, this.group); const i = Do(t === 0 ? "right" : "left", e); const s = this._handleWidth / 2 + cO; const l = Ao([c[t] + (t === 0 ? -s : s), this._size[1] / 2], e); o[t].setStyle({
          x: l[0], y: l[1], textVerticalAlign: a === hO ? "middle" : i, textAlign: a === hO ? i : "center", text: r[t],
        });
      } const i = this.dataZoomModel; var n = this._displayables; var o = n.handleLabels; var a = this._orient; var r = ["", ""]; if (i.get("showDetail")) { const s = i.findRepresentativeAxisProxy(); if (s) { const l = s.getAxisModel().axis; const u = this._range; const h = t ? s.calculateDataWindow({ start: u[0], end: u[1] }).valueWindow : s.getDataValueWindow(); r = [this._formatLabel(h[0], l), this._formatLabel(h[1], l)]; } } var c = sO(this._handleEnds.slice()); e.call(this, 0), e.call(this, 1);
    },
    _formatLabel(t, e) { const i = this.dataZoomModel; const n = i.get("labelFormatter"); let o = i.get("labelPrecision"); o != null && o !== "auto" || (o = e.getPixelPrecision()); const a = t == null || isNaN(t) ? "" : e.type === "category" || e.type === "time" ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(o, 20)); return x(n) ? n(t, a) : _(n) ? n.replace("{value}", a) : a; },
    _showDataInfo(t) { t = this._dragging || t; const e = this._displayables.handleLabels; e[0].attr("invisible", !t), e[1].attr("invisible", !t); },
    _onDragMove(t, e, i) { this._dragging = !0; const n = Ao([e, i], this._displayables.barGroup.getLocalTransform(), !0); const o = this._updateInterval(t, n[0]); const a = this.dataZoomModel.get("realtime"); this._updateView(!a), o && a && this._dispatchZoomAction(); },
    _onDragEnd() { this._dragging = !1, this._showDataInfo(!1), !this.dataZoomModel.get("realtime") && this._dispatchZoomAction(); },
    _onClickPanelClick(t) { const e = this._size; const i = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY); if (!(i[0] < 0 || i[0] > e[0] || i[1] < 0 || i[1] > e[1])) { const n = this._handleEnds; const o = (n[0] + n[1]) / 2; const a = this._updateInterval("all", i[0] - o); this._updateView(), a && this._dispatchZoomAction(); } },
    _dispatchZoomAction() {
      const t = this._range; this.api.dispatchAction({
        type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, start: t[0], end: t[1],
      });
    },
    _findCoordRect() {
      let t; if (uO(this.getTargetCoordInfo(), (e) => { if (!t && e.length) { const i = e[0].model.coordinateSystem; t = i.getRect && i.getRect(); } }), !t) {
        const e = this.api.getWidth(); const i = this.api.getHeight(); t = {
          x: 0.2 * e, y: 0.2 * i, width: 0.6 * e, height: 0.6 * i,
        };
      } return t;
    },
  }); nO.extend({
    type: "dataZoom.inside",
    defaultOption: {
      disabled: !1, zoomLock: !1, zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0,
    },
  }); var pO = "\0_ec_dataZoom_roams"; const gO = m; var mO = oO.extend({
    type: "dataZoom.inside",
    init(t, e) { this._range; },
    render(t, e, i, n) {
      mO.superApply(this, "render", arguments), this._range = t.getPercentRange(), d(this.getTargetCoordInfo(), function (e, n) {
        const o = f(e, t => Zy(t.model)); d(e, function (e) {
          const a = e.model; const r = {}; d(["pan", "zoom", "scrollMove"], function (t) { r[t] = gO(vO[t], this, e, n); }, this), Wy(i, {
            coordId: Zy(a), allCoordIds: o, containsPoint(t, e, i) { return a.coordinateSystem.containPoint([e, i]); }, dataZoomId: t.id, dataZoomModel: t, getRange: r,
          });
        }, this);
      }, this);
    },
    dispose() { Hy(this.api, this.dataZoomModel.id), mO.superApply(this, "dispose", arguments), this._range = null; },
  }); var vO = { zoom(t, e, i, n) { const o = this._range; const a = o.slice(); const r = t.axisModels[0]; if (r) { const s = yO[e](null, [n.originX, n.originY], r, i, t); const l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0]; const u = Math.max(1 / n.scale, 0); a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l; const h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan(); return tk(0, a, [0, 100], 0, h.minSpan, h.maxSpan), this._range = a, o[0] !== a[0] || o[1] !== a[1] ? a : void 0; } }, pan: Ky((t, e, i, n, o, a) => { const r = yO[n]([a.oldX, a.oldY], [a.newX, a.newY], e, o, i); return r.signal * (t[1] - t[0]) * r.pixel / r.pixelLength; }), scrollMove: Ky((t, e, i, n, o, a) => yO[n]([0, 0], [a.scrollDelta, a.scrollDelta], e, o, i).signal * (t[1] - t[0]) * a.scrollDelta) }; var yO = { grid(t, e, i, n, o) { const a = i.axis; const r = {}; const s = o.model.coordinateSystem.getRect(); return t = t || [0, 0], a.dim === "x" ? (r.pixel = e[0] - t[0], r.pixelLength = s.width, r.pixelStart = s.x, r.signal = a.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = s.height, r.pixelStart = s.y, r.signal = a.inverse ? -1 : 1), r; }, polar(t, e, i, n, o) { const a = i.axis; const r = {}; const s = o.model.coordinateSystem; const l = s.getRadiusAxis().getExtent(); const u = s.getAngleAxis().getExtent(); return t = t ? s.pointToCoord(t) : [0, 0], e = s.pointToCoord(e), i.mainType === "radiusAxis" ? (r.pixel = e[0] - t[0], r.pixelLength = l[1] - l[0], r.pixelStart = l[0], r.signal = a.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = u[1] - u[0], r.pixelStart = u[0], r.signal = a.inverse ? -1 : 1), r; }, singleAxis(t, e, i, n, o) { const a = i.axis; const r = o.model.coordinateSystem.getRect(); const s = {}; return t = t || [0, 0], a.orient === "horizontal" ? (s.pixel = e[0] - t[0], s.pixelLength = r.width, s.pixelStart = r.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = r.height, s.pixelStart = r.y, s.signal = a.inverse ? -1 : 1), s; } }; Ns({
    getTargetSeries(t) { const e = R(); return t.eachComponent("dataZoom", (t) => { t.eachTargetAxis((t, i, n) => { d(n.getAxisProxy(t.name, i).getTargetSeriesModels(), (t) => { e.set(t.uid, t); }); }); }), e; },
    modifyOutputEnd: !0,
    overallReset(t, e) {
      t.eachComponent("dataZoom", (t) => { t.eachTargetAxis((t, i, n) => { n.getAxisProxy(t.name, i).reset(n, e); }), t.eachTargetAxis((t, i, n) => { n.getAxisProxy(t.name, i).filterData(n, e); }); }), t.eachComponent("dataZoom", (t) => {
        const e = t.findRepresentativeAxisProxy(); const i = e.getDataPercentWindow(); const n = e.getDataValueWindow(); t.setRawRange({
          start: i[0], end: i[1], startValue: n[0], endValue: n[1],
        }, !0);
      });
    },
  }), Os("dataZoom", (t, e) => {
    const i = Ny(m(e.eachComponent, e, "dataZoom"), $N, (t, e) => t.get(e.axisIndex)); const n = []; e.eachComponent({ mainType: "dataZoom", query: t }, (t, e) => { n.push.apply(n, i(t).nodes); }), d(n, (e, i) => {
      e.setRawRange({
        start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue,
      });
    });
  }); const xO = d; const _O = function (t) { let e = t && t.visualMap; y(e) || (e = e ? [e] : []), xO(e, (t) => { if (t) { $y(t, "splitList") && !$y(t, "pieces") && (t.pieces = t.splitList, delete t.splitList); const e = t.pieces; e && y(e) && xO(e, (t) => { w(t) && ($y(t, "start") && !$y(t, "min") && (t.min = t.start), $y(t, "end") && !$y(t, "max") && (t.max = t.end)); }); } }); }; uI.registerSubTypeDefaulter("visualMap", t => (t.categories || (t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) && !t.calculable ? "piecewise" : "continuous")); const wO = GT.VISUAL.COMPONENT; zs(wO, { createOnAllSeries: !0, reset(t, e) { const i = []; return e.eachComponent("visualMap", (e) => { const n = t.pipelineContext; !e.isTargetSeries(t) || n && n.large || i.push(ny(e.stateList, e.targetVisuals, m(e.getValueState, e), e.getDataDimension(t.getData()))); }), i; } }), zs(wO, { createOnAllSeries: !0, reset(t, e) { const i = t.getData(); const n = []; e.eachComponent("visualMap", (e) => { if (e.isTargetSeries(t)) { const o = e.getVisualMeta(m(Jy, null, t, e)) || { stops: [], outerColors: [] }; const a = e.getDataDimension(i); const r = i.getDimensionInfo(a); r != null && (o.dimension = r.index, n.push(o)); } }), t.getData().setVisual("visualMeta", n); } }); const bO = { get(t, e, n) { const o = i((SO[t] || {})[e]); return n && y(o) ? o[o.length - 1] : o; } }; var SO = {
    color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [0.3, 1], inactive: [0, 0] }, colorLightness: { active: [0.9, 0.5], inactive: [0, 0] }, colorAlpha: { active: [0.3, 1], inactive: [0, 0] }, opacity: { active: [0.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] },
  }; const MO = cL.mapVisual; const IO = cL.eachVisual; const TO = y; const AO = d; const DO = Go; const CO = zo; const LO = B; const kO = Gs({
    type: "visualMap",
    dependencies: ["series"],
    stateList: ["inRange", "outOfRange"],
    replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
    dataBound: [-1 / 0, 1 / 0],
    layoutMode: { type: "box", ignoreSize: !0 },
    defaultOption: {
      show: !0, zlevel: 0, z: 4, seriesIndex: "all", min: 0, max: 200, dimension: null, inRange: null, outOfRange: null, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: !1, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, color: null, formatter: null, text: null, textStyle: { color: "#333" },
    },
    init(t, e, i) { this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, this.itemSize, this.mergeDefaultAndTheme(t, i); },
    optionUpdated(t, e) { const i = this.option; U_.canvasSupported || (i.realtime = !1), !e && ey(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption(); },
    resetVisual(t) { const e = this.stateList; t = m(t, this), this.controllerVisuals = ty(this.option.controller, e, t), this.targetVisuals = ty(this.option.target, e, t); },
    getTargetSeriesIndices() { const t = this.option.seriesIndex; let e = []; return t == null || t === "all" ? this.ecModel.eachSeries((t, i) => { e.push(i); }) : e = Di(t), e; },
    eachTargetSeries(t, e) { d(this.getTargetSeriesIndices(), function (i) { t.call(e, this.ecModel.getSeriesByIndex(i)); }, this); },
    isTargetSeries(t) { let e = !1; return this.eachTargetSeries((i) => { i === t && (e = !0); }), e; },
    formatValueText(t, e, i) { function n(t) { return t === l[0] ? "min" : t === l[1] ? "max" : (+t).toFixed(Math.min(s, 20)); } let o; let a; const r = this.option; var s = r.precision; var l = this.dataBound; const u = r.formatter; return i = i || ["<", ">"], y(t) && (t = t.slice(), o = !0), a = e ? t : o ? [n(t[0]), n(t[1])] : n(t), _(u) ? u.replace("{value}", o ? a[0] : a).replace("{value2}", o ? a[1] : a) : x(u) ? o ? u(t[0], t[1]) : u(t) : o ? t[0] === l[0] ? `${i[0]} ${a[1]}` : t[1] === l[1] ? `${i[1]} ${a[0]}` : `${a[0]} - ${a[1]}` : a; },
    resetExtent() { const t = this.option; const e = DO([t.min, t.max]); this._dataExtent = e; },
    getDataDimension(t) { const e = this.option.dimension; const i = t.dimensions; if (e != null || i.length) { if (e != null) return t.getDimension(e); for (let n = t.dimensions, o = n.length - 1; o >= 0; o--) { const a = n[o]; if (!t.getDimensionInfo(a).isCalculationCoord) return a; } } },
    getExtent() { return this._dataExtent.slice(); },
    completeVisualOption() { function t(t) { TO(o.color) && !t.inRange && (t.inRange = { color: o.color.slice().reverse() }), t.inRange = t.inRange || { color: e.get("gradientColor") }, AO(this.stateList, (e) => { const i = t[e]; if (_(i)) { const n = bO.get(i, "active", l); n ? (t[e] = {}, t[e][i] = n) : delete t[e]; } }, this); } var e = this.ecModel; var o = this.option; const a = { inRange: o.inRange, outOfRange: o.outOfRange }; const r = o.target || (o.target = {}); const s = o.controller || (o.controller = {}); n(r, a), n(s, a); var l = this.isCategory(); t.call(this, r), t.call(this, s), function (t, e, i) { const n = t[e]; let o = t[i]; n && !o && (o = t[i] = {}, AO(n, (t, e) => { if (cL.isValidType(e)) { const i = bO.get(e, "inactive", l); i != null && (o[e] = i, e !== "color" || o.hasOwnProperty("opacity") || o.hasOwnProperty("colorAlpha") || (o.opacity = [0, 0])); } })); }.call(this, r, "inRange", "outOfRange"), function (t) { const e = (t.inRange || {}).symbol || (t.outOfRange || {}).symbol; const n = (t.inRange || {}).symbolSize || (t.outOfRange || {}).symbolSize; const o = this.get("inactiveColor"); AO(this.stateList, function (a) { const r = this.itemSize; let s = t[a]; s || (s = t[a] = { color: l ? o : [o] }), s.symbol == null && (s.symbol = e && i(e) || (l ? "roundRect" : ["roundRect"])), s.symbolSize == null && (s.symbolSize = n && i(n) || (l ? r[0] : [r[0], r[0]])), s.symbol = MO(s.symbol, t => (t === "none" || t === "square" ? "roundRect" : t)); const u = s.symbolSize; if (u != null) { let h = -1 / 0; IO(u, (t) => { t > h && (h = t); }), s.symbolSize = MO(u, t => CO(t, [0, h], [0, r[0]], !0)); } }, this); }.call(this, s); },
    resetItemSize() { this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]; },
    isCategory() { return !!this.option.categories; },
    setSelected: LO,
    getValueState: LO,
    getVisualMeta: LO,
  }); const PO = [20, 140]; var NO = kO.extend({
    type: "visualMap.continuous",
    defaultOption: {
      align: "auto", calculable: !1, range: null, realtime: !0, itemHeight: null, itemWidth: null, hoverLink: !0, hoverLinkDataSize: null, hoverLinkOnHandle: null,
    },
    optionUpdated(t, e) { NO.superApply(this, "optionUpdated", arguments), this.resetExtent(), this.resetVisual(function (t) { t.mappingMethod = "linear", t.dataExtent = this.getExtent(); }), this._resetRange(); },
    resetItemSize() { NO.superApply(this, "resetItemSize", arguments); const t = this.itemSize; this._orient === "horizontal" && t.reverse(), (t[0] == null || isNaN(t[0])) && (t[0] = PO[0]), (t[1] == null || isNaN(t[1])) && (t[1] = PO[1]); },
    _resetRange() { const t = this.getExtent(); const e = this.option.range; !e || e.auto ? (t.auto = 1, this.option.range = t) : y(e) && (e[0] > e[1] && e.reverse(), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1])); },
    completeVisualOption() { kO.prototype.completeVisualOption.apply(this, arguments), d(this.stateList, function (t) { const e = this.option.controller[t].symbolSize; e && e[0] !== e[1] && (e[0] = 0); }, this); },
    setSelected(t) { this.option.range = t.slice(), this._resetRange(); },
    getSelected() { const t = this.getExtent(); const e = Go((this.get("range") || []).slice()); return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e; },
    getValueState(t) { const e = this.option.range; const i = this.getExtent(); return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange"; },
    findTargetDataIndices(t) { const e = []; return this.eachTargetSeries(function (i) { const n = []; const o = i.getData(); o.each(this.getDataDimension(o), (e, i) => { t[0] <= e && e <= t[1] && n.push(i); }, this), e.push({ seriesId: i.id, dataIndex: n }); }, this), e; },
    getVisualMeta(t) { function e(e, i) { o.push({ value: e, color: t(e, i) }); } for (var i = Qy(0, 0, this.getExtent()), n = Qy(0, 0, this.option.range.slice()), o = [], a = 0, r = 0, s = n.length, l = i.length; r < l && (!n.length || i[r] <= n[0]); r++)i[r] < n[a] && e(i[r], "outOfRange"); for (u = 1; a < s; a++, u = 0)u && o.length && e(n[a], "outOfRange"), e(n[a], "inRange"); for (var u = 1; r < l; r++)(!n.length || n[n.length - 1] < i[r]) && (u && (o.length && e(o[o.length - 1].value, "outOfRange"), u = 0), e(i[r], "outOfRange")); const h = o.length; return { stops: o, outerColors: [h ? o[0].color : "transparent", h ? o[h - 1].color : "transparent"] }; },
  }); const OO = Fs({
    type: "visualMap",
    autoPositionValues: {
      left: 1, right: 1, top: 1, bottom: 1,
    },
    init(t, e) { this.ecModel = t, this.api = e, this.visualMapModel; },
    render(t, e, i, n) { this.visualMapModel = t, !1 !== t.get("show") ? this.doRender.apply(this, arguments) : this.group.removeAll(); },
    renderBackground(t) {
      const e = this.visualMapModel; const i = qM(e.get("padding") || 0); const n = t.getBoundingRect(); t.add(new yM({
        z2: -1,
        silent: !0,
        shape: {
          x: n.x - i[3], y: n.y - i[0], width: n.width + i[3] + i[1], height: n.height + i[0] + i[2],
        },
        style: { fill: e.get("backgroundColor"), stroke: e.get("borderColor"), lineWidth: e.get("borderWidth") },
      }));
    },
    getControllerVisual(t, e, i) { function n(t) { return s[t]; } function o(t, e) { s[t] = e; } const a = (i = i || {}).forceState; const r = this.visualMapModel; var s = {}; if (e === "symbol" && (s.symbol = r.get("itemSymbol")), e === "color") { const l = r.get("contentColor"); s.color = l; } const u = r.controllerVisuals[a || r.getValueState(t)]; return d(cL.prepareVisualTypes(u), (a) => { let r = u[a]; i.convertOpacityToAlpha && a === "opacity" && (a = "colorAlpha", r = u.__alphaForOpacity), cL.dependsOn(a, e) && r && r.applyVisual(t, n, o); }), s[e]; },
    positionGroup(t) { const e = this.visualMapModel; const i = this.api; ca(t, e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }); },
    doRender: B,
  }); var EO = zo; const RO = d; var zO = Math.min; var BO = Math.max; var VO = 12; var GO = 6; var FO = OO.extend({
    type: "visualMap.continuous",
    init() { FO.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], this._dragging, this._hovering; },
    doRender(t, e, i, n) { n && n.type === "selectDataRange" && n.from === this.uid || this._buildView(); },
    _buildView() { this.group.removeAll(); const t = this.visualMapModel; const e = this.group; this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(e); const i = t.get("text"); this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e); },
    _renderEndsText(t, e, i) {
      if (e) {
        let n = e[1 - i]; n = n != null ? `${n}` : ""; const o = this.visualMapModel; const a = o.get("textGap"); const r = o.itemSize; const s = this._shapes.barGroup; const l = this._applyTransform([r[0] / 2, i === 0 ? -a : r[1] + a], s); const u = this._applyTransform(i === 0 ? "bottom" : "top", s); const h = this._orient; const c = this.visualMapModel.textStyleModel; this.group.add(new rM({
          style: {
            x: l[0], y: l[1], textVerticalAlign: h === "horizontal" ? "middle" : u, textAlign: h === "horizontal" ? u : "center", text: n, textFont: c.getFont(), textFill: c.getTextColor(),
          },
        }));
      }
    },
    _renderBar(t) { const e = this.visualMapModel; const i = this._shapes; const n = e.itemSize; const o = this._orient; const a = this._useHandle; const r = tx(e, this.api, n); const s = i.barGroup = this._createBarGroup(r); s.add(i.outOfRange = ix()), s.add(i.inRange = ix(null, a ? sx(this._orient) : null, m(this._dragHandle, this, "all", !1), m(this._dragHandle, this, "all", !0))); const l = e.textStyleModel.getTextRect("国"); const u = BO(l.width, l.height); a && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(s, 0, n, u, o, r), this._createHandle(s, 1, n, u, o, r)), this._createIndicator(s, n, u, o), t.add(s); },
    _createHandle(t, e, i, n, o) {
      const a = m(this._dragHandle, this, e, !1); const r = m(this._dragHandle, this, e, !0); const s = ix(nx(e, n), sx(this._orient), a, r); s.position[0] = i[0], t.add(s); const l = this.visualMapModel.textStyleModel; const u = new rM({
        draggable: !0,
        drift: a,
        onmousemove(t) { mw(t.event); },
        ondragend: r,
        style: {
          x: 0, y: 0, text: "", textFont: l.getFont(), textFill: l.getTextColor(),
        },
      }); this.group.add(u); const h = [o === "horizontal" ? n / 2 : 1.5 * n, o === "horizontal" ? e === 0 ? -1.5 * n : 1.5 * n : e === 0 ? -n / 2 : n / 2]; const c = this._shapes; c.handleThumbs[e] = s, c.handleLabelPoints[e] = h, c.handleLabels[e] = u;
    },
    _createIndicator(t, e, i, n) {
      const o = ix([[0, 0]], "move"); o.position[0] = e[0], o.attr({ invisible: !0, silent: !0 }), t.add(o); const a = this.visualMapModel.textStyleModel; const r = new rM({
        silent: !0,
        invisible: !0,
        style: {
          x: 0, y: 0, text: "", textFont: a.getFont(), textFill: a.getTextColor(),
        },
      }); this.group.add(r); const s = [n === "horizontal" ? i / 2 : GO + 3, 0]; const l = this._shapes; l.indicator = o, l.indicatorLabel = r, l.indicatorLabelPoint = s;
    },
    _dragHandle(t, e, i, n) {
      if (this._useHandle) {
        if (this._dragging = !e, !e) { const o = this._applyTransform([i, n], this._shapes.barGroup, !0); this._updateInterval(t, o[1]), this._updateView(); }e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice(),
        }), e ? !this._hovering && this._clearHoverLinkToSeries() : rx(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
      }
    },
    _resetInterval() { const t = this.visualMapModel; const e = this._dataInterval = t.getSelected(); const i = t.getExtent(); const n = [0, t.itemSize[1]]; this._handleEnds = [EO(e[0], i, n, !0), EO(e[1], i, n, !0)]; },
    _updateInterval(t, e) { e = e || 0; const i = this.visualMapModel; const n = this._handleEnds; const o = [0, i.itemSize[1]]; tk(e, n, o, t, 0); const a = i.getExtent(); this._dataInterval = [EO(n[0], o, a, !0), EO(n[1], o, a, !0)]; },
    _updateView(t) { const e = this.visualMapModel; const i = e.getExtent(); const n = this._shapes; const o = [0, e.itemSize[1]]; const a = t ? o : this._handleEnds; const r = this._createBarVisual(this._dataInterval, i, a, "inRange"); const s = this._createBarVisual(i, i, o, "outOfRange"); n.inRange.setStyle({ fill: r.barColor, opacity: r.opacity }).setShape("points", r.barPoints), n.outOfRange.setStyle({ fill: s.barColor, opacity: s.opacity }).setShape("points", s.barPoints), this._updateHandle(a, r); },
    _createBarVisual(t, e, i, n) { const o = { forceState: n, convertOpacityToAlpha: !0 }; const a = this._makeColorGradient(t, o); const r = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)]; const s = this._createBarPoints(i, r); return { barColor: new TM(0, 0, 0, 1, a), barPoints: s, handlesColor: [a[0].color, a[a.length - 1].color] }; },
    _makeColorGradient(t, e) { const i = []; const n = (t[1] - t[0]) / 100; i.push({ color: this.getControllerVisual(t[0], "color", e), offset: 0 }); for (let o = 1; o < 100; o++) { const a = t[0] + n * o; if (a > t[1]) break; i.push({ color: this.getControllerVisual(a, "color", e), offset: o / 100 }); } return i.push({ color: this.getControllerVisual(t[1], "color", e), offset: 1 }), i; },
    _createBarPoints(t, e) { const i = this.visualMapModel.itemSize; return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]]; },
    _createBarGroup(t) { const e = this._orient; const i = this.visualMapModel.get("inverse"); return new tb(e !== "horizontal" || i ? e === "horizontal" && i ? { scale: t === "bottom" ? [-1, 1] : [1, 1], rotation: -Math.PI / 2 } : e !== "vertical" || i ? { scale: t === "left" ? [1, 1] : [-1, 1] } : { scale: t === "left" ? [1, -1] : [-1, -1] } : { scale: t === "bottom" ? [1, 1] : [-1, 1], rotation: Math.PI / 2 }); },
    _updateHandle(t, e) {
      if (this._useHandle) {
        const i = this._shapes; const n = this.visualMapModel; const o = i.handleThumbs; const a = i.handleLabels; RO([0, 1], function (r) {
          const s = o[r]; s.setStyle("fill", e.handlesColor[r]), s.position[1] = t[r]; const l = Ao(i.handleLabelPoints[r], To(s, this.group)); a[r].setStyle({
            x: l[0], y: l[1], text: n.formatValueText(this._dataInterval[r]), textVerticalAlign: "middle", textAlign: this._applyTransform(this._orient === "horizontal" ? r === 0 ? "bottom" : "top" : "left", i.barGroup),
          });
        }, this);
      }
    },
    _showIndicator(t, e, i, n) {
      const o = this.visualMapModel; const a = o.getExtent(); const r = o.itemSize; const s = [0, r[1]]; const l = EO(t, a, s, !0); const u = this._shapes; const h = u.indicator; if (h) {
        h.position[1] = l, h.attr("invisible", !1), h.setShape("points", ox(!!i, n, l, r[1])); const c = { convertOpacityToAlpha: !0 }; const d = this.getControllerVisual(t, "color", c); h.setStyle("fill", d); const f = Ao(u.indicatorLabelPoint, To(h, this.group)); const p = u.indicatorLabel; p.attr("invisible", !1); const g = this._applyTransform("left", u.barGroup); const m = this._orient; p.setStyle({
          text: (i || "") + o.formatValueText(e), textVerticalAlign: m === "horizontal" ? g : "middle", textAlign: m === "horizontal" ? "center" : g, x: f[0], y: f[1],
        });
      }
    },
    _enableHoverLinkToSeries() { const t = this; this._shapes.barGroup.on("mousemove", (e) => { if (t._hovering = !0, !t._dragging) { const i = t.visualMapModel.itemSize; const n = t._applyTransform([e.offsetX, e.offsetY], t._shapes.barGroup, !0, !0); n[1] = zO(BO(0, n[1]), i[1]), t._doHoverLinkToSeries(n[1], n[0] >= 0 && n[0] <= i[0]); } }).on("mouseout", () => { t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries(); }); },
    _enableHoverLinkFromSeries() { const t = this.api.getZr(); this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries(); },
    _doHoverLinkToSeries(t, e) { const i = this.visualMapModel; const n = i.itemSize; if (i.option.hoverLink) { const o = [0, n[1]]; const a = i.getExtent(); t = zO(BO(o[0], t), o[1]); const r = ax(i, a, o); const s = [t - r, t + r]; const l = EO(t, o, a, !0); const u = [EO(s[0], o, a, !0), EO(s[1], o, a, !0)]; s[0] < o[0] && (u[0] = -1 / 0), s[1] > o[1] && (u[1] = 1 / 0), e && (u[0] === -1 / 0 ? this._showIndicator(l, u[1], "< ", r) : u[1] === 1 / 0 ? this._showIndicator(l, u[0], "> ", r) : this._showIndicator(l, l, "≈ ", r)); const h = this._hoverLinkDataIndices; let c = []; (e || rx(i)) && (c = this._hoverLinkDataIndices = i.findTargetDataIndices(u)); const d = Ri(h, c); this._dispatchHighDown("downplay", ex(d[0])), this._dispatchHighDown("highlight", ex(d[1])); } },
    _hoverLinkFromSeriesMouseOver(t) { const e = t.target; const i = this.visualMapModel; if (e && e.dataIndex != null) { const n = this.ecModel.getSeriesByIndex(e.seriesIndex); if (i.isTargetSeries(n)) { const o = n.getData(e.dataType); const a = o.get(i.getDataDimension(o), e.dataIndex, !0); isNaN(a) || this._showIndicator(a, a); } } },
    _hideIndicator() { const t = this._shapes; t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0); },
    _clearHoverLinkToSeries() { this._hideIndicator(); const t = this._hoverLinkDataIndices; this._dispatchHighDown("downplay", ex(t)), t.length = 0; },
    _clearHoverLinkFromSeries() { this._hideIndicator(); const t = this.api.getZr(); t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator); },
    _applyTransform(t, e, i, n) { const o = To(e, n ? null : this.group); return zM[y(t) ? "applyTransform" : "transformDirection"](t, o, i); },
    _dispatchHighDown(t, e) { e && e.length && this.api.dispatchAction({ type: t, batch: e }); },
    dispose() { this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries(); },
    remove() { this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries(); },
  }); Os({ type: "selectDataRange", event: "dataRangeSelected", update: "update" }, (t, e) => { e.eachComponent({ mainType: "visualMap", query: t }, (e) => { e.setSelected(t.selected); }); }), Ps(_O); var WO = kO.extend({
    type: "visualMap.piecewise",
    defaultOption: {
      selected: null, minOpen: !1, maxOpen: !1, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieceList: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: !0, showLabel: null,
    },
    optionUpdated(t, e) { WO.superApply(this, "optionUpdated", arguments), this._pieceList = [], this.resetExtent(); const n = this._mode = this._determineMode(); HO[this._mode].call(this), this._resetSelected(t, e); const o = this.option.categories; this.resetVisual(function (t, e) { n === "categories" ? (t.mappingMethod = "category", t.categories = i(o)) : (t.dataExtent = this.getExtent(), t.mappingMethod = "piecewise", t.pieceList = f(this._pieceList, (t) => { var t = i(t); return e !== "inRange" && (t.visual = null), t; })); }); },
    completeVisualOption() { function t(t, e, i) { return t && t[e] && (w(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i); } const e = this.option; const i = {}; const n = cL.listVisualTypes(); const o = this.isCategory(); d(e.pieces, (t) => { d(n, (e) => { t.hasOwnProperty(e) && (i[e] = 1); }); }), d(i, function (i, n) { let a = 0; d(this.stateList, (i) => { a |= t(e, i, n) || t(e.target, i, n); }, this), !a && d(this.stateList, (t) => { (e[t] || (e[t] = {}))[n] = bO.get(n, t === "inRange" ? "active" : "inactive", o); }); }, this), kO.prototype.completeVisualOption.apply(this, arguments); },
    _resetSelected(t, e) { const i = this.option; const n = this._pieceList; const o = (e ? i : t).selected || {}; if (i.selected = o, d(n, function (t, e) { const i = this.getSelectedMapKey(t); o.hasOwnProperty(i) || (o[i] = !0); }, this), i.selectedMode === "single") { let a = !1; d(n, function (t, e) { const i = this.getSelectedMapKey(t); o[i] && (a ? o[i] = !1 : a = !0); }, this); } },
    getSelectedMapKey(t) { return this._mode === "categories" ? `${t.value}` : `${t.index}`; },
    getPieceList() { return this._pieceList; },
    _determineMode() { const t = this.option; return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber"; },
    setSelected(t) { this.option.selected = i(t); },
    getValueState(t) { const e = cL.findPieceIndex(t, this._pieceList); return e != null && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange"; },
    findTargetDataIndices(t) { const e = []; return this.eachTargetSeries(function (i) { const n = []; const o = i.getData(); o.each(this.getDataDimension(o), function (e, i) { cL.findPieceIndex(e, this._pieceList) === t && n.push(i); }, this), e.push({ seriesId: i.id, dataIndex: n }); }, this), e; },
    getRepresentValue(t) { let e; if (this.isCategory())e = t.value; else if (t.value != null)e = t.value; else { const i = t.interval || []; e = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2; } return e; },
    getVisualMeta(t) { function e(e, a) { const r = o.getRepresentValue({ interval: e }); a || (a = o.getValueState(r)); const s = t(r, a); e[0] === -1 / 0 ? n[0] = s : e[1] === 1 / 0 ? n[1] = s : i.push({ value: e[0], color: s }, { value: e[1], color: s }); } if (!this.isCategory()) { var i = []; var n = []; var o = this; const a = this._pieceList.slice(); if (a.length) { let r = a[0].interval[0]; r !== -1 / 0 && a.unshift({ interval: [-1 / 0, r] }), (r = a[a.length - 1].interval[1]) !== 1 / 0 && a.push({ interval: [r, 1 / 0] }); } else a.push({ interval: [-1 / 0, 1 / 0] }); let s = -1 / 0; return d(a, (t) => { const i = t.interval; i && (i[0] > s && e([s, i[0]], "outOfRange"), e(i.slice()), s = i[1]); }, this), { stops: i, outerColors: n }; } },
  }); var HO = { splitNumber() { const t = this.option; const e = this._pieceList; let i = Math.min(t.precision, 20); const n = this.getExtent(); let o = t.splitNumber; o = Math.max(parseInt(o, 10), 1), t.splitNumber = o; for (var a = (n[1] - n[0]) / o; +a.toFixed(i) !== a && i < 5;)i++; t.precision = i, a = +a.toFixed(i); let r = 0; t.minOpen && e.push({ index: r++, interval: [-1 / 0, n[0]], close: [0, 0] }); for (let s = n[0], l = r + o; r < l; s += a) { const u = r === o - 1 ? n[1] : s + a; e.push({ index: r++, interval: [s, u], close: [1, 1] }); }t.maxOpen && e.push({ index: r++, interval: [n[1], 1 / 0], close: [0, 0] }), $o(e), d(e, function (t) { t.text = this.formatValueText(t.interval); }, this); }, categories() { const t = this.option; d(t.categories, function (t) { this._pieceList.push({ text: this.formatValueText(t, !0), value: t }); }, this), lx(t, this._pieceList); }, pieces() { const t = this.option; const e = this._pieceList; d(t.pieces, (t, i) => { w(t) || (t = { value: t }); const n = { text: "", index: i }; if (t.label != null && (n.text = t.label), t.hasOwnProperty("value")) { const o = n.value = t.value; n.interval = [o, o], n.close = [1, 1]; } else { for (var a = n.interval = [], r = n.close = [0, 0], s = [1, 0, 1], l = [-1 / 0, 1 / 0], u = [], h = 0; h < 2; h++) { for (let c = [["gte", "gt", "min"], ["lte", "lt", "max"]][h], d = 0; d < 3 && a[h] == null; d++)a[h] = t[c[d]], r[h] = s[d], u[h] = d === 2; a[h] == null && (a[h] = l[h]); }u[0] && a[1] === 1 / 0 && (r[0] = 0), u[1] && a[0] === -1 / 0 && (r[1] = 0), a[0] === a[1] && r[0] && r[1] && (n.value = a[0]); }n.visual = cL.retrieveVisuals(t), e.push(n); }, this), lx(t, e), $o(e), d(e, function (t) { const e = t.close; const i = [["<", "≤"][e[1]], [">", "≥"][e[0]]]; t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, i); }, this); } }; OO.extend({
    type: "visualMap.piecewise",
    doRender() {
      const t = this.group; t.removeAll(); const e = this.visualMapModel; const i = e.get("textGap"); const n = e.textStyleModel; const o = n.getFont(); const a = n.getTextColor(); const r = this._getItemAlign(); const s = e.itemSize; const l = this._getViewData(); const u = l.endsText; const h = T(e.get("showLabel", !0), !u); u && this._renderEndsText(t, u[0], s, h, r), d(l.viewPieceList, function (n) {
        const l = n.piece; const u = new tb(); u.onclick = m(this._onItemClick, this, l), this._enableHoverLink(u, n.indexInModelPieceList); const c = e.getRepresentValue(l); if (this._createItemSymbol(u, c, [0, 0, s[0], s[1]]), h) {
          const d = this.visualMapModel.getValueState(c); u.add(new rM({
            style: {
              x: r === "right" ? -i : s[0] + i, y: s[1] / 2, text: l.text, textVerticalAlign: "middle", textAlign: r, textFont: o, textFill: a, opacity: d === "outOfRange" ? 0.5 : 1,
            },
          }));
        }t.add(u);
      }, this), u && this._renderEndsText(t, u[1], s, h, r), rI(e.get("orient"), t, e.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    },
    _enableHoverLink(t, e) { function i(t) { const i = this.visualMapModel; i.option.hoverLink && this.api.dispatchAction({ type: t, batch: ex(i.findTargetDataIndices(e)) }); }t.on("mouseover", m(i, this, "highlight")).on("mouseout", m(i, this, "downplay")); },
    _getItemAlign() { const t = this.visualMapModel; const e = t.option; if (e.orient === "vertical") return tx(t, this.api, t.itemSize); let i = e.align; return i && i !== "auto" || (i = "left"), i; },
    _renderEndsText(t, e, i, n, o) {
      if (e) {
        const a = new tb(); const
          r = this.visualMapModel.textStyleModel; a.add(new rM({
          style: {
            x: n ? o === "right" ? i[0] : 0 : i[0] / 2, y: i[1] / 2, textVerticalAlign: "middle", textAlign: n ? o : "center", text: e, textFont: r.getFont(), textFill: r.getTextColor(),
          },
        })), t.add(a);
      }
    },
    _getViewData() { const t = this.visualMapModel; const e = f(t.getPieceList(), (t, e) => ({ piece: t, indexInModelPieceList: e })); let i = t.get("text"); const n = t.get("orient"); const o = t.get("inverse"); return (n === "horizontal" ? o : !o) ? e.reverse() : i && (i = i.slice().reverse()), { viewPieceList: e, endsText: i }; },
    _createItemSymbol(t, e, i) { t.add($l(this.getControllerVisual(e, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color"))); },
    _onItemClick(t) {
      const e = this.visualMapModel; const n = e.option; const o = i(n.selected); const a = e.getSelectedMapKey(t); n.selectedMode === "single" ? (o[a] = !0, d(o, (t, e) => { o[e] = e === a; })) : o[a] = !o[a], this.api.dispatchAction({
        type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: o,
      });
    },
  }); Ps(_O); const ZO = Qo; const UO = ea; const XO = Gs({
    type: "marker",
    dependencies: ["series", "grid", "polar", "geo"],
    init(t, e, i, n) { this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0); },
    isAnimationEnabled() { if (U_.node) return !1; const t = this.__hostSeries; return this.getShallow("animation") && t && t.isAnimationEnabled(); },
    mergeOption(t, e, i, n) {
      const o = this.constructor; const r = `${this.mainType}Model`; i || e.eachSeries(function (t) {
        const i = t.get(this.mainType, !0); let s = t[r]; i && i.data ? (s ? s.mergeOption(i, e, !0) : (n && ux(i), d(i.data, (t) => { t instanceof Array ? (ux(t[0]), ux(t[1])) : ux(t); }), a(s = new o(i, this, e), {
          mainType: this.mainType, seriesIndex: t.seriesIndex, name: t.name, createdBySelf: !0,
        }), s.__hostSeries = t), t[r] = s) : t[r] = null;
      }, this);
    },
    formatTooltip(t) { const e = this.getData(); const i = this.getRawValue(t); const n = y(i) ? f(i, ZO).join(", ") : ZO(i); const o = e.getName(t); let a = UO(this.name); return (i != null || o) && (a += "<br />"), o && (a += UO(o), i != null && (a += " : ")), i != null && (a += UO(n)), a; },
    getData() { return this._data; },
    setData(t) { this._data = t; },
  }); h(XO, UI), XO.extend({
    type: "markPoint",
    defaultOption: {
      zlevel: 0, z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { show: !0, position: "inside" }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: !0 } },
    },
  }); var jO = l; const YO = v; var qO = { min: YO(dx, "min"), max: YO(dx, "max"), average: YO(dx, "average") }; const KO = Fs({
    type: "marker", init() { this.markerGroupMap = R(); }, render(t, e, i) { const n = this.markerGroupMap; n.each((t) => { t.__keep = !1; }); const o = `${this.type}Model`; e.eachSeries(function (t) { const n = t[o]; n && this.renderSeries(t, n, e, i); }, this), n.each(function (t) { !t.__keep && this.group.remove(t.group); }, this); }, renderSeries() {},
  }); KO.extend({ type: "markPoint", updateTransform(t, e, i) { e.eachSeries(function (t) { const e = t.markPointModel; e && (xx(e.getData(), t, i), this.markerGroupMap.get(t.id).updateLayout(e)); }, this); }, renderSeries(t, e, i, n) { const o = t.coordinateSystem; const a = t.id; const r = t.getData(); const s = this.markerGroupMap; const l = s.get(a) || s.set(a, new Au()); const u = _x(o, t, e); e.setData(u), xx(e.getData(), t, n), u.each((t) => { const i = u.getItemModel(t); let n = i.getShallow("symbolSize"); typeof n === "function" && (n = n(e.getRawValue(t), e.getDataParams(t))), u.setItemVisual(t, { symbolSize: n, color: i.get("itemStyle.color") || r.getVisual("color"), symbol: i.getShallow("symbol") }); }), l.updateData(u), this.group.add(l.group), u.eachItemGraphicEl((t) => { t.traverse((t) => { t.dataModel = e; }); }), l.__keep = !0, l.group.silent = e.get("silent") || t.get("silent"); } }), Ps((t) => { t.markPoint = t.markPoint || {}; }), XO.extend({
    type: "markLine",
    defaultOption: {
      zlevel: 0, z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], precision: 2, tooltip: { trigger: "item" }, label: { show: !0, position: "end" }, lineStyle: { type: "dashed" }, emphasis: { label: { show: !0 }, lineStyle: { width: 3 } }, animationEasing: "linear",
    },
  }); var $O = function (t, e, o, r) { const s = t.getData(); const l = r.type; if (!y(r) && (l === "min" || l === "max" || l === "average" || l === "median" || r.xAxis != null || r.yAxis != null)) { let u; let h; if (r.yAxis != null || r.xAxis != null)u = r.yAxis != null ? "y" : "x", e.getAxis(u), h = T(r.yAxis, r.xAxis); else { const c = px(r, s, e, t); u = c.valueDataDim, c.valueAxis, h = yx(s, u, l); } const d = u === "x" ? 0 : 1; const f = 1 - d; const p = i(r); const g = {}; p.type = null, p.coord = [], g.coord = [], p.coord[f] = -1 / 0, g.coord[f] = 1 / 0; const m = o.get("precision"); m >= 0 && typeof h === "number" && (h = +h.toFixed(Math.min(m, 20))), p.coord[d] = g.coord[d] = h, r = [p, g, { type: l, valueIndex: r.valueIndex, value: h }]; } return r = [fx(t, r[0]), fx(t, r[1]), a({}, r[2])], r[2].type = r[2].type || "", n(r[2], r[0]), n(r[2], r[1]), r; }; KO.extend({
    type: "markLine",
    updateTransform(t, e, i) { e.eachSeries(function (t) { const e = t.markLineModel; if (e) { const n = e.getData(); const o = e.__from; const a = e.__to; o.each((e) => { Ix(o, e, !0, t, i), Ix(a, e, !1, t, i); }), n.each((t) => { n.setItemLayout(t, [o.getItemLayout(t), a.getItemLayout(t)]); }), this.markerGroupMap.get(t.id).updateLayout(); } }, this); },
    renderSeries(t, e, i, n) {
      function o(e, i, o) { const a = e.getItemModel(i); Ix(e, i, o, t, n), e.setItemVisual(i, { symbolSize: a.get("symbolSize") || g[o ? 0 : 1], symbol: a.get("symbol", !0) || p[o ? 0 : 1], color: a.get("itemStyle.color") || s.getVisual("color") }); } const a = t.coordinateSystem; const r = t.id; var s = t.getData(); const l = this.markerGroupMap; const u = l.get(r) || l.set(r, new rf()); this.group.add(u.group); const h = Tx(a, t, e); const c = h.from; const d = h.to; const f = h.line; e.__from = c, e.__to = d, e.setData(f); var p = e.get("symbol"); var g = e.get("symbolSize"); y(p) || (p = [p, p]), typeof g === "number" && (g = [g, g]), h.from.each((t) => { o(c, t, !0), o(d, t, !1); }), f.each((t) => {
        const e = f.getItemModel(t).get("lineStyle.color"); f.setItemVisual(t, { color: e || c.getItemVisual(t, "color") }), f.setItemLayout(t, [c.getItemLayout(t), d.getItemLayout(t)]), f.setItemVisual(t, {
          fromSymbolSize: c.getItemVisual(t, "symbolSize"), fromSymbol: c.getItemVisual(t, "symbol"), toSymbolSize: d.getItemVisual(t, "symbolSize"), toSymbol: d.getItemVisual(t, "symbol"),
        });
      }), u.updateData(f), h.line.eachItemGraphicEl((t, i) => { t.traverse((t) => { t.dataModel = e; }); }), u.__keep = !0, u.group.silent = e.get("silent") || t.get("silent");
    },
  }), Ps((t) => { t.markLine = t.markLine || {}; }), XO.extend({
    type: "markArea",
    defaultOption: {
      zlevel: 0, z: 1, tooltip: { trigger: "item" }, animation: !1, label: { show: !0, position: "top" }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: !0, position: "top" } },
    },
  }); var JO = function (t, e, i, n) { const a = fx(t, n[0]); const r = fx(t, n[1]); const s = T; const l = a.coord; const u = r.coord; l[0] = s(l[0], -1 / 0), l[1] = s(l[1], -1 / 0), u[0] = s(u[0], 1 / 0), u[1] = s(u[1], 1 / 0); const h = o([{}, a, r]); return h.coord = [a.coord, r.coord], h.x0 = a.x, h.y0 = a.y, h.x1 = r.x, h.y1 = r.y, h; }; const QO = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]]; KO.extend({
    type: "markArea",
    updateTransform(t, e, i) { e.eachSeries((t) => { const e = t.markAreaModel; if (e) { const n = e.getData(); n.each((e) => { const o = f(QO, o => Lx(n, e, o, t, i)); n.setItemLayout(e, o), n.getItemGraphicEl(e).setShape("points", o); }); } }, this); },
    renderSeries(t, e, i, n) {
      const o = t.coordinateSystem; const a = t.id; const s = t.getData(); const l = this.markerGroupMap; const u = l.get(a) || l.set(a, { group: new tb() }); this.group.add(u.group), u.__keep = !0; const h = kx(o, t, e); e.setData(h), h.each((e) => { h.setItemLayout(e, f(QO, i => Lx(h, e, i, t, n))), h.setItemVisual(e, { color: s.getVisual("color") }); }), h.diff(u.__data).add((t) => { const e = new pM({ shape: { points: h.getItemLayout(t) } }); h.setItemGraphicEl(t, e), u.group.add(e); }).update((t, i) => { const n = u.__data.getItemGraphicEl(i); Mo(n, { shape: { points: h.getItemLayout(t) } }, e, t), u.group.add(n), h.setItemGraphicEl(t, n); }).remove((t) => { const e = u.__data.getItemGraphicEl(t); u.group.remove(e); })
        .execute(), h.eachItemGraphicEl((t, i) => {
        const n = h.getItemModel(i); const o = n.getModel("label"); const a = n.getModel("emphasis.label"); const s = h.getItemVisual(i, "color"); t.useStyle(r(n.getModel("itemStyle").getItemStyle(), { fill: Yt(s, 0.4), stroke: s })), t.hoverStyle = n.getModel("emphasis.itemStyle").getItemStyle(), po(t.style, t.hoverStyle, o, a, {
          labelFetcher: e, labelDataIndex: i, defaultText: h.getName(i) || "", isRectText: !0, autoColor: s,
        }), co(t, {}), t.dataModel = e;
      }), u.__data = h, u.group.silent = e.get("silent") || t.get("silent");
    },
  }), Ps((t) => { t.markArea = t.markArea || {}; }); uI.registerSubTypeDefaulter("timeline", () => "slider"), Os({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, (t, e) => { const i = e.getComponent("timeline"); return i && t.currentIndex != null && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)), e.resetOption("timeline"), r({ currentIndex: i.option.currentIndex }, t); }), Os({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, (t, e) => { const i = e.getComponent("timeline"); i && t.playState != null && i.setPlayState(t.playState); }); var tE = uI.extend({
    type: "timeline",
    layoutMode: "box",
    defaultOption: {
      zlevel: 0, z: 4, show: !0, axisType: "time", realtime: !0, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: !1, rewind: !1, loop: !0, playInterval: 2e3, currentIndex: 0, itemStyle: {}, label: { color: "#000" }, data: [],
    },
    init(t, e, i) { this._data, this._names, this.mergeDefaultAndTheme(t, i), this._initData(); },
    mergeOption(t) { tE.superApply(this, "mergeOption", arguments), this._initData(); },
    setCurrentIndex(t) { t == null && (t = this.option.currentIndex); const e = this._data.count(); this.option.loop ? t = (t % e + e) % e : (t >= e && (t = e - 1), t < 0 && (t = 0)), this.option.currentIndex = t; },
    getCurrentIndex() { return this.option.currentIndex; },
    isIndexMax() { return this.getCurrentIndex() >= this._data.count() - 1; },
    setPlayState(t) { this.option.autoPlay = !!t; },
    getPlayState() { return !!this.option.autoPlay; },
    _initData() { const t = this.option; let e = t.data || []; const n = t.axisType; const o = this._names = []; if (n === "category") { const a = []; d(e, (t, e) => { let n; let r = Li(t); w(t) ? (n = i(t)).value = e : n = e, a.push(n), _(r) || r != null && !isNaN(r) || (r = ""), o.push(`${r}`); }), e = a; } const r = { category: "ordinal", time: "time" }[n] || "number"; (this._data = new yA([{ name: "value", type: r }], this)).initData(e, o); },
    getData() { return this._data; },
    getCategories() { if (this.get("axisType") === "category") return this._names.slice(); },
  }); h(tE.extend({
    type: "timeline.slider",
    defaultOption: {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: { trigger: "item" },
      symbol: "emptyCircle",
      symbolSize: 10,
      lineStyle: { show: !0, width: 2, color: "#304654" },
      label: {
        position: "auto", show: !0, interval: "auto", rotate: 0, color: "#304654",
      },
      itemStyle: { color: "#304654", borderWidth: 1 },
      checkpointStyle: {
        symbol: "circle", symbolSize: 13, color: "#c23531", borderWidth: 5, borderColor: "rgba(194,53,49, 0.5)", animation: !0, animationDuration: 300, animationEasing: "quinticInOut",
      },
      controlStyle: {
        show: !0, showPlayBtn: !0, showPrevBtn: !0, showNextBtn: !0, itemSize: 22, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z", prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z", color: "#304654", borderColor: "#304654", borderWidth: 1,
      },
      emphasis: { label: { show: !0, color: "#c23531" }, itemStyle: { color: "#c23531" }, controlStyle: { color: "#c23531", borderColor: "#c23531", borderWidth: 2 } },
      data: [],
    },
  }), UI); const eE = KI.extend({ type: "timeline" }); const iE = function (t, e, i, n) { rD.call(this, t, e, i), this.type = n || "value", this.model = null; }; iE.prototype = { constructor: iE, getLabelModel() { return this.model.getModel("label"); }, isHorizontal() { return this.model.get("orient") === "horizontal"; } }, u(iE, rD); const nE = m; const oE = d; const aE = Math.PI; eE.extend({
    type: "timeline.slider",
    init(t, e) { this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup; },
    render(t, e, i, n) { if (this.model = t, this.api = i, this.ecModel = e, this.group.removeAll(), t.get("show", !0)) { const o = this._layout(t, i); const a = this._createGroup("mainGroup"); const r = this._createGroup("labelGroup"); const s = this._axis = this._createAxis(o, t); t.formatTooltip = function (t) { return ea(s.scale.getLabel(t)); }, oE(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (e) { this[`_render${e}`](o, a, s, t); }, this), this._renderAxisLabel(o, r, s, t), this._position(o, t); } this._doPlayStop(); },
    remove() { this._clearTimer(), this.group.removeAll(); },
    dispose() { this._clearTimer(); },
    _layout(t, e) {
      let i = t.get("label.position"); const n = t.get("orient"); const o = Ex(t, e); i == null || i === "auto" ? i = n === "horizontal" ? o.y + o.height / 2 < e.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(i) && (i = { horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } }[n][i]); const a = { horizontal: "center", vertical: i >= 0 || i === "+" ? "left" : "right" }; const r = { horizontal: i >= 0 || i === "+" ? "top" : "bottom", vertical: "middle" }; const s = { horizontal: 0, vertical: aE / 2 }; const l = n === "vertical" ? o.height : o.width; const u = t.getModel("controlStyle"); const h = u.get("show", !0); const c = h ? u.get("itemSize") : 0; const d = h ? u.get("itemGap") : 0; const f = c + d; let p = t.get("label.rotate") || 0; p = p * aE / 180; let g; let m; let v; let y; const x = u.get("position", !0); const _ = h && u.get("showPlayBtn", !0); const w = h && u.get("showPrevBtn", !0); const b = h && u.get("showNextBtn", !0); let S = 0; let M = l; return x === "left" || x === "bottom" ? (_ && (g = [0, 0], S += f), w && (m = [S, 0], S += f), b && (v = [M - c, 0], M -= f)) : (_ && (g = [M - c, 0], M -= f), w && (m = [0, 0], S += f), b && (v = [M - c, 0], M -= f)), y = [S, M], t.get("inverse") && y.reverse(), {
        viewRect: o, mainLength: l, orient: n, rotation: s[n], labelRotation: p, labelPosOpt: i, labelAlign: t.get("label.align") || a[n], labelBaseline: t.get("label.verticalAlign") || t.get("label.baseline") || r[n], playPosition: g, prevBtnPosition: m, nextBtnPosition: v, axisExtent: y, controlSize: c, controlGap: d,
      };
    },
    _position(t, e) { function i(t) { const e = t.position; t.origin = [c[0][0] - e[0], c[1][0] - e[1]]; } function n(t) { return [[t.x, t.x + t.width], [t.y, t.y + t.height]]; } function o(t, e, i, n, o) { t[n] += i[n][o] - e[n][o]; } const a = this._mainGroup; const r = this._labelGroup; let s = t.viewRect; if (t.orient === "vertical") { const l = xt(); const u = s.x; const h = s.y + s.height; St(l, l, [-u, -h]), Mt(l, l, -aE / 2), St(l, l, [u, h]), (s = s.clone()).applyTransform(l); } var c = n(s); const d = n(a.getBoundingRect()); const f = n(r.getBoundingRect()); const p = a.position; const g = r.position; g[0] = p[0] = c[0][0]; const m = t.labelPosOpt; if (isNaN(m))o(p, d, c, 1, v = m === "+" ? 0 : 1), o(g, f, c, 1, 1 - v); else { var v = m >= 0 ? 0 : 1; o(p, d, c, 1, v), g[1] = p[1] + m; }a.attr("position", p), r.attr("position", g), a.rotation = r.rotation = t.rotation, i(a), i(r); },
    _createAxis(t, e) { const i = e.getData(); const n = e.get("axisType"); const o = Wl(e, n); o.getTicks = function () { return i.mapArray(["value"], t => t); }; const a = i.getDataExtent("value"); o.setExtent(a[0], a[1]), o.niceTicks(); const r = new iE("value", o, t.axisExtent, n); return r.model = e, r; },
    _createGroup(t) { const e = this[`_${t}`] = new tb(); return this.group.add(e), e; },
    _renderAxisLine(t, e, i, n) {
      const o = i.getExtent(); n.get("lineStyle.show") && e.add(new _M({
        shape: {
          x1: o[0], y1: 0, x2: o[1], y2: 0,
        },
        style: a({ lineCap: "round" }, n.getModel("lineStyle").getLineStyle()),
        silent: !0,
        z2: 1,
      }));
    },
    _renderAxisTick(t, e, i, n) { const o = n.getData(); const a = i.scale.getTicks(); oE(a, function (t) { const a = i.dataToCoord(t); const r = o.getItemModel(t); const s = r.getModel("itemStyle"); const l = r.getModel("emphasis.itemStyle"); const u = { position: [a, 0], onclick: nE(this._changeTimeline, this, t) }; const h = zx(r, s, e, u); co(h, l.getItemStyle()), r.get("tooltip") ? (h.dataIndex = t, h.dataModel = n) : h.dataIndex = h.dataModel = null; }, this); },
    _renderAxisLabel(t, e, i, n) {
      if (i.getLabelModel().get("show")) {
        const o = n.getData(); const a = i.getViewLabels(); oE(a, function (n) {
          const a = n.tickValue; const r = o.getItemModel(a); const s = r.getModel("label"); const l = r.getModel("emphasis.label"); const u = i.dataToCoord(n.tickValue); const h = new rM({
            position: [u, 0], rotation: t.labelRotation - t.rotation, onclick: nE(this._changeTimeline, this, a), silent: !1,
          }); go(h.style, s, { text: n.formattedLabel, textAlign: t.labelAlign, textVerticalAlign: t.labelBaseline }), e.add(h), co(h, go({}, l));
        }, this);
      }
    },
    _renderControl(t, e, i, n) {
      function o(t, i, o, h) {
        if (t) {
          const c = Rx(n, i, u, {
            position: t, origin: [a / 2, 0], rotation: h ? -r : 0, rectHover: !0, style: s, onclick: o,
          }); e.add(c), co(c, l);
        }
      } var a = t.controlSize; var r = t.rotation; var s = n.getModel("controlStyle").getItemStyle(); var l = n.getModel("emphasis.controlStyle").getItemStyle(); var u = [0, -a / 2, a, a]; const h = n.getPlayState(); const c = n.get("inverse", !0); o(t.nextBtnPosition, "controlStyle.nextIcon", nE(this._changeTimeline, this, c ? "-" : "+")), o(t.prevBtnPosition, "controlStyle.prevIcon", nE(this._changeTimeline, this, c ? "+" : "-")), o(t.playPosition, `controlStyle.${h ? "stopIcon" : "playIcon"}`, nE(this._handlePlayClick, this, !h), !0);
    },
    _renderCurrentPointer(t, e, i, n) { const o = n.getData(); const a = n.getCurrentIndex(); const r = o.getItemModel(a).getModel("checkpointStyle"); const s = this; const l = { onCreate(t) { t.draggable = !0, t.drift = nE(s._handlePointerDrag, s), t.ondragend = nE(s._handlePointerDragend, s), Bx(t, a, i, n, !0); }, onUpdate(t) { Bx(t, a, i, n); } }; this._currentPointer = zx(r, r, this._mainGroup, {}, this._currentPointer, l); },
    _handlePlayClick(t) { this._clearTimer(), this.api.dispatchAction({ type: "timelinePlayChange", playState: t, from: this.uid }); },
    _handlePointerDrag(t, e, i) { this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]); },
    _handlePointerDragend(t) { this._pointerChangeTimeline([t.offsetX, t.offsetY], !0); },
    _pointerChangeTimeline(t, e) { let i = this._toAxisCoord(t)[0]; const n = Go(this._axis.getExtent().slice()); i > n[1] && (i = n[1]), i < n[0] && (i = n[0]), this._currentPointer.position[0] = i, this._currentPointer.dirty(); const o = this._findNearestTick(i); const a = this.model; (e || o !== a.getCurrentIndex() && a.get("realtime")) && this._changeTimeline(o); },
    _doPlayStop() { this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(nE(function () { const t = this.model; this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1)); }, this), this.model.get("playInterval"))); },
    _toAxisCoord(t) { return Ao(t, this._mainGroup.getLocalTransform(), !0); },
    _findNearestTick(t) { let e; const i = this.model.getData(); let n = 1 / 0; const o = this._axis; return i.each(["value"], (i, a) => { const r = o.dataToCoord(i); const s = Math.abs(r - t); s < n && (n = s, e = a); }), e; },
    _clearTimer() { this._timer && (clearTimeout(this._timer), this._timer = null); },
    _changeTimeline(t) { const e = this.model.getCurrentIndex(); t === "+" ? t = e + 1 : t === "-" && (t = e - 1), this.api.dispatchAction({ type: "timelineChange", currentIndex: t, from: this.uid }); },
  }), Ps((t) => { let e = t && t.timeline; y(e) || (e = e ? [e] : []), d(e, (t) => { t && Px(t); }); }); var rE = Gs({
    type: "toolbox",
    layoutMode: { type: "box", ignoreSize: !0 },
    optionUpdated() { rE.superApply(this, "optionUpdated", arguments), d(this.option.feature, (t, e) => { const i = Ay(e); i && n(t, i.defaultOption); }); },
    defaultOption: {
      show: !0, z: 6, zlevel: 0, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { borderColor: "#666", color: "none" }, emphasis: { iconStyle: { borderColor: "#3E98C5" } },
    },
  }); Fs({
    type: "toolbox",
    render(t, e, i, n) {
      function o(o, r) { let s; const c = h[o]; const d = h[r]; const f = new Po(l[c], t, t.ecModel); if (c && !d) { if (Vx(c))s = { model: f, onclick: f.option.onclick, featureName: c }; else { const p = Ay(c); if (!p) return; s = new p(f, e, i); }u[c] = s; } else { if (!(s = u[d])) return; s.model = f, s.ecModel = e, s.api = i; }c || !d ? f.get("show") && !s.unusable ? (a(f, s, c), f.setIconStatus = function (t, e) { const i = this.option; const n = this.iconPaths; i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t].trigger(e); }, s.render && s.render(f, e, i, n)) : s.remove && s.remove(e, i) : s.dispose && s.dispose(e, i); } function a(n, o, a) {
        const l = n.getModel("iconStyle"); const u = n.getModel("emphasis.iconStyle"); let h = o.getIcons ? o.getIcons() : n.get("icon"); let c = n.get("title") || {}; if (typeof h === "string") { const f = h; const p = c; c = {}, (h = {})[a] = f, c[a] = p; } const g = n.iconPaths = {}; d(h, (a, h) => {
          const d = ko(a, {}, {
            x: -s / 2, y: -s / 2, width: s, height: s,
          }); d.setStyle(l.getItemStyle()), d.hoverStyle = u.getItemStyle(), co(d), t.get("showTitle") && (d.__title = c[h], d.on("mouseover", () => {
            const t = u.getItemStyle(); d.setStyle({
              text: c[h], textPosition: t.textPosition || "bottom", textFill: t.fill || t.stroke || "#000", textAlign: t.textAlign || "center",
            });
          }).on("mouseout", () => { d.setStyle({ textFill: null }); })), d.trigger(n.get(`iconStatus.${h}`) || "normal"), r.add(d), d.on("click", m(o.onclick, o, e, i, h)), g[h] = d;
        });
      } var r = this.group; if (r.removeAll(), t.get("show")) {
        var s = +t.get("itemSize"); var l = t.get("feature") || {}; var u = this._features || (this._features = {}); var h = []; d(l, (t, e) => { h.push(e); }), new Us(this._featureNames || [], h).add(o).update(o).remove(v(o, null))
          .execute(), this._featureNames = h, _v(r, t, i), r.add(wv(r.getBoundingRect(), t)), r.eachChild((t) => { const e = t.__title; const n = t.hoverStyle; if (n && e) { const o = ke(e, Xe(n)); const a = t.position[0] + r.position[0]; let l = !1; t.position[1] + r.position[1] + s + o.height > i.getHeight() && (n.textPosition = "top", l = !0); const u = l ? -5 - o.height : s + 8; a + o.width / 2 > i.getWidth() ? (n.textPosition = ["100%", u], n.textAlign = "right") : a - o.width / 2 < 0 && (n.textPosition = [0, u], n.textAlign = "left"); } });
      }
    },
    updateView(t, e, i, n) { d(this._features, (t) => { t.updateView && t.updateView(t.model, e, i, n); }); },
    remove(t, e) { d(this._features, (i) => { i.remove && i.remove(t, e); }), this.group.removeAll(); },
    dispose(t, e) { d(this._features, (i) => { i.dispose && i.dispose(t, e); }); },
  }); const sE = sT.toolbox.saveAsImage; Gx.defaultOption = {
    show: !0, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: sE.title, type: "png", name: "", excludeComponents: ["toolbox"], pixelRatio: 1, lang: sE.lang.slice(),
  }, Gx.prototype.unusable = !U_.canvasSupported, Gx.prototype.onclick = function (t, e) {
    const i = this.model; const n = i.get("name") || t.get("title.0.text") || "echarts"; const o = document.createElement("a"); const a = i.get("type", !0) || "png"; o.download = `${n}.${a}`, o.target = "_blank"; const r = e.getConnectedDataURL({
      type: a, backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff", excludeComponents: i.get("excludeComponents"), pixelRatio: i.get("pixelRatio"),
    }); if (o.href = r, typeof MouseEvent !== "function" || U_.browser.ie || U_.browser.edge) if (window.navigator.msSaveOrOpenBlob) { for (var s = atob(r.split(",")[1]), l = s.length, u = new Uint8Array(l); l--;)u[l] = s.charCodeAt(l); const h = new Blob([u]); window.navigator.msSaveOrOpenBlob(h, `${n}.${a}`); } else { const c = i.get("lang"); const d = `<body style="margin:0;"><img src="${r}" style="max-width:100%;" title="${c && c[0] || ""}" /></body>`; window.open().document.write(d); } else { const f = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1 }); o.dispatchEvent(f); }
  }, Ty("saveAsImage", Gx); const lE = sT.toolbox.magicType; Fx.defaultOption = {
    show: !0,
    type: [],
    icon: {
      line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z", tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z",
    },
    title: i(lE.title),
    option: {},
    seriesIndex: {},
  }; const uE = Fx.prototype; uE.getIcons = function () { const t = this.model; const e = t.get("icon"); const i = {}; return d(t.get("type"), (t) => { e[t] && (i[t] = e[t]); }), i; }; const hE = {
    line(t, e, i, o) {
      if (t === "bar") {
        return n({
          id: e, type: "line", data: i.get("data"), stack: i.get("stack"), markPoint: i.get("markPoint"), markLine: i.get("markLine"),
        }, o.get("option.line") || {}, !0);
      }
    },
    bar(t, e, i, o) {
      if (t === "line") {
        return n({
          id: e, type: "bar", data: i.get("data"), stack: i.get("stack"), markPoint: i.get("markPoint"), markLine: i.get("markLine"),
        }, o.get("option.bar") || {}, !0);
      }
    },
    stack(t, e, i, o) { if (t === "line" || t === "bar") return n({ id: e, stack: "__ec_magicType_stack__" }, o.get("option.stack") || {}, !0); },
    tiled(t, e, i, o) { if (t === "line" || t === "bar") return n({ id: e, stack: "" }, o.get("option.tiled") || {}, !0); },
  }; const cE = [["line", "bar"], ["stack", "tiled"]]; uE.onclick = function (t, e, i) { const n = this.model; const o = n.get(`seriesIndex.${i}`); if (hE[i]) { const a = { series: [] }; d(cE, (t) => { l(t, i) >= 0 && d(t, (t) => { n.setIconStatus(t, "normal"); }); }), n.setIconStatus(i, "emphasis"), t.eachComponent({ mainType: "series", query: o == null ? null : { seriesIndex: o } }, (e) => { const o = e.subType; const s = e.id; const l = hE[i](o, s, e, n); l && (r(l, e.option), a.series.push(l)); const u = e.coordinateSystem; if (u && u.type === "cartesian2d" && (i === "line" || i === "bar")) { const h = u.getAxesByScale("ordinal")[0]; if (h) { const c = `${h.dim}Axis`; const d = t.queryComponents({ mainType: c, index: e.get(`${name}Index`), id: e.get(`${name}Id`) })[0].componentIndex; a[c] = a[c] || []; for (let f = 0; f <= d; f++)a[c][d] = a[c][d] || {}; a[c][d].boundaryGap = i === "bar"; } } }), e.dispatchAction({ type: "changeMagicType", currentType: i, newOption: a }); } }, Os({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, (t, e) => { e.mergeOption(t.newOption); }), Ty("magicType", Fx); const dE = sT.toolbox.dataView; var fE = new Array(60).join("-"); var pE = "\t"; var gE = new RegExp(`[${pE}]+`, "g"); $x.defaultOption = {
    show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: i(dE.title), lang: i(dE.lang), backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff",
  }, $x.prototype.onclick = function (t, e) { function i() { n.removeChild(a), x._dom = null; } var n = e.getDom(); const o = this.model; this._dom && n.removeChild(this._dom); var a = document.createElement("div"); a.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", a.style.backgroundColor = o.get("backgroundColor") || "#fff"; const r = document.createElement("h4"); const s = o.get("lang") || []; r.innerHTML = s[0] || o.get("title"), r.style.cssText = "margin: 10px 20px;", r.style.color = o.get("textColor"); const l = document.createElement("div"); const u = document.createElement("textarea"); l.style.cssText = "display:block;width:100%;overflow:auto;"; const h = o.get("optionToContent"); const c = o.get("contentToOption"); const d = Ux(t); if (typeof h === "function") { const f = h(e.getOption()); typeof f === "string" ? l.innerHTML = f : M(f) && l.appendChild(f); } else l.appendChild(u), u.readOnly = o.get("readOnly"), u.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", u.style.color = o.get("textColor"), u.style.borderColor = o.get("textareaBorderColor"), u.style.backgroundColor = o.get("textareaColor"), u.value = d.value; const p = d.meta; const g = document.createElement("div"); g.style.cssText = "position:absolute;bottom:0;left:0;right:0;"; let m = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px"; const v = document.createElement("div"); const y = document.createElement("div"); m += `;background-color:${o.get("buttonColor")}`, m += `;color:${o.get("buttonTextColor")}`; var x = this; ht(v, "click", i), ht(y, "click", () => { let t; try { t = typeof c === "function" ? c(l, e.getOption()) : Kx(u.value, p); } catch (t) { throw i(), new Error(`Data view format error ${t}`); }t && e.dispatchAction({ type: "changeDataView", newOption: t }), i(); }), v.innerHTML = s[1], y.innerHTML = s[2], y.style.cssText = m, v.style.cssText = m, !o.get("readOnly") && g.appendChild(y), g.appendChild(v), ht(u, "keydown", function (t) { if ((t.keyCode || t.which) === 9) { const e = this.value; const i = this.selectionStart; const n = this.selectionEnd; this.value = e.substring(0, i) + pE + e.substring(n), this.selectionStart = this.selectionEnd = i + 1, mw(t); } }), a.appendChild(r), a.appendChild(l), a.appendChild(g), l.style.height = `${n.clientHeight - 80}px`, n.appendChild(a), this._dom = a; }, $x.prototype.remove = function (t, e) { this._dom && e.getDom().removeChild(this._dom); }, $x.prototype.dispose = function (t, e) { this.remove(t, e); }, Ty("dataView", $x), Os({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, (t, e) => { const i = []; d(t.newOption.series, (t) => { const n = e.getSeriesByName(t.name)[0]; if (n) { const o = n.get("data"); i.push({ name: t.name, data: Jx(t.data, o) }); } else i.push(a({ type: "scatter" }, t)); }), e.mergeOption(r({ series: i }, t.newOption)); }); var mE = d; var vE = "\0_ec_hist_store"; nO.extend({ type: "dataZoom.select" }), oO.extend({ type: "dataZoom.select" }); const yE = sT.toolbox.dataZoom; const xE = d; const _E = "\0_ec_\0toolbox-dataZoom_"; o_.defaultOption = { show: !0, icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: i(yE.title) }; const wE = o_.prototype; wE.render = function (t, e, i, n) { this.model = t, this.ecModel = e, this.api = i, s_(t, e, this, n, i), r_(t, e); }, wE.onclick = function (t, e, i) { bE[i].call(this); }, wE.remove = function (t, e) { this._brushController.unmount(); }, wE.dispose = function (t, e) { this._brushController.dispose(); }; var bE = { zoom() { const t = !this._isZoomActive; this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: t }); }, back() { this._dispatchZoomAction(t_(this.ecModel)); } }; wE._onBrush = function (t, e) { function i(t, e, i) { const r = e.getAxis(t); const s = r.model; const l = n(t, s, a); const u = l.findRepresentativeAxisProxy(s).getMinMaxSpan(); u.minValueSpan == null && u.maxValueSpan == null || (i = tk(0, i.slice(), r.scale.getExtent(), 0, u.minValueSpan, u.maxValueSpan)), l && (o[l.id] = { dataZoomId: l.id, startValue: i[0], endValue: i[1] }); } function n(t, e, i) { let n; return i.eachComponent({ mainType: "dataZoom", subType: "select" }, (i) => { i.getAxisModel(t, e.componentIndex) && (n = i); }), n; } if (e.isEnd && t.length) { var o = {}; var a = this.ecModel; this._brushController.updateCovers([]), new hy(a_(this.model.option), a, { include: ["grid"] }).matchOutputRanges(t, a, (t, e, n) => { if (n.type === "cartesian2d") { const o = t.brushType; o === "rect" ? (i("x", n, e[0]), i("y", n, e[1])) : i({ lineX: "x", lineY: "y" }[o], n, e); } }), Qx(a, o), this._dispatchZoomAction(o); } }, wE._dispatchZoomAction = function (t) { const e = []; xE(t, (t, n) => { e.push(i(t)); }), e.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: e }); }, Ty("dataZoom", o_), Ps((t) => { function e(t, e) { if (e) { const o = `${t}Index`; let a = e[o]; a == null || a === "all" || y(a) || (a = !1 === a || a === "none" ? [] : [a]), i(t, (e, i) => { if (a == null || a === "all" || l(a, i) !== -1) { const r = { type: "select", $fromToolbox: !0, id: _E + t + i }; r[o] = i, n.push(r); } }); } } function i(e, i) { let n = t[e]; y(n) || (n = n ? [n] : []), xE(n, i); } if (t) { var n = t.dataZoom || (t.dataZoom = []); y(n) || (t.dataZoom = n = [n]); let o = t.toolbox; if (o && (y(o) && (o = o[0]), o && o.feature)) { const a = o.feature.dataZoom; e("xAxis", a), e("yAxis", a); } } }); const SE = sT.toolbox.restore; l_.defaultOption = { show: !0, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: SE.title }, l_.prototype.onclick = function (t, e, i) { e_(t), e.dispatchAction({ type: "restore", from: this.uid }); }, Ty("restore", l_), Os({ type: "restore", event: "restore", update: "prepareAndUpdate" }, (t, e) => { e.resetOption("recreate"); }); let ME; const IE = "urn:schemas-microsoft-com:vml"; const TE = typeof window === "undefined" ? null : window; var AE = !1; var DE = TE && TE.document; if (DE && !U_.canvasSupported) try { !DE.namespaces.zrvml && DE.namespaces.add("zrvml", IE), ME = function (t) { return DE.createElement(`<zrvml:${t} class="zrvml">`); }; } catch (t) { ME = function (t) { return DE.createElement(`<${t} xmlns="${IE}" class="zrvml">`); }; } const CE = ES.CMD; const LE = Math.round; const kE = Math.sqrt; const PE = Math.abs; const NE = Math.cos; const OE = Math.sin; const EE = Math.max; if (!U_.canvasSupported) {
    const RE = 21600; const zE = RE / 2; const BE = function (t) { t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = `${RE},${RE}`, t.coordorigin = "0,0"; }; const VE = function (t) { return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;"); }; const GE = function (t, e, i) { return `rgb(${[t, e, i].join(",")})`; }; const FE = function (t, e) { e && t && e.parentNode !== t && t.appendChild(e); }; const WE = function (t, e) { e && t && e.parentNode === t && t.removeChild(e); }; const HE = function (t, e, i) { return 1e5 * (parseFloat(t) || 0) + 1e3 * (parseFloat(e) || 0) + i; }; const ZE = function (t, e) { return typeof t === "string" ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t; }; const UE = function (t, e, i) { const n = Gt(e); i = +i, isNaN(i) && (i = 1), n && (t.color = GE(n[0], n[1], n[2]), t.opacity = i * n[3]); }; const XE = function (t) { const e = Gt(t); return [GE(e[0], e[1], e[2]), e[3]]; }; const jE = function (t, e, i) { const n = e.fill; if (n != null) if (n instanceof IM) { let o; let a = 0; let r = [0, 0]; let s = 0; let l = 1; const u = i.getBoundingRect(); const h = u.width; const c = u.height; if (n.type === "linear") { o = "gradient"; var d = i.transform; var f = [n.x * h, n.y * c]; const p = [n.x2 * h, n.y2 * c]; d && (Q(f, f, d), Q(p, p, d)); const g = p[0] - f[0]; const m = p[1] - f[1]; (a = 180 * Math.atan2(g, m) / Math.PI) < 0 && (a += 360), a < 1e-6 && (a = 0); } else { o = "gradientradial"; var f = [n.x * h, n.y * c]; var d = i.transform; const v = i.scale; let y = h; let x = c; r = [(f[0] - u.x) / y, (f[1] - u.y) / x], d && Q(f, f, d), y /= v[0] * RE, x /= v[1] * RE; const _ = EE(y, x); s = 0 / _, l = 2 * n.r / _ - s; } const w = n.colorStops.slice(); w.sort((t, e) => t.offset - e.offset); for (var b = w.length, S = [], M = [], I = 0; I < b; I++) { const T = w[I]; const A = XE(T.color); M.push(`${T.offset * l + s} ${A[0]}`), I !== 0 && I !== b - 1 || S.push(A); } if (b >= 2) { const D = S[0][0]; const C = S[1][0]; const L = S[0][1] * e.opacity; const k = S[1][1] * e.opacity; t.type = o, t.method = "none", t.focus = "100%", t.angle = a, t.color = D, t.color2 = C, t.colors = M.join(","), t.opacity = k, t.opacity2 = L; }o === "radial" && (t.focusposition = r.join(",")); } else UE(t, n, e.opacity); }; const YE = function (t, e) { e.lineDash != null && (t.dashstyle = e.lineDash.join(" ")), e.stroke == null || e.stroke instanceof IM || UE(t, e.stroke, e.opacity); }; const qE = function (t, e, i, n) { const o = e === "fill"; let a = t.getElementsByTagName(e)[0]; i[e] != null && i[e] !== "none" && (o || !o && i.lineWidth) ? (t[o ? "filled" : "stroked"] = "true", i[e] instanceof IM && WE(t, a), a || (a = u_(e)), o ? jE(a, i, n) : YE(a, i), FE(t, a)) : (t[o ? "filled" : "stroked"] = "false", WE(t, a)); }; const KE = [[], [], []]; const $E = function (t, e) { let i; let n; let o; let a; let r; let s; const l = CE.M; const u = CE.C; const h = CE.L; const c = CE.A; const d = CE.Q; const f = []; const p = t.data; const g = t.len(); for (a = 0; a < g;) { switch (o = p[a++], n = "", i = 0, o) { case l: n = " m ", i = 1, r = p[a++], s = p[a++], KE[0][0] = r, KE[0][1] = s; break; case h: n = " l ", i = 1, r = p[a++], s = p[a++], KE[0][0] = r, KE[0][1] = s; break; case d: case u: n = " c ", i = 3; var m; var v; var y = p[a++]; var x = p[a++]; var _ = p[a++]; var w = p[a++]; o === d ? (m = _, v = w, _ = (_ + 2 * y) / 3, w = (w + 2 * x) / 3, y = (r + 2 * y) / 3, x = (s + 2 * x) / 3) : (m = p[a++], v = p[a++]), KE[0][0] = y, KE[0][1] = x, KE[1][0] = _, KE[1][1] = w, KE[2][0] = m, KE[2][1] = v, r = m, s = v; break; case c: var b = 0; var S = 0; var M = 1; var I = 1; var T = 0; e && (b = e[4], S = e[5], M = kE(e[0] * e[0] + e[1] * e[1]), I = kE(e[2] * e[2] + e[3] * e[3]), T = Math.atan2(-e[1] / I, e[0] / M)); var A = p[a++]; var D = p[a++]; var C = p[a++]; var L = p[a++]; var k = p[a++] + T; var P = p[a++] + k + T; a++; var N = p[a++]; var O = A + NE(k) * C; var E = D + OE(k) * L; var y = A + NE(P) * C; var x = D + OE(P) * L; var R = N ? " wa " : " at "; Math.abs(O - y) < 1e-4 && (Math.abs(P - k) > 0.01 ? N && (O += 0.0125) : Math.abs(E - D) < 1e-4 ? N && O < A || !N && O > A ? x -= 0.0125 : x += 0.0125 : N && E < D || !N && E > D ? y += 0.0125 : y -= 0.0125), f.push(R, LE(((A - C) * M + b) * RE - zE), ",", LE(((D - L) * I + S) * RE - zE), ",", LE(((A + C) * M + b) * RE - zE), ",", LE(((D + L) * I + S) * RE - zE), ",", LE((O * M + b) * RE - zE), ",", LE((E * I + S) * RE - zE), ",", LE((y * M + b) * RE - zE), ",", LE((x * I + S) * RE - zE)), r = y, s = x; break; case CE.R: var z = KE[0]; var B = KE[1]; z[0] = p[a++], z[1] = p[a++], B[0] = z[0] + p[a++], B[1] = z[1] + p[a++], e && (Q(z, z, e), Q(B, B, e)), z[0] = LE(z[0] * RE - zE), B[0] = LE(B[0] * RE - zE), z[1] = LE(z[1] * RE - zE), B[1] = LE(B[1] * RE - zE), f.push(" m ", z[0], ",", z[1], " l ", B[0], ",", z[1], " l ", B[0], ",", B[1], " l ", z[0], ",", B[1]); break; case CE.Z: f.push(" x "); } if (i > 0) { f.push(n); for (let V = 0; V < i; V++) { const G = KE[V]; e && Q(G, G, e), f.push(LE(G[0] * RE - zE), ",", LE(G[1] * RE - zE), V < i - 1 ? "," : ""); } } } return f.join(""); }; kn.prototype.brushVML = function (t) { const e = this.style; let i = this._vmlEl; i || (i = u_("shape"), BE(i), this._vmlEl = i), qE(i, "fill", e, this), qE(i, "stroke", e, this); const n = this.transform; const o = n != null; const a = i.getElementsByTagName("stroke")[0]; if (a) { let r = e.lineWidth; if (o && !e.strokeNoScale) { const s = n[0] * n[3] - n[1] * n[2]; r *= kE(PE(s)); }a.weight = `${r}px`; } const l = this.path || (this.path = new ES()); this.__dirtyPath && (l.beginPath(), l.subPixelOptimize = !1, this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), i.path = $E(l, this.transform), i.style.zIndex = HE(this.zlevel, this.z, this.z2), FE(t, i), e.text != null ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t); }, kn.prototype.onRemove = function (t) { WE(t, this._vmlEl), this.removeRectText(t); }, kn.prototype.onAdd = function (t) { FE(t, this._vmlEl), this.appendRectText(t); }; const JE = function (t) { return typeof t === "object" && t.tagName && t.tagName.toUpperCase() === "IMG"; }; fi.prototype.brushVML = function (t) {
      let e; let i; const n = this.style; let o = n.image; if (JE(o)) { const a = o.src; if (a === this._imageSrc)e = this._imageWidth, i = this._imageHeight; else { const r = o.runtimeStyle; const s = r.width; const l = r.height; r.width = "auto", r.height = "auto", e = o.width, i = o.height, r.width = s, r.height = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i; }o = a; } else o === this._imageSrc && (e = this._imageWidth, i = this._imageHeight); if (o) {
        let u = n.x || 0; let h = n.y || 0; const c = n.width; const d = n.height; const f = n.sWidth; const p = n.sHeight; const g = n.sx || 0; const m = n.sy || 0; const v = f && p; let y = this._vmlEl; y || (y = DE.createElement("div"), BE(y), this._vmlEl = y); let x; const _ = y.style; let w = !1; let b = 1; let S = 1; if (this.transform && (x = this.transform, b = kE(x[0] * x[0] + x[1] * x[1]), S = kE(x[2] * x[2] + x[3] * x[3]), w = x[1] || x[2]), w) { const M = [u, h]; const I = [u + c, h]; const T = [u, h + d]; const A = [u + c, h + d]; Q(M, M, x), Q(I, I, x), Q(T, T, x), Q(A, A, x); const D = EE(M[0], I[0], T[0], A[0]); const C = EE(M[1], I[1], T[1], A[1]); const L = []; L.push("M11=", x[0] / b, ",", "M12=", x[2] / S, ",", "M21=", x[1] / b, ",", "M22=", x[3] / S, ",", "Dx=", LE(u * b + x[4]), ",", "Dy=", LE(h * S + x[5])), _.padding = `0 ${LE(D)}px ${LE(C)}px 0`, _.filter = `progid:DXImageTransform.Microsoft.Matrix(${L.join("")}, SizingMethod=clip)`; } else x && (u = u * b + x[4], h = h * S + x[5]), _.filter = "", _.left = `${LE(u)}px`, _.top = `${LE(h)}px`; let k = this._imageEl; let P = this._cropEl; k || (k = DE.createElement("div"), this._imageEl = k); const N = k.style; if (v) {
          if (e && i)N.width = `${LE(b * e * c / f)}px`, N.height = `${LE(S * i * d / p)}px`; else {
            const O = new Image(); const
              E = this; O.onload = function () { O.onload = null, e = O.width, i = O.height, N.width = `${LE(b * e * c / f)}px`, N.height = `${LE(S * i * d / p)}px`, E._imageWidth = e, E._imageHeight = i, E._imageSrc = o; }, O.src = o;
          }P || ((P = DE.createElement("div")).style.overflow = "hidden", this._cropEl = P); const R = P.style; R.width = LE((c + g * c / f) * b), R.height = LE((d + m * d / p) * S), R.filter = `progid:DXImageTransform.Microsoft.Matrix(Dx=${-g * c / f * b},Dy=${-m * d / p * S})`, P.parentNode || y.appendChild(P), k.parentNode !== P && P.appendChild(k);
        } else N.width = `${LE(b * c)}px`, N.height = `${LE(S * d)}px`, y.appendChild(k), P && P.parentNode && (y.removeChild(P), this._cropEl = null); let z = ""; const B = n.opacity; B < 1 && (z += `.Alpha(opacity=${LE(100 * B)}) `), z += `progid:DXImageTransform.Microsoft.AlphaImageLoader(src=${o}, SizingMethod=scale)`, N.filter = z, y.style.zIndex = HE(this.zlevel, this.z, this.z2), FE(t, y), n.text != null && this.drawRectText(t, this.getBoundingRect());
      }
    }, fi.prototype.onRemove = function (t) { WE(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t); }, fi.prototype.onAdd = function (t) { FE(t, this._vmlEl), this.appendRectText(t); }; let QE; let tR = {}; let eR = 0; const iR = document.createElement("div"); const nR = function (t) {
      let e = tR[t]; if (!e) {
        eR > 100 && (eR = 0, tR = {}); let i; const n = iR.style; try { n.font = t, i = n.fontFamily.split(",")[0]; } catch (t) {}e = {
          style: n.fontStyle || "normal", variant: n.fontVariant || "normal", weight: n.fontWeight || "normal", size: 0 | parseFloat(n.fontSize || 12), family: i || "Microsoft YaHei",
        }, tR[t] = e, eR++;
      } return e;
    }; !(function (t, e) { bb[t] = e; }("measureText", (t, e) => { const i = DE; QE || ((QE = i.createElement("div")).style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", DE.body.appendChild(QE)); try { QE.style.font = e; } catch (t) {} return QE.innerHTML = "", QE.appendChild(i.createTextNode(t)), { width: QE.offsetWidth }; })); for (var oR = new de(), aR = [Db, di, fi, kn, rM], rR = 0; rR < aR.length; rR++) { const sR = aR[rR].prototype; sR.drawRectText = function (t, e, i, n) { const o = this.style; this.__dirty && Ye(o); let a = o.text; if (a != null && (a += ""), a) { if (o.rich) { const r = Ze(a, o); a = []; for (let s = 0; s < r.lines.length; s++) { for (var l = r.lines[s].tokens, u = [], h = 0; h < l.length; h++)u.push(l[h].text); a.push(u.join("")); }a = a.join("\n"); } let c; let d; let f = o.textAlign; let p = o.textVerticalAlign; const g = nR(o.font); const m = `${g.style} ${g.variant} ${g.weight} ${g.size}px "${g.family}"`; i = i || ke(a, m, f, p, o.textPadding, o.textLineHeight); const v = this.transform; if (v && !n && (oR.copy(e), oR.applyTransform(v), e = oR), n)c = e.x, d = e.y; else { const y = o.textPosition; const x = o.textDistance; if (y instanceof Array)c = e.x + ZE(y[0], e.width), d = e.y + ZE(y[1], e.height), f = f || "left"; else { const _ = Re(y, e, x); c = _.x, d = _.y, f = f || _.textAlign, p = p || _.textVerticalAlign; } }c = Oe(c, i.width, f), d = Ee(d, i.height, p), d += i.height / 2; let w; let b; let S; const M = u_; let I = this._textVmlEl; I ? b = (w = (S = I.firstChild).nextSibling).nextSibling : (I = M("line"), w = M("path"), b = M("textpath"), S = M("skew"), b.style["v-text-align"] = "left", BE(I), w.textpathok = !0, b.on = !0, I.from = "0 0", I.to = "1000 0.05", FE(I, S), FE(I, w), FE(I, b), this._textVmlEl = I); const T = [c, d]; const A = I.style; v && n ? (Q(T, T, v), S.on = !0, S.matrix = `${v[0].toFixed(3)},${v[2].toFixed(3)},${v[1].toFixed(3)},${v[3].toFixed(3)},0,0`, S.offset = `${LE(T[0]) || 0},${LE(T[1]) || 0}`, S.origin = "0 0", A.left = "0px", A.top = "0px") : (S.on = !1, A.left = `${LE(c)}px`, A.top = `${LE(d)}px`), b.string = VE(a); try { b.style.font = m; } catch (t) {}qE(I, "fill", { fill: o.textFill, opacity: o.opacity }, this), qE(I, "stroke", { stroke: o.textStroke, opacity: o.opacity, lineDash: o.lineDash }, this), I.style.zIndex = HE(this.zlevel, this.z, this.z2), FE(t, I); } }, sR.removeRectText = function (t) { WE(t, this._textVmlEl), this._textVmlEl = null; }, sR.appendRectText = function (t) { FE(t, this._textVmlEl); }; }rM.prototype.brushVML = function (t) {
      const e = this.style; e.text != null ? this.drawRectText(t, {
        x: e.x || 0, y: e.y || 0, width: 0, height: 0,
      }, this.getBoundingRect(), !0) : this.removeRectText(t);
    }, rM.prototype.onRemove = function (t) { this.removeRectText(t); }, rM.prototype.onAdd = function (t) { this.appendRectText(t); };
  }d_.prototype = {
    constructor: d_, getType() { return "vml"; }, getViewportRoot() { return this._vmlViewport; }, getViewportRootOffset() { const t = this.getViewportRoot(); if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 }; }, refresh() { const t = this.storage.getDisplayList(!0, !0); this._paintList(t); }, _paintList(t) { for (var e = this._vmlRoot, i = 0; i < t.length; i++) { const n = t[i]; n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1; } this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1); }, resize(t, e) { var t = t == null ? this._getWidth() : t; var e = e == null ? this._getHeight() : e; if (this._width !== t || this._height !== e) { this._width = t, this._height = e; const i = this._vmlViewport.style; i.width = `${t}px`, i.height = `${e}px`; } }, dispose() { this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null; }, getWidth() { return this._width; }, getHeight() { return this._height; }, clear() { this._vmlViewport && this.root.removeChild(this._vmlViewport); }, _getWidth() { const t = this.root; const e = t.currentStyle; return (t.clientWidth || c_(e.width)) - c_(e.paddingLeft) - c_(e.paddingRight) | 0; }, _getHeight() { const t = this.root; const e = t.currentStyle; return (t.clientHeight || c_(e.height)) - c_(e.paddingTop) - c_(e.paddingBottom) | 0; },
  }, d(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], (t) => { d_.prototype[t] = f_(t); }), Ti("vml", d_); var lR = "http://www.w3.org/2000/svg"; var uR = ES.CMD; var hR = Array.prototype.join; var cR = "none"; var dR = Math.round; var fR = Math.sin; var pR = Math.cos; var gR = Math.PI; var mR = 2 * Math.PI; var vR = 180 / gR; var yR = 1e-4; var xR = {}; xR.brush = function (t) { const e = t.style; let i = t.__svgEl; i || (i = p_("path"), t.__svgEl = i), t.path || t.createPathProxy(); const n = t.path; if (t.__dirtyPath) { n.beginPath(), n.subPixelOptimize = !1, t.buildPath(n, t.shape), t.__dirtyPath = !1; const o = S_(n); o.indexOf("NaN") < 0 && __(i, "d", o); }b_(i, e, !1, t), x_(i, t.transform), e.text != null && SR(t, t.getBoundingRect()); }; var _R = {}; _R.brush = function (t) { const e = t.style; let i = e.image; if (i instanceof HTMLImageElement && (i = i.src), i) { const n = e.x || 0; const o = e.y || 0; const a = e.width; const r = e.height; let s = t.__svgEl; s || (s = p_("image"), t.__svgEl = s), i !== t.__imageSrc && (w_(s, "href", i), t.__imageSrc = i), __(s, "width", a), __(s, "height", r), __(s, "x", n), __(s, "y", o), x_(s, t.transform), e.text != null && SR(t, t.getBoundingRect()); } }; var wR = {}; const bR = new de(); var SR = function (t, e, i) { const n = t.style; t.__dirty && Ye(n); let o = n.text; if (o != null) { o += ""; let a = t.__textSvgEl; a || (a = p_("text"), t.__textSvgEl = a); let r; let s; const l = n.textPosition; const u = n.textDistance; let h = n.textAlign || "left"; typeof n.fontSize === "number" && (n.fontSize += "px"); const c = n.font || [n.fontStyle || "", n.fontWeight || "", n.fontSize || "", n.fontFamily || ""].join(" ") || wb; let d = M_(n.textVerticalAlign); const f = (i = ke(o, c, h, d, n.textPadding, n.textLineHeight)).lineHeight; if (l instanceof Array)r = e.x + l[0], s = e.y + l[1]; else { const p = Re(l, e, u); r = p.x, s = p.y, d = M_(p.textVerticalAlign), h = p.textAlign; }__(a, "alignment-baseline", d), c && (a.style.font = c); const g = n.textPadding; if (__(a, "x", r), __(a, "y", s), b_(a, n, !0, t), t instanceof rM || t.style.transformText)x_(a, t.transform); else { if (t.transform)bR.copy(e), bR.applyTransform(t.transform), e = bR; else { var m = t.transformCoordToGlobal(e.x, e.y); e.x = m[0], e.y = m[1], t.transform = _t(xt()); } const v = n.textOrigin; v === "center" ? (r = i.width / 2 + r, s = i.height / 2 + s) : v && (r = v[0] + r, s = v[1] + s); const y = -n.textRotation || 0; const x = xt(); Mt(x, x, y), St(x, x, m = [t.transform[4], t.transform[5]]), x_(a, x); } const _ = o.split("\n"); const w = _.length; let b = h; b === "left" ? (b = "start", g && (r += g[3])) : b === "right" ? (b = "end", g && (r -= g[1])) : b === "center" && (b = "middle", g && (r += (g[3] - g[1]) / 2)); let S = 0; if (d === "after-edge" ? (S = -i.height + f, g && (S -= g[2])) : d === "middle" ? (S = (-i.height + f) / 2, g && (s += (g[0] - g[2]) / 2)) : g && (S += g[0]), t.__text !== o || t.__textFont !== c) { const M = t.__tspanList || []; t.__tspanList = M; for (T = 0; T < w; T++)(A = M[T]) ? A.innerHTML = "" : (A = M[T] = p_("tspan"), a.appendChild(A), __(A, "alignment-baseline", d), __(A, "text-anchor", b)), __(A, "x", r), __(A, "y", s + T * f + S), A.appendChild(document.createTextNode(_[T])); for (;T < M.length; T++)a.removeChild(M[T]); M.length = w, t.__text = o, t.__textFont = c; } else if (t.__tspanList.length) for (var I = t.__tspanList.length, T = 0; T < I; ++T) { var A = t.__tspanList[T]; A && (__(A, "x", r), __(A, "y", s + T * f + S)); } } }; wR.drawRectText = SR, wR.brush = function (t) {
    const e = t.style; e.text != null && (e.textPosition = [0, 0], SR(t, {
      x: e.x || 0, y: e.y || 0, width: 0, height: 0,
    }, t.getBoundingRect()));
  }, I_.prototype = {
    diff(t, e, i) { i || (i = function (t, e) { return t === e; }), this.equals = i; const n = this; t = t.slice(); const o = (e = e.slice()).length; const a = t.length; let r = 1; const s = o + a; const l = [{ newPos: -1, components: [] }]; const u = this.extractCommon(l[0], e, t, 0); if (l[0].newPos + 1 >= o && u + 1 >= a) { for (var h = [], c = 0; c < e.length; c++)h.push(c); return [{ indices: h, count: e.length }]; } for (;r <= s;) { const d = (function () { for (let i = -1 * r; i <= r; i += 2) { var s; const u = l[i - 1]; const h = l[i + 1]; let c = (h ? h.newPos : 0) - i; u && (l[i - 1] = void 0); const d = u && u.newPos + 1 < o; const f = h && c >= 0 && c < a; if (d || f) { if (!d || f && u.newPos < h.newPos ? (s = A_(h), n.pushComponent(s.components, void 0, !0)) : ((s = u).newPos++, n.pushComponent(s.components, !0, void 0)), c = n.extractCommon(s, e, t, i), s.newPos + 1 >= o && c + 1 >= a) return T_(0, s.components); l[i] = s; } else l[i] = void 0; }r++; }()); if (d) return d; } }, pushComponent(t, e, i) { const n = t[t.length - 1]; n && n.added === e && n.removed === i ? t[t.length - 1] = { count: n.count + 1, added: e, removed: i } : t.push({ count: 1, added: e, removed: i }); }, extractCommon(t, e, i, n) { for (var o = e.length, a = i.length, r = t.newPos, s = r - n, l = 0; r + 1 < o && s + 1 < a && this.equals(e[r + 1], i[s + 1]);)r++, s++, l++; return l && t.components.push({ count: l }), t.newPos = r, s; }, tokenize(t) { return t.slice(); }, join(t) { return t.slice(); },
  }; const MR = new I_(); const
    IR = function (t, e, i) { return MR.diff(t, e, i); }; D_.prototype.createElement = p_, D_.prototype.getDefs = function (t) { const e = this._svgRoot; let i = this._svgRoot.getElementsByTagName("defs"); return i.length === 0 ? t ? ((i = e.insertBefore(this.createElement("defs"), e.firstChild)).contains || (i.contains = function (t) { const e = i.children; if (!e) return !1; for (let n = e.length - 1; n >= 0; --n) if (e[n] === t) return !0; return !1; }), i) : null : i[0]; }, D_.prototype.update = function (t, e) { if (t) { const i = this.getDefs(!1); if (t[this._domName] && i.contains(t[this._domName])) typeof e === "function" && e(t); else { const n = this.add(t); n && (t[this._domName] = n); } } }, D_.prototype.addDom = function (t) { this.getDefs(!0).appendChild(t); }, D_.prototype.removeDom = function (t) { const e = this.getDefs(!1); e && t[this._domName] && (e.removeChild(t[this._domName]), t[this._domName] = null); }, D_.prototype.getDoms = function () { const t = this.getDefs(!1); if (!t) return []; let e = []; return d(this._tagNames, (i) => { const n = t.getElementsByTagName(i); e = e.concat([].slice.call(n)); }), e; }, D_.prototype.markAllUnused = function () { const t = this; d(this.getDoms(), (e) => { e[t._markLabel] = "0"; }); }, D_.prototype.markUsed = function (t) { t && (t[this._markLabel] = "1"); }, D_.prototype.removeUnused = function () { const t = this.getDefs(!1); if (t) { const e = this; d(this.getDoms(), (i) => { i[e._markLabel] !== "1" && t.removeChild(i); }); } }, D_.prototype.getSvgProxy = function (t) { return t instanceof kn ? xR : t instanceof fi ? _R : t instanceof rM ? wR : xR; }, D_.prototype.getTextSvgElement = function (t) { return t.__textSvgEl; }, D_.prototype.getSvgElement = function (t) { return t.__svgEl; }, u(C_, D_), C_.prototype.addWithoutUpdate = function (t, e) { if (e && e.style) { const i = this; d(["fill", "stroke"], (n) => { if (e.style[n] && (e.style[n].type === "linear" || e.style[n].type === "radial")) { let o; const a = e.style[n]; const r = i.getDefs(!0); a._dom ? (o = a._dom, r.contains(a._dom) || i.addDom(o)) : o = i.add(a), i.markUsed(e); const s = o.getAttribute("id"); t.setAttribute(n, `url(#${s})`); } }); } }, C_.prototype.add = function (t) { let e; if (t.type === "linear")e = this.createElement("linearGradient"); else { if (t.type !== "radial") return Yw("Illegal gradient type."), null; e = this.createElement("radialGradient"); } return t.id = t.id || this.nextId++, e.setAttribute("id", `zr${this._zrId}-gradient-${t.id}`), this.updateDom(t, e), this.addDom(e), e; }, C_.prototype.update = function (t) { const e = this; D_.prototype.update.call(this, t, () => { const i = t.type; const n = t._dom.tagName; i === "linear" && n === "linearGradient" || i === "radial" && n === "radialGradient" ? e.updateDom(t, t._dom) : (e.removeDom(t), e.add(t)); }); }, C_.prototype.updateDom = function (t, e) { if (t.type === "linear")e.setAttribute("x1", t.x), e.setAttribute("y1", t.y), e.setAttribute("x2", t.x2), e.setAttribute("y2", t.y2); else { if (t.type !== "radial") return void Yw("Illegal gradient type."); e.setAttribute("cx", t.x), e.setAttribute("cy", t.y), e.setAttribute("r", t.r); }t.global ? e.setAttribute("gradientUnits", "userSpaceOnUse") : e.setAttribute("gradientUnits", "objectBoundingBox"), e.innerHTML = ""; for (let i = t.colorStops, n = 0, o = i.length; n < o; ++n) { const a = this.createElement("stop"); a.setAttribute("offset", `${100 * i[n].offset}%`); const r = i[n].color; if (r.indexOf(!1)) { const s = Gt(r)[3]; const l = Zt(r); a.setAttribute("stop-color", `#${l}`), a.setAttribute("stop-opacity", s); } else a.setAttribute("stop-color", i[n].color); e.appendChild(a); }t._dom = e; }, C_.prototype.markUsed = function (t) { if (t.style) { let e = t.style.fill; e && e._dom && D_.prototype.markUsed.call(this, e._dom), (e = t.style.stroke) && e._dom && D_.prototype.markUsed.call(this, e._dom); } }, u(L_, D_), L_.prototype.update = function (t) { const e = this.getSvgElement(t); e && this.updateDom(e, t.__clipPaths, !1); const i = this.getTextSvgElement(t); i && this.updateDom(i, t.__clipPaths, !0), this.markUsed(t); }, L_.prototype.updateDom = function (t, e, i) { if (e && e.length > 0) { let n; let o; const a = this.getDefs(!0); const r = e[0]; const s = i ? "_textDom" : "_dom"; r[s] ? (o = r[s].getAttribute("id"), n = r[s], a.contains(n) || a.appendChild(n)) : (o = `zr${this._zrId}-clip-${this.nextId}`, ++this.nextId, (n = this.createElement("clipPath")).setAttribute("id", o), a.appendChild(n), r[s] = n); const l = this.getSvgProxy(r); if (r.transform && r.parent.invTransform && !i) { const u = Array.prototype.slice.call(r.transform); bt(r.transform, r.parent.invTransform, r.transform), l.brush(r), r.transform = u; } else l.brush(r); const h = this.getSvgElement(r); n.innerHTML = "", n.appendChild(h.cloneNode()), t.setAttribute("clip-path", `url(#${o})`), e.length > 1 && this.updateDom(n, e.slice(1), i); } else t && t.setAttribute("clip-path", "none"); }, L_.prototype.markUsed = function (t) { const e = this; t.__clipPaths && t.__clipPaths.length > 0 && d(t.__clipPaths, (t) => { t._dom && D_.prototype.markUsed.call(e, t._dom), t._textDom && D_.prototype.markUsed.call(e, t._textDom); }); }, u(k_, D_), k_.prototype.addWithoutUpdate = function (t, e) { if (e && P_(e.style)) { let i; const n = e.style; n._shadowDom ? (i = n._shadowDom, this.getDefs(!0).contains(n._shadowDom) || this.addDom(i)) : i = this.add(e), this.markUsed(e); const o = i.getAttribute("id"); t.style.filter = `url(#${o})`; } }, k_.prototype.add = function (t) { const e = this.createElement("filter"); const i = t.style; return i._shadowDomId = i._shadowDomId || this.nextId++, e.setAttribute("id", `zr${this._zrId}-shadow-${i._shadowDomId}`), this.updateDom(t, e), this.addDom(e), e; }, k_.prototype.update = function (t, e) { const i = e.style; if (P_(i)) { const n = this; D_.prototype.update.call(this, e, (t) => { n.updateDom(e, t._shadowDom); }); } else this.remove(t, i); }, k_.prototype.remove = function (t, e) { e._shadowDomId != null && (this.removeDom(e), t.style.filter = ""); }, k_.prototype.updateDom = function (t, e) { let i = e.getElementsByTagName("feDropShadow"); i = i.length === 0 ? this.createElement("feDropShadow") : i[0]; let n; let o; let a; let r; const s = t.style; const l = t.scale ? t.scale[0] || 1 : 1; const u = t.scale ? t.scale[1] || 1 : 1; if (s.shadowBlur || s.shadowOffsetX || s.shadowOffsetY)n = s.shadowOffsetX || 0, o = s.shadowOffsetY || 0, a = s.shadowBlur, r = s.shadowColor; else { if (!s.textShadowBlur) return void this.removeDom(e, s); n = s.textShadowOffsetX || 0, o = s.textShadowOffsetY || 0, a = s.textShadowBlur, r = s.textShadowColor; }i.setAttribute("dx", n / l), i.setAttribute("dy", o / u), i.setAttribute("flood-color", r); const h = `${a / 2 / l} ${a / 2 / u}`; i.setAttribute("stdDeviation", h), e.setAttribute("x", "-100%"), e.setAttribute("y", "-100%"), e.setAttribute("width", `${Math.ceil(a / 2 * 200)}%`), e.setAttribute("height", `${Math.ceil(a / 2 * 200)}%`), e.appendChild(i), s._shadowDom = e; }, k_.prototype.markUsed = function (t) { const e = t.style; e && e._shadowDom && D_.prototype.markUsed.call(this, e._shadowDom); }; const TR = function (t, e, i, n) { this.root = t, this.storage = e, this._opts = i = a({}, i || {}); const o = p_("svg"); o.setAttribute("xmlns", "http://www.w3.org/2000/svg"), o.setAttribute("version", "1.1"), o.setAttribute("baseProfile", "full"), o.style.cssText = "user-select:none;position:absolute;left:0;top:0;", this.gradientManager = new C_(n, o), this.clipPathManager = new L_(n, o), this.shadowManager = new k_(n, o); const r = document.createElement("div"); r.style.cssText = "overflow:hidden;position:relative", this._svgRoot = o, this._viewport = r, t.appendChild(r), r.appendChild(o), this.resize(i.width, i.height), this._visibleList = []; }; TR.prototype = {
    constructor: TR, getType() { return "svg"; }, getViewportRoot() { return this._viewport; }, getViewportRootOffset() { const t = this.getViewportRoot(); if (t) return { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 }; }, refresh() { const t = this.storage.getDisplayList(!0); this._paintList(t); }, setBackgroundColor(t) { this._viewport.style.background = t; }, _paintList(t) { this.gradientManager.markAllUnused(), this.clipPathManager.markAllUnused(), this.shadowManager.markAllUnused(); let e; const i = this._svgRoot; const n = this._visibleList; const o = t.length; const a = []; for (e = 0; e < o; e++) { const r = O_(f = t[e]); var s = G_(f) || V_(f); f.invisible || (f.__dirty && (r && r.brush(f), this.clipPathManager.update(f), f.style && (this.gradientManager.update(f.style.fill), this.gradientManager.update(f.style.stroke), this.shadowManager.update(s, f)), f.__dirty = !1), a.push(f)); } let l; const u = IR(n, a); for (e = 0; e < u.length; e++) if ((c = u[e]).removed) for (d = 0; d < c.count; d++) { var s = G_(f = n[c.indices[d]]); var h = V_(f); B_(i, s), B_(i, h); } for (e = 0; e < u.length; e++) { var c = u[e]; if (c.added) for (d = 0; d < c.count; d++) { var s = G_(f = a[c.indices[d]]); var h = V_(f); l ? R_(i, s, l) : z_(i, s), s ? R_(i, h, s) : l ? R_(i, h, l) : z_(i, h), R_(i, h, s), l = h || s || l, this.gradientManager.addWithoutUpdate(s, f), this.shadowManager.addWithoutUpdate(l, f), this.clipPathManager.markUsed(f); } else if (!c.removed) for (var d = 0; d < c.count; d++) { var f = a[c.indices[d]]; l = s = V_(f) || G_(f) || l, this.gradientManager.markUsed(f), this.gradientManager.addWithoutUpdate(s, f), this.shadowManager.markUsed(f), this.shadowManager.addWithoutUpdate(s, f), this.clipPathManager.markUsed(f); } } this.gradientManager.removeUnused(), this.clipPathManager.removeUnused(), this.shadowManager.removeUnused(), this._visibleList = a; }, _getDefs(t) { const e = this._svgRoot; let i = this._svgRoot.getElementsByTagName("defs"); return i.length === 0 ? t ? ((i = e.insertBefore(p_("defs"), e.firstChild)).contains || (i.contains = function (t) { const e = i.children; if (!e) return !1; for (let n = e.length - 1; n >= 0; --n) if (e[n] === t) return !0; return !1; }), i) : null : i[0]; }, resize(t, e) { const i = this._viewport; i.style.display = "none"; const n = this._opts; if (t != null && (n.width = t), e != null && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width !== t || this._height !== e) { this._width = t, this._height = e; const o = i.style; o.width = `${t}px`, o.height = `${e}px`; const a = this._svgRoot; a.setAttribute("width", t), a.setAttribute("height", e); } }, getWidth() { return this._width; }, getHeight() { return this._height; }, _getSize(t) { const e = this._opts; const i = ["width", "height"][t]; const n = ["clientWidth", "clientHeight"][t]; const o = ["paddingLeft", "paddingTop"][t]; const a = ["paddingRight", "paddingBottom"][t]; if (e[i] != null && e[i] !== "auto") return parseFloat(e[i]); const r = this.root; const s = document.defaultView.getComputedStyle(r); return (r[n] || N_(s[i]) || N_(r.style[i])) - (N_(s[o]) || 0) - (N_(s[a]) || 0) | 0; }, dispose() { this.root.innerHTML = "", this._svgRoot = this._viewport = this.storage = null; }, clear() { this._viewport && this.root.removeChild(this._viewport); }, pathToDataUrl() { return this.refresh(), `data:image/svg+xml;charset=UTF-8,${this._svgRoot.outerHTML}`; },
  }, d(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], (t) => { TR.prototype[t] = F_(t); }), Ti("svg", TR), t.version = "4.2.1", t.dependencies = RT, t.PRIORITY = GT, t.init = function (t, e, i) { const n = Ls(t); if (n) return n; const o = new ls(t, e, i); return o.id = `ec_${nA++}`, eA[o.id] = o, Fi(t, aA, o.id), Ds(o), o; }, t.connect = function (t) { if (y(t)) { const e = t; t = null, PT(e, (e) => { e.group != null && (t = e.group); }), t = t || `g_${oA++}`, PT(e, (e) => { e.group = t; }); } return iA[t] = !0, t; }, t.disConnect = Cs, t.disconnect = rA, t.dispose = function (t) { typeof t === "string" ? t = eA[t] : t instanceof ls || (t = Ls(t)), t instanceof ls && !t.isDisposed() && t.dispose(); }, t.getInstanceByDom = Ls, t.getInstanceById = function (t) { return eA[t]; }, t.registerTheme = ks, t.registerPreprocessor = Ps, t.registerProcessor = Ns, t.registerPostUpdate = function (t) { $T.push(t); }, t.registerAction = Os, t.registerCoordinateSystem = Es, t.getCoordinateSystemDimensions = function (t) { const e = Ga.get(t); if (e) return e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice(); }, t.registerLayout = Rs, t.registerVisual = zs, t.registerLoading = Vs, t.extendComponentModel = Gs, t.extendComponentView = Fs, t.extendSeriesModel = Ws, t.extendChartView = Hs, t.setCanvasCreator = function (t) { e("createCanvas", t); }, t.registerMap = function (t, e, i) { CT.registerMap(t, e, i); }, t.getMap = function (t) { const e = CT.retrieveMap(t); return e && e[0] && { geoJson: e[0].geoJSON, specialAreas: e[0].specialAreas }; }, t.dataTool = sA, t.zrender = Hb, t.number = YM, t.format = iI, t.throttle = kr, t.helper = eD, t.matrix = Sw, t.vector = cw, t.color = Ww, t.parseGeoJSON = nD, t.parseGeoJson = sD, t.util = lD, t.graphic = uD, t.List = yA, t.Model = Po, t.Axis = rD, t.env = U_;
}));
